// node_modules/molstar/lib/mol-util/bit-flags.js
var BitFlags;
(function(BitFlags2) {
  function create(flags) {
    return flags;
  }
  BitFlags2.create = create;
  function has(flags, flag) {
    return (flags & flag) !== 0;
  }
  BitFlags2.has = has;
  function hasAll(flags, toCheck) {
    return !!toCheck && (flags & toCheck) === toCheck;
  }
  BitFlags2.hasAll = hasAll;
})(BitFlags || (BitFlags = {}));

// node_modules/molstar/lib/mol-util/string-builder.js
var StringBuilder;
(function(StringBuilder2) {
  function create(chunkCapacity = 512) {
    return {
      current: [],
      offset: 0,
      capacity: chunkCapacity,
      chunks: []
    };
  }
  StringBuilder2.create = create;
  function getString(builder) {
    if (!builder.chunks.length) {
      if (builder.current.length === builder.offset)
        return builder.current.join("");
      return builder.current.splice(0, builder.offset).join("");
    }
    if (builder.offset > 0) {
      builder.chunks[builder.chunks.length] = builder.current.length === builder.offset ? builder.current.join("") : builder.current.slice(0, builder.offset).join("");
    }
    return builder.chunks.join("");
  }
  StringBuilder2.getString = getString;
  function getSize(builder) {
    let size = 0;
    for (const c of builder.chunks)
      size += c.length;
    for (let i = 0; i < builder.offset; i++)
      size += builder.current[i].length;
    return size;
  }
  StringBuilder2.getSize = getSize;
  function getChunks(builder) {
    if (builder.offset > 0) {
      if (builder.current.length === builder.offset)
        builder.chunks[builder.chunks.length] = builder.current.join("");
      else
        builder.chunks[builder.chunks.length] = builder.current.slice(0, builder.offset).join("");
      builder.offset = 0;
    }
    return builder.chunks;
  }
  StringBuilder2.getChunks = getChunks;
  let PaddingSpaces;
  (function(PaddingSpaces2) {
    PaddingSpaces2[PaddingSpaces2["Count"] = 512] = "Count";
  })(PaddingSpaces || (PaddingSpaces = {}));
  const __paddingSpaces = [];
  (function() {
    let s = "";
    for (let i = 0; i < PaddingSpaces.Count; i++) {
      __paddingSpaces[i] = s;
      s = s + " ";
    }
  })();
  function newline(builder) {
    writeSafe(builder, "\n");
  }
  StringBuilder2.newline = newline;
  function whitespace(builder, len) {
    if (len > 0)
      writeSafe(builder, __paddingSpaces[len]);
  }
  StringBuilder2.whitespace = whitespace;
  function whitespace1(builder) {
    writeSafe(builder, " ");
  }
  StringBuilder2.whitespace1 = whitespace1;
  function write(builder, val) {
    if (!val)
      return;
    if (builder.offset === builder.capacity) {
      builder.chunks[builder.chunks.length] = builder.current.join("");
      builder.offset = 0;
    }
    builder.current[builder.offset++] = val;
  }
  StringBuilder2.write = write;
  function writeSafe(builder, val) {
    if (builder.offset === builder.capacity) {
      builder.chunks[builder.chunks.length] = builder.current.join("");
      builder.offset = 0;
    }
    builder.current[builder.offset++] = val;
  }
  StringBuilder2.writeSafe = writeSafe;
  function writePadLeft(builder, val, totalWidth) {
    if (!val) {
      whitespace(builder, totalWidth);
      return;
    }
    const padding = totalWidth - val.length;
    whitespace(builder, padding);
    writeSafe(builder, val);
  }
  StringBuilder2.writePadLeft = writePadLeft;
  function writePadRight(builder, val, totalWidth) {
    if (!val) {
      whitespace(builder, totalWidth);
      return;
    }
    const padding = totalWidth - val.length;
    writeSafe(builder, val);
    whitespace(builder, padding);
  }
  StringBuilder2.writePadRight = writePadRight;
  function writeInteger(builder, val) {
    writeSafe(builder, "" + val);
  }
  StringBuilder2.writeInteger = writeInteger;
  function writeIntegerAndSpace(builder, val) {
    writeSafe(builder, "" + val + " ");
  }
  StringBuilder2.writeIntegerAndSpace = writeIntegerAndSpace;
  function writeIntegerPadLeft(builder, val, totalWidth) {
    const s = "" + val;
    const padding = totalWidth - s.length;
    whitespace(builder, padding);
    writeSafe(builder, s);
  }
  StringBuilder2.writeIntegerPadLeft = writeIntegerPadLeft;
  function writeIntegerPadRight(builder, val, totalWidth) {
    const s = "" + val;
    const padding = totalWidth - s.length;
    writeSafe(builder, s);
    whitespace(builder, padding);
  }
  StringBuilder2.writeIntegerPadRight = writeIntegerPadRight;
  function writeFloat(builder, val, precisionMultiplier) {
    writeSafe(builder, "" + Math.round(precisionMultiplier * val) / precisionMultiplier);
  }
  StringBuilder2.writeFloat = writeFloat;
  function writeFloatPadLeft(builder, val, precisionMultiplier, totalWidth) {
    const s = "" + Math.round(precisionMultiplier * val) / precisionMultiplier;
    const padding = totalWidth - s.length;
    whitespace(builder, padding);
    writeSafe(builder, s);
  }
  StringBuilder2.writeFloatPadLeft = writeFloatPadLeft;
  function writeFloatPadRight(builder, val, precisionMultiplier, totalWidth) {
    const s = "" + Math.round(precisionMultiplier * val) / precisionMultiplier;
    const padding = totalWidth - s.length;
    writeSafe(builder, s);
    whitespace(builder, padding);
  }
  StringBuilder2.writeFloatPadRight = writeFloatPadRight;
})(StringBuilder || (StringBuilder = {}));

// node_modules/molstar/lib/mol-util/now.js
var now = function() {
  if (typeof window !== "undefined" && window.performance) {
    const perf = window.performance;
    return () => perf.now();
  } else if (typeof process !== "undefined" && process.hrtime !== "undefined" && typeof process.hrtime === "function") {
    return () => {
      const t = process.hrtime();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (Date.now) {
    return () => Date.now();
  } else {
    return () => +/* @__PURE__ */ new Date();
  }
}();
function formatTimespan(t, includeMsZeroes = true) {
  if (isNaN(t))
    return "n/a";
  const h = Math.floor(t / (60 * 60 * 1e3)), m = Math.floor(t / (60 * 1e3) % 60), s = Math.floor(t / 1e3 % 60);
  let ms = Math.floor(t % 1e3).toString();
  while (ms.length < 3)
    ms = "0" + ms;
  while (!includeMsZeroes && ms.length > 1 && ms[ms.length - 1] === "0")
    ms = ms.substr(0, ms.length - 1);
  if (h > 0)
    return `${h}h${m}m${s}.${ms}s`;
  if (m > 0)
    return `${m}m${s}.${ms}s`;
  if (s > 0)
    return `${s}.${ms}s`;
  return `${t.toFixed(0)}ms`;
}

// node_modules/molstar/lib/mol-util/uuid.js
var UUID;
(function(UUID2) {
  const _btoa = typeof btoa !== "undefined" ? btoa : (s) => Buffer.from(s).toString("base64");
  const chars = [];
  function create22() {
    let d = +/* @__PURE__ */ new Date() + now();
    for (let i = 0; i < 16; i++) {
      chars[i] = String.fromCharCode((d + Math.random() * 255) % 255 | 0);
      d = Math.floor(d / 255);
    }
    return _btoa(chars.join("")).replace(/\+/g, "-").replace(/\//g, "_").substr(0, 22);
  }
  UUID2.create22 = create22;
  function createv4() {
    let d = +/* @__PURE__ */ new Date() + now();
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
    return uuid;
  }
  UUID2.createv4 = createv4;
  function is(x) {
    return typeof x === "string";
  }
  UUID2.is = is;
})(UUID || (UUID = {}));

// node_modules/molstar/lib/mol-util/mask.js
function _ascSort(a, b) {
  return a - b;
}
function sortAsc(array) {
  Array.prototype.sort.call(array, _ascSort);
  return array;
}
var Mask;
(function(Mask2) {
  class EmptyMask {
    has(i) {
      return false;
    }
    forEach(f, ctx) {
      return ctx;
    }
    constructor() {
      this.size = 0;
    }
  }
  class SingletonMask {
    has(i) {
      return i === this.idx;
    }
    forEach(f, ctx) {
      f(this.idx, ctx);
      return ctx;
    }
    constructor(idx) {
      this.idx = idx;
      this.size = 1;
    }
  }
  class BitMask {
    has(i) {
      return i < this.length && !!this.mask[i];
    }
    _forEach(f, ctx) {
      for (let i = 0; i < this.length; i++) {
        if (this.mask[i])
          f(i, ctx);
      }
    }
    forEach(f, ctx) {
      this._forEach(f, ctx);
      return ctx;
    }
    constructor(mask, size) {
      this.mask = mask;
      this.size = size;
      this.length = mask.length;
    }
  }
  class AllMask {
    has(i) {
      return true;
    }
    _forEach(f, ctx) {
      for (let i = 0; i < this.size; i++) {
        f(i, ctx);
      }
    }
    forEach(f, ctx) {
      this._forEach(f, ctx);
      return ctx;
    }
    constructor(size) {
      this.size = size;
    }
  }
  class SetMask {
    has(i) {
      return this.set.has(i);
    }
    _forEach(f, ctx) {
      for (const idx of this.flatten()) {
        f(idx, ctx);
      }
    }
    flatten() {
      if (this._flat)
        return this._flat;
      const indices = new Int32Array(this.size);
      let offset = 0;
      this.set.forEach((i) => indices[offset++] = i);
      sortAsc(indices);
      this._flat = indices;
      return this._flat;
    }
    forEach(f, ctx) {
      this._forEach(f, ctx);
      return ctx;
    }
    constructor(set) {
      this.set = set;
      this._flat = void 0;
      this.size = set.size;
    }
  }
  function always(size) {
    return new AllMask(size);
  }
  Mask2.always = always;
  Mask2.never = new EmptyMask();
  function ofSet(set) {
    return new SetMask(set);
  }
  Mask2.ofSet = ofSet;
  function singleton(i) {
    return new SingletonMask(i);
  }
  Mask2.singleton = singleton;
  function ofUniqueIndices(indices) {
    const len = indices.length;
    if (len === 0)
      return new EmptyMask();
    if (len === 1)
      return new SingletonMask(indices[0]);
    let max = 0;
    for (const i of indices) {
      if (i > max)
        max = i;
    }
    if (len === max)
      return new AllMask(len);
    const f = len / max;
    if (f < 1 / 12) {
      const set = /* @__PURE__ */ new Set();
      for (const i of indices)
        set.add(i);
      return new SetMask(set);
    }
    const mask = new Int8Array(max + 1);
    for (const i of indices) {
      mask[i] = 1;
    }
    return new BitMask(mask, indices.length);
  }
  Mask2.ofUniqueIndices = ofUniqueIndices;
  function ofMask(mask, size) {
    return new BitMask(mask, size);
  }
  Mask2.ofMask = ofMask;
  function hasAny(mask, xs) {
    for (const x of xs) {
      if (mask.has(x))
        return true;
    }
    return false;
  }
  Mask2.hasAny = hasAny;
  function complement(mask, against) {
    let count = 0;
    let max = 0;
    against.forEach((i) => {
      if (!mask.has(i)) {
        count++;
        if (i > max)
          max = i;
      }
    });
    if (count / max < 1 / 12) {
      const set = /* @__PURE__ */ new Set();
      against.forEach((i) => {
        if (!mask.has(i)) {
          set.add(i);
        }
      });
      return ofSet(set);
    } else {
      const target = new Uint8Array(max + 1);
      against.forEach((i) => {
        if (!mask.has(i)) {
          target[i] = 1;
        }
      });
      return ofMask(target, count);
    }
  }
  Mask2.complement = complement;
})(Mask || (Mask = {}));

// node_modules/molstar/lib/mol-util/id-factory.js
function idFactory(firstId = 0, maxId = Number.MAX_SAFE_INTEGER) {
  let _nextId = firstId;
  return () => {
    const ret = _nextId;
    _nextId = (_nextId + 1) % maxId;
    return ret;
  };
}

// node_modules/molstar/lib/mol-util/value-cell.js
var ValueRef;
(function(ValueRef2) {
  function create(ref) {
    return { ref };
  }
  ValueRef2.create = create;
  function set(ref, value) {
    ref.ref = value;
    return ref;
  }
  ValueRef2.set = set;
})(ValueRef || (ValueRef = {}));
var getNextId = idFactory(0, 2147483647);
var ValueBox;
(function(ValueBox2) {
  function create(value, metadata) {
    return { id: getNextId(), version: 0, value, metadata };
  }
  ValueBox2.create = create;
  function withValue(box, value) {
    return { id: box.id, version: box.version + 1, value, metadata: box.metadata };
  }
  ValueBox2.withValue = withValue;
})(ValueBox || (ValueBox = {}));
var ValueCell;
(function(ValueCell2) {
  function create(value, metadata) {
    return ValueRef.create(ValueBox.create(value, metadata));
  }
  ValueCell2.create = create;
  function update(cell, value) {
    return ValueRef.set(cell, ValueBox.withValue(cell.ref, value));
  }
  ValueCell2.update = update;
  function set(cell, box) {
    return ValueRef.set(cell, box);
  }
  ValueCell2.set = set;
  function updateIfChanged(cell, value) {
    return cell.ref.value !== value ? update(cell, value) : cell;
  }
  ValueCell2.updateIfChanged = updateIfChanged;
})(ValueCell || (ValueCell = {}));

// node_modules/molstar/lib/mol-util/index.js
var noop = function() {
};
function round(n, d) {
  const f = Math.pow(10, d);
  return Math.round(f * n) / f;
}
function arrayEqual(arr1, arr2) {
  const length = arr1.length;
  if (length !== arr2.length)
    return false;
  for (let i = 0; i < length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function deepEqual(a, b) {
  if (a === b)
    return true;
  const arrA = Array.isArray(a);
  const arrB = Array.isArray(b);
  if (arrA && arrB) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i]))
        return false;
    }
    return true;
  }
  if (arrA !== arrB)
    return false;
  if (a && b && typeof a === "object" && typeof b === "object") {
    const keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length)
      return false;
    const dateA = a instanceof Date;
    const dateB = b instanceof Date;
    if (dateA && dateB)
      return a.getTime() === b.getTime();
    if (dateA !== dateB)
      return false;
    const regexpA = a instanceof RegExp;
    const regexpB = b instanceof RegExp;
    if (regexpA && regexpB)
      return a.toString() === b.toString();
    if (regexpA !== regexpB)
      return false;
    for (let i = 0; i < keys.length; i++) {
      if (!hasOwnProperty.call(b, keys[i]))
        return false;
    }
    for (let i = 0; i < keys.length; i++) {
      if (!deepEqual(a[keys[i]], b[keys[i]]))
        return false;
    }
    return true;
  }
  return false;
}
function shallowEqual(a, b) {
  if (a === b)
    return true;
  const arrA = Array.isArray(a);
  const arrB = Array.isArray(b);
  if (arrA && arrB)
    return shallowEqualArrays(a, b);
  if (arrA !== arrB)
    return false;
  if (a && b && typeof a === "object" && typeof b === "object") {
    return shallowEqualObjects(a, b);
  }
  return false;
}
function shallowEqualObjects(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  const keys = Object.keys(a);
  if (Object.keys(b).length !== keys.length)
    return false;
  for (const k of keys) {
    if (!hasOwnProperty.call(a, k) || a[k] !== b[k])
      return false;
  }
  return true;
}
function shallowEqualArrays(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  if (a.length !== b.length)
    return false;
  for (let i = 0, il = a.length; i < il; ++i) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function defaults(value, defaultValue) {
  return value !== void 0 ? value : defaultValue;
}
function padTime(n) {
  return (n < 10 ? "0" : "") + n;
}
function formatTime(d) {
  const h = d.getHours(), m = d.getMinutes(), s = d.getSeconds();
  return `${h}:${padTime(m)}:${padTime(s)}`;
}

// node_modules/molstar/lib/mol-plugin/command.js
function PluginCommand() {
  const ret = (ctx, params) => ctx.commands.dispatch(ret, params || {});
  ret.subscribe = (ctx, action) => ctx.commands.subscribe(ret, action);
  ret.id = UUID.create22();
  return ret;
}
var PluginCommandManager = class {
  constructor() {
    this.subs = /* @__PURE__ */ new Map();
    this.disposing = false;
  }
  subscribe(cmd, action) {
    let actions = this.subs.get(cmd.id);
    if (!actions) {
      actions = [];
      this.subs.set(cmd.id, actions);
    }
    actions.push(action);
    return {
      unsubscribe: () => {
        const actions2 = this.subs.get(cmd.id);
        if (!actions2)
          return;
        const idx = actions2.indexOf(action);
        if (idx < 0)
          return;
        for (let i = idx + 1; i < actions2.length; i++) {
          actions2[i - 1] = actions2[i];
        }
        actions2.pop();
      }
    };
  }
  /** Resolves after all actions have completed */
  dispatch(cmd, params) {
    return new Promise((resolve, reject) => {
      if (this.disposing) {
        reject("disposed");
        return;
      }
      const actions = this.subs.get(cmd.id);
      if (!actions) {
        resolve();
        return;
      }
      this.resolve({ cmd, params, resolve, reject });
    });
  }
  dispose() {
    this.subs.clear();
  }
  async resolve(instance) {
    const actions = this.subs.get(instance.cmd.id);
    if (!actions) {
      instance.resolve();
      return;
    }
    try {
      for (const a of actions) {
        await a(instance.params);
      }
      instance.resolve();
    } catch (e) {
      instance.reject(e);
    }
  }
};

// node_modules/molstar/lib/mol-plugin/commands.js
var PluginCommands = {
  State: {
    SetCurrentObject: PluginCommand(),
    ApplyAction: PluginCommand(),
    Update: PluginCommand(),
    RemoveObject: PluginCommand(),
    ToggleExpanded: PluginCommand(),
    ToggleVisibility: PluginCommand(),
    Snapshots: {
      Add: PluginCommand(),
      Replace: PluginCommand(),
      Move: PluginCommand(),
      Remove: PluginCommand(),
      Apply: PluginCommand(),
      Clear: PluginCommand(),
      Upload: PluginCommand(),
      Fetch: PluginCommand(),
      DownloadToFile: PluginCommand(),
      OpenFile: PluginCommand(),
      OpenUrl: PluginCommand()
    }
  },
  Interactivity: {
    Object: {
      Highlight: PluginCommand()
    },
    Structure: {
      Highlight: PluginCommand(),
      Select: PluginCommand()
    },
    ClearHighlights: PluginCommand()
  },
  Layout: {
    Update: PluginCommand()
  },
  Toast: {
    Show: PluginCommand(),
    Hide: PluginCommand()
  },
  Camera: {
    Reset: PluginCommand(),
    SetSnapshot: PluginCommand(),
    Focus: PluginCommand(),
    FocusObject: PluginCommand(),
    OrientAxes: PluginCommand(),
    ResetAxes: PluginCommand()
  },
  Canvas3D: {
    SetSettings: PluginCommand(),
    ResetSettings: PluginCommand()
  }
};

export {
  BitFlags,
  StringBuilder,
  now,
  formatTimespan,
  UUID,
  idFactory,
  ValueBox,
  ValueCell,
  noop,
  round,
  arrayEqual,
  deepEqual,
  shallowEqual,
  shallowEqualObjects,
  defaults,
  formatTime,
  PluginCommandManager,
  PluginCommands
};
//# sourceMappingURL=chunk-XTJKDAVG.js.map
