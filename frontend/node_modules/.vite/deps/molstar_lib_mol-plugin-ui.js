import {
  AccountTreeOutlinedSvg,
  ActionMenu,
  AddSvg,
  ArrowDownwardSvg,
  ArrowDropDownSvg,
  ArrowRightSvg,
  ArrowUpwardSvg,
  Asset,
  AssetManager,
  AtomSiteAnisotrop,
  AttributeSpec,
  AutorenewSvg,
  Axes3D,
  BaseGeometry,
  BehaviorSubject,
  Binding,
  BlurOnSvg,
  Bond,
  BondType,
  BookmarksOutlinedSvg,
  BoundaryHelper,
  Box,
  Box3D,
  BrushSvg,
  BuildOutlinedSvg,
  BuildSvg,
  BuiltInCoordinatesFormats,
  BuiltInPluginBehaviors,
  BuiltInTopologyFormats,
  BuiltInTrajectoryFormats,
  Button,
  ButtonsType,
  Camera,
  CameraHelperParams,
  CameraOutlinedSvg,
  CameraSvg,
  CancelOutlinedSvg,
  CancelSvg,
  Canvas3D,
  Canvas3DContext,
  Canvas3DParams,
  CenterFocusStrongSvg,
  CentroidHelper,
  CheckSvg,
  ChunkedArray,
  Clip,
  Clipping,
  CloseSvg,
  CloudUploadSvg,
  CodeSvg,
  CollapsableControls,
  Color,
  ColorNames,
  ColorSmoothingParams,
  ColorTheme,
  CombinedColorControl,
  CommonSurfaceParams,
  ComplexCylindersParams,
  ComplexCylindersVisual,
  ComplexDirectVolumeParams,
  ComplexDirectVolumeVisual,
  ComplexImageParams,
  ComplexImageVisual,
  ComplexLinesParams,
  ComplexLinesVisual,
  ComplexMeshParams,
  ComplexMeshVisual,
  ComplexPointsParams,
  ComplexPointsVisual,
  ComplexRepresentation,
  ComplexSpheresParams,
  ComplexSpheresVisual,
  ComplexTextParams,
  ComplexTextVisual,
  ComplexTextureMeshParams,
  ComplexTextureMeshVisual,
  ControlGroup,
  ControlRow,
  CopySvg,
  CreateObservableCtx,
  CropFreeSvg,
  CropOrginalSvg,
  CropSvg,
  CubeOutlineSvg,
  CustomModelProperty,
  CustomPropertyDescriptor,
  Cylinders,
  CylindersBuilder,
  DataFormatProvider,
  DefaultCanvas3DParams,
  DefaultPluginUISpec,
  DefineSpec,
  DeleteOutlinedSvg,
  DiamondPrism,
  DirectVolume,
  Download,
  DownloadBlob,
  EPSILON,
  Emissive,
  EmptyKeyInput,
  EmptyLinkBuilderProps,
  EmptyLocationIterator,
  EmptyLoci,
  ErrorSvg,
  EveryLoci,
  ExecuteInContext,
  ExpandGroup,
  FocusLoci,
  FullscreenSvg,
  GetAppSvg,
  GridLookup3D,
  HelpOutlineSvg,
  HeptagonalPrism,
  HexagonalPrism,
  HomeOutlinedSvg,
  Icon,
  IconButton,
  Image,
  InitVolumeStreaming,
  IntAdjacencyGraph,
  InteractionsProvider,
  InterpolationTypes,
  IntersectSvg,
  Interval,
  Lines,
  LinesBuilder,
  LinkCylinderParams,
  LinkLineParams,
  LinkStyle,
  List,
  LocationIterator,
  Loci,
  LogEntry,
  MagicWandSvg,
  MarkerAction,
  Mat3,
  Mat4,
  Material,
  Matrix,
  MeasurementRepresentationCommonTextParams,
  Mesh,
  MeshBuilder,
  MetalsSet,
  Model,
  ModelSymmetry,
  ModifiersKeys,
  MolScriptBuilder,
  MoleculeSvg,
  MoleculeType,
  MoreHorizSvg,
  NavigateBeforeSvg,
  NavigateNextSvg,
  ObjectKeys,
  OpenFiles,
  OpenInBrowserSvg,
  OperatorNameColorThemeProvider,
  OrderedMap,
  OrderedSet,
  Overpaint,
  PLUGIN_VERSION,
  PLUGIN_VERSION_DATE,
  ParamDefinition,
  ParamHelp,
  ParameterControls,
  ParameterMappingControl,
  PencilRulerSvg,
  PentagonalPrism,
  PerforatedBox,
  Plane3D,
  PlayArrowSvg,
  PluginBehavior,
  PluginComponent,
  PluginConfig,
  PluginConfigManager,
  PluginReactContext,
  PluginStateObject,
  PluginStateSnapshotManager,
  PluginUIComponent,
  Points,
  PointsBuilder,
  PositionLocation,
  PostprocessingParams,
  PresetStructureRepresentations,
  PrimitiveBuilder,
  PrincipalAxes,
  PurePluginUIComponent,
  PureSelectControl,
  Quat,
  Queries,
  QueryContext,
  RawData,
  ReadFile,
  RefreshSvg,
  RemoveSvg,
  Representation,
  RepresentationRegistry,
  RestoreSvg,
  RootStructureDefinition,
  RxEventHelper,
  SIFTSMapping,
  SaccharideShape,
  SaveOutlinedSvg,
  Scheduler,
  SecondaryStructureProvider,
  SecondaryStructureType,
  SectionHeader,
  Segmentation,
  SelectLoci,
  SelectionModeSvg,
  SetSvg,
  SetUtils,
  ShaderCode,
  ShiftedHexagonalPrism,
  SizeTheme,
  SkipPreviousSvg,
  SortedArray,
  SortedRanges,
  SpacegroupCell,
  Sphere3D,
  Spheres,
  SpheresBuilder,
  State,
  StateObject,
  StateObjectRef,
  StateSelection,
  StateTransforms,
  StateTree,
  StateTreeSpine,
  StatefulPluginComponent,
  StopSvg,
  Structure,
  StructureFocusRepresentation,
  StructureProperties,
  StructureQuery,
  StructureRepresentation3D,
  StructureRepresentationPresetProvider,
  StructureRepresentationProvider,
  StructureRepresentationStateBuilder,
  StructureSelection,
  StructureSelectionQueries,
  StructureSelectionQueryRegistry,
  Subject,
  SubscriptionsOutlinedSvg,
  Substance,
  SubtractSvg,
  SuperposeAtomsSvg,
  SuperposeChainsSvg,
  SuperpositionSvg,
  SwapHorizSvg,
  Task,
  Tensor,
  TextBuilder,
  TextInput,
  TextureMesh,
  TextureSpec,
  ToggleButton,
  ToggleParamHelpButton,
  Transform,
  Transformer,
  Transparency,
  TuneSvg,
  UniformSpec,
  UnionSvg,
  UniqueArray,
  Unit,
  UnitsCylindersParams,
  UnitsCylindersVisual,
  UnitsDirectVolumeParams,
  UnitsDirectVolumeVisual,
  UnitsLinesParams,
  UnitsLinesVisual,
  UnitsMeshParams,
  UnitsMeshVisual,
  UnitsPointsParams,
  UnitsPointsVisual,
  UnitsRepresentation,
  UnitsSpheresParams,
  UnitsSpheresVisual,
  UnitsTextureMeshParams,
  UnitsTextureMeshVisual,
  UpdateTrajectory,
  ValueSpec,
  Vec2,
  Vec3,
  VisibilityOffOutlinedSvg,
  VisibilityOutlinedSvg,
  VisualQualityOptions,
  Volume,
  VolumeRepresentation3DHelpers,
  VolumeRepresentationRegistry,
  VolumeStreaming,
  WarningSvg,
  addCylinder,
  addEllipsoid,
  addFixedCountDashedCylinder,
  addSphere,
  ajaxGet,
  angleLabel,
  applyMarkerAction,
  applyMeshColorSmoothing,
  applyTextureMeshColorSmoothing,
  arrayEqual as arrayEqual2,
  arrayFind,
  arrayIntersectionSize,
  arrayRemoveAtInPlace,
  arrayRemoveInPlace,
  arraySetAdd,
  bondCount,
  cantorPairing,
  canvasToBlob,
  capitalize,
  clamp,
  compile,
  computeMarchingCubesLines,
  computeMarchingCubesMesh,
  createCage,
  createComputeRenderItem,
  createComputeRenderable,
  createLinkCylinderImpostors,
  createLinkCylinderMesh,
  createLinkLines,
  createPrimitive,
  createStructureColorThemeParams,
  createStructureRepresentationParams,
  createStructureSizeThemeParams,
  debounceTime,
  deepClone,
  degToRad,
  dihedralLabel,
  distanceLabel,
  download,
  elementLabel,
  element_exports,
  ensureReasonableResolution,
  equalEps,
  extractIsosurface,
  fasterExp,
  fillGridDim,
  filter,
  getAltResidueLoci,
  getAltResidueLociFromId,
  getButton,
  getButtons,
  getColorSmoothingProps,
  getContourLevelEmdb,
  getElementIdx,
  getElementQueries,
  getFileNameInfo,
  getModifiers,
  getNonStandardResidueQueries,
  getPolymerAndBranchedEntityQueries,
  getResidueLoci,
  getSaccharideShape,
  getStructureConformationAndRadius,
  getStructureQuality,
  getStructureThemeTypes,
  getUnitConformationAndRadius,
  getUnitKindsParam,
  getVolumeSliceInfo,
  guessCifVariant,
  isDebugMode,
  isEmptyLoci,
  isEveryLoci,
  isHydrogen,
  isNucleic,
  isProductionMode,
  isPurineBase,
  isPyrimidineBase,
  isTimingMode,
  isTrace,
  iterableToArray,
  lerp,
  lociLabel,
  memoizeLatest,
  merge,
  objectForEach,
  packIntToRGBArray,
  polygon,
  printTimerResults,
  produce,
  resizeCanvas,
  setAutoFreeze,
  setSaccharideCompIdMapType,
  setSubtreeVisibility,
  shallowEqual as shallowEqual2,
  skip,
  smoothstep,
  sphereVertexCount,
  stripTags,
  structureAreEqual,
  structureAreIntersecting,
  structureElementLociLabelMany,
  structureElementStatsLabel,
  structureIntersect,
  structureSubtract,
  structureUnion,
  take,
  throttleTime,
  transformPositionArray,
  urlCombine
} from "./chunk-WPJJZM3B.js";
import {
  BitFlags,
  PluginCommandManager,
  PluginCommands,
  UUID,
  ValueCell,
  arrayEqual,
  formatTime,
  formatTimespan,
  now,
  round,
  shallowEqual,
  shallowEqualObjects
} from "./chunk-XTJKDAVG.js";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/inline-style-parser/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/inline-style-parser/cjs/index.js"(exports, module) {
    "use strict";
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    function index2(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style) return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position3() {
        var start2 = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start2);
          whitespace2();
          return node2;
        };
      }
      function Position(start2) {
        this.start = start2;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) ;
        else {
          throw err;
        }
      }
      function match(re2) {
        var m = re2.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c4;
        rules = rules || [];
        while (c4 = comment()) {
          if (c4 !== false) {
            rules.push(c4);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position3();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
        var i = 2;
        while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position3();
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment();
        if (!match(COLON_REGEX)) return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    }
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
    module.exports = index2;
  }
});

// node_modules/style-to-object/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/style-to-object/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = StyleToObject;
    var inline_style_parser_1 = __importDefault(require_cjs());
    function StyleToObject(style, iterator) {
      let styleObject = null;
      if (!style || typeof style !== "string") {
        return styleObject;
      }
      const declarations = (0, inline_style_parser_1.default)(style);
      const hasIterator = typeof iterator === "function";
      declarations.forEach((declaration) => {
        if (declaration.type !== "declaration") {
          return;
        }
        const { property, value } = declaration;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          styleObject = styleObject || {};
          styleObject[property] = value;
        }
      });
      return styleObject;
    }
  }
});

// node_modules/style-to-js/cjs/utilities.js
var require_utilities = __commonJS({
  "node_modules/style-to-js/cjs/utilities.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelCase = void 0;
    var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
    var HYPHEN_REGEX = /-([a-z])/g;
    var NO_HYPHEN_REGEX = /^[^-]+$/;
    var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
    var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
    var skipCamelCase = function(property) {
      return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
    };
    var capitalize2 = function(match, character) {
      return character.toUpperCase();
    };
    var trimHyphen = function(match, prefix) {
      return "".concat(prefix, "-");
    };
    var camelCase = function(property, options) {
      if (options === void 0) {
        options = {};
      }
      if (skipCamelCase(property)) {
        return property;
      }
      property = property.toLowerCase();
      if (options.reactCompat) {
        property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
      } else {
        property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
      }
      return property.replace(HYPHEN_REGEX, capitalize2);
    };
    exports.camelCase = camelCase;
  }
});

// node_modules/style-to-js/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/style-to-js/cjs/index.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var style_to_object_1 = __importDefault(require_cjs2());
    var utilities_1 = require_utilities();
    function StyleToJS(style, options) {
      var output = {};
      if (!style || typeof style !== "string") {
        return output;
      }
      (0, style_to_object_1.default)(style, function(property, value) {
        if (property && value) {
          output[(0, utilities_1.camelCase)(property, options)] = value;
        }
      });
      return output;
    }
    StyleToJS.default = StyleToJS;
    module.exports = StyleToJS;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d3 = h * 24;
    var w = d3 * 7;
    var y = d3 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug2[key] = env2[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name2) {
        for (const skip2 of createDebug2.skips) {
          if (matchesTemplate(name2, skip2)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name2, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c4);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module.exports = function extend2() {
      var options, name2, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/molstar/lib/mol-plugin-ui/index.js
var import_react6 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin-ui/plugin.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var React10 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin-ui/controls.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var React3 = __toESM(require_react());

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function unreachable(message) {
  assert(false, false, true, "ok", "Unreachable", message);
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/comma-separated-tokens/index.js
function stringify(values2, options) {
  const settings = options || {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/estree-util-is-identifier-name/lib/index.js
var nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var emptyOptions = {};
function name(name2, options) {
  const settings = options || emptyOptions;
  const re2 = settings.jsx ? nameReJsx : nameRe;
  return re2.test(name2);
}

// node_modules/hast-util-whitespace/lib/index.js
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal3, space2) {
    this.normal = normal3;
    this.property = property;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;

// node_modules/property-information/lib/util/merge.js
function merge2(definitions, space2) {
  const property = {};
  const normal3 = {};
  for (const definition2 of definitions) {
    Object.assign(property, definition2.property);
    Object.assign(normal3, definition2.normal);
  }
  return new Schema(property, normal3, space2);
}

// node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute;
    this.property = property;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}

// node_modules/property-information/lib/util/create.js
function create(definition2) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition2.properties)) {
    const info = new DefinedInfo(
      property,
      definition2.transform(definition2.attributes || {}, property),
      value,
      definition2.space
    );
    if (definition2.mustUseProperty && definition2.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize(property)] = property;
    normals[normalize(info.attribute)] = property;
  }
  return new Schema(properties, normals, definition2.space);
}

// node_modules/property-information/lib/aria.js
var aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/property-information/lib/html.js
var html = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/svg.js
var svg = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// node_modules/property-information/lib/xlink.js
var xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/xml.js
var xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});

// node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find(schema, value) {
  const normal3 = normalize(value);
  let property = value;
  let Type = Info;
  if (normal3 in schema.normal) {
    return schema.property[schema.normal[normal3]];
  }
  if (normal3.length > 4 && normal3.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/index.js
var html2 = merge2([aria, html, xlink, xmlns, xml], "html");
var svg2 = merge2([aria, svg, xlink, xmlns, xml], "svg");

// node_modules/space-separated-tokens/index.js
function stringify2(values2) {
  return values2.join(" ").trim();
}

// node_modules/hast-util-to-jsx-runtime/lib/index.js
var import_style_to_js = __toESM(require_cjs3(), 1);

// node_modules/unist-util-position/lib/index.js
var pointEnd = point("end");
var pointStart = point("start");
function point(type) {
  return point4;
  function point4(node2) {
    const point5 = node2 && node2.position && node2.position[type] || {};
    if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
      return {
        line: point5.line,
        column: point5.column,
        offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
      };
    }
  }
}
function position(node2) {
  const start2 = pointStart(node2);
  const end = pointEnd(node2);
  if (start2 && end) {
    return { start: start2, end };
  }
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point2(value);
  }
  return "";
}
function point2(point4) {
  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/hast-util-to-jsx-runtime/lib/index.js
var own = {}.hasOwnProperty;
var emptyMap = /* @__PURE__ */ new Map();
var cap2 = /[A-Z]/g;
var tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
var tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
var docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create2;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create2 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create2 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create2,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg2 : html2,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one(state, node2, key) {
  if (node2.type === "element") {
    return element(state, node2, key);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root(state, node2, key);
  }
  if (node2.type === "text") {
    return text(state, node2);
  }
}
function element(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg2;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  if (tableElements.has(node2.tagName)) {
    children = children.filter(function(child) {
      return typeof child === "string" ? !whitespace(child) : true;
    });
  }
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg2;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren(state, node2);
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function root(state, node2, key) {
  const props = {};
  addChildren(props, createChildren(state, node2));
  return state.create(node2, state.Fragment, props, key);
}
function text(_, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_, jsx2, jsxs2) {
  return create2;
  function create2(_2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn = isStaticChildren ? jsxs2 : jsx2;
    return key ? fn(type, props, key) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create2;
  function create2(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point4 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point4 ? point4.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point4 ? point4.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok(objectExpression.type === "ObjectExpression");
        const property = objectExpression.properties[0];
        ok(property.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count2 = countsByName.get(name2) || 0;
        key = name2 + "-" + count2;
        countsByName.set(name2, count2 + 1);
      }
    }
    const result = one(state, child, key);
    if (result !== void 0) children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify(value) : stringify2(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  try {
    return (0, import_style_to_js.default)(value, { reactCompat: true });
  } catch (error) {
    if (state.ignoreInvalidStyle) {
      return {};
    }
    const cause = (
      /** @type {Error} */
      error
    );
    const message = new VFileMessage("Cannot parse `style` attribute", {
      ancestors: state.ancestors,
      cause,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    message.file = state.filePath || void 0;
    message.url = docs + "#cannot-parse-style-attribute";
    throw message;
  }
}
function findComponentFromName(state, name2, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name2 };
  } else if (name2.includes(".")) {
    const identifiers = name2.split(".");
    let index2 = -1;
    let node2;
    while (++index2 < identifiers.length) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index2 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    ok(node2, "always a result");
    result = node2;
  } else {
    result = name(name2) && !/^[a-z]/.test(name2) ? { type: "Identifier", name: name2 } : { type: "Literal", value: name2 };
  }
  if (result.type === "Literal") {
    const name3 = (
      /** @type {string | number} */
      result.value
    );
    return own.call(state.components, name3) ? state.components[name3] : name3;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing) {
    if (own.call(domCasing, from)) {
      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to = from.replace(cap2, toDash);
  if (to.slice(0, 3) === "ms-") to = "-" + to;
  return to;
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}

// node_modules/html-url-attributes/lib/index.js
var urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};

// node_modules/react-markdown/lib/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions2 = {};
function toString(value, options) {
  const settings = options || emptyOptions2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one2(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element2 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element2.innerHTML = characterReference2;
  const character = element2.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnt.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list3, start2, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list3.splice(...parameters);
  } else {
    if (remove) list3.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list3.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < codes.ht || code2 === codes.vt || code2 > codes.cr && code2 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code2 > codes.tilde && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code2);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < codes.space || code2 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < codes.nul || code2 === codes.space);
}
function markdownSpace(code2) {
  return code2 === codes.horizontalTab || code2 === codes.virtualSpace || code2 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start2 = 0;
  let skip2 = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace = "";
    if (code2 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip2 = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace = String.fromCharCode(code2, next);
        skip2 = 1;
      } else {
        replace = values.replacementCharacter;
      }
    } else {
      replace = String.fromCharCode(code2);
    }
    if (replace) {
      result.push(value.slice(start2, index2), encodeURIComponent(replace));
      start2 = index2 + skip2 + 1;
      replace = "";
    }
    if (skip2) {
      index2 += skip2;
      skip2 = 0;
    }
  }
  return result.join("") + value.slice(start2);
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start2;
  function start2(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok3(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok3(code2);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start2(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point4 };
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code2) {
  if (code2 === codes.eof || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code2)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text5;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start2 = { ...events[open][1].end };
          const end = { ...events[index2][1].start };
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: start2,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index2][1].start },
            end
          };
          text5 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index2][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index2][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text5, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text5, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start2;
  function start2(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code2);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code2);
  }
}
function movePoint(point4, offset) {
  point4.column += offset;
  point4.offset += offset;
  point4._bufferIndex += offset;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code2);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    if (code2 === codes.atSign) {
      return nok(code2);
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === codes.colon) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) && size++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.lessThan || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === codes.atSign) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === codes.dot) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === codes.dash || asciiAlphanumeric(code2)) && size++ < constants.autolinkDomainSizeMax) {
      const next = code2 === codes.dash ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, types.linePrefix)(code2) : after(code2);
  }
  function after(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code2);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok3, nok)(code2);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code2);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code2);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let max2;
  let test;
  return start2;
  function start2(code2) {
    ok(code2 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code2);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === codes.uppercaseX || code2 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max2 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === codes.semicolon && size) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code2) && size++ < max2) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    ok(
      code2 === codes.graveAccent || code2 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code2);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, types.whitespace)(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code2);
  }
  function info(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit(types.codeFenced);
    return ok3(code2);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      ok(markdownLineEnding(code2), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code2);
      effects2.exit(types.lineEnding);
      return start3;
    }
    function start3(code2) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === codes.eof || markdownLineEnding(code2)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(markdownSpace(code2));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.eof) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit(types.codeIndented);
    return ok3(code2);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start2;
  function start2(code2) {
    ok(code2 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code2);
  }
  function between(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.space) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.graveAccent || markdownLineEnding(code2)) {
      effects.exit(types.codeTextData);
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code2);
    }
    token.type = types.codeTextData;
    return data(code2);
  }
}

// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start2, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start2, stop);
    }
    if (start2 > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start2 + this.left.length
      ).reverse();
    }
    return this.left.slice(start2).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start2, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start2));
    const removed = this.right.splice(
      this.right.length - count2,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list3, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list3.push(...right);
  } else {
    while (chunkStart < right.length) {
      list3.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === types.chunkFlow && events.get(index2 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok(
      !previous2 || current.previous === previous2,
      "expected previous to match"
    );
    ok(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      ok(current, "expected a current token");
      start2 = index2 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.push([start3, start3 + slice.length - 1]);
    events.splice(start3, 2, slice);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous2 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === codes.eof) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code2);
  }
  function contentContinue(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.consume(code2);
    effects.exit(types.chunkContent);
    ok(previous2, "expected previous token");
    previous2.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code2) {
    if (code2 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.rightParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === codes.eof || code2 === codes.lessThan || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === codes.lessThan || code2 === codes.greaterThan || code2 === codes.backslash) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === codes.eof || code2 === codes.rightParenthesis || markdownLineEndingOrSpace(code2))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code2);
    }
    if (balance < limit && code2 === codes.leftParenthesis) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === codes.rightParenthesis) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.leftParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === codes.leftParenthesis || code2 === codes.rightParenthesis || code2 === codes.backslash) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > constants.linkReferenceSizeMax || code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === codes.caret && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket || markdownLineEnding(code2) || size++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace(code2);
    return code2 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === codes.leftSquareBracket || code2 === codes.backslash || code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start2;
  function start2(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === codes.leftParenthesis ? codes.rightParenthesis : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === codes.backslash) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start2,
        seen ? types.linePrefix : types.lineSuffix
      )(code2);
    }
    return ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start2;
  function start2(code2) {
    effects.enter(types.definition);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code2);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, types.whitespace)(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text5;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text5 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text5, context],
      ["exit", text5, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter(types.atxHeading);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === codes.eof || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.atxHeading);
      return ok3(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, types.whitespace)(code2);
    }
    effects.enter(types.atxHeadingText);
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === codes.numberSign) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.numberSign || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start2;
  function start2(code2) {
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      ok(code2 !== null);
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      marker = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      ok(code2 !== null);
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === codes.eof || code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === codes.slash;
      const name2 = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.slash || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    ok(markdownLineEnding(code2));
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === codes.greaterThan) {
      const name2 = buffer2.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < constants.htmlRawSizeMax) {
      ok(code2 !== null);
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit(types.htmlFlow);
    return ok3(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === codes.greaterThan ? end(code2) : code2 === codes.dash ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === codes.greaterThan) {
      return end(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === codes.eof || code2 === codes.greaterThan) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === codes.greaterThan ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return end;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code2), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter(types.htmlTextData);
    return returnState(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token = events[index2][1];
    newEvents.push(events[index2]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close = index2;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close][1].end }
  };
  const text5 = {
    type: types.labelText,
    start: { ...events[open + offset + 2][1].end },
    end: { ...events[close - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text5, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text5, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start2;
  function start2(code2) {
    ok(code2 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code2) {
    if (code2 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok3(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code2) {
    ok(code2 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code2);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === codes.rightParenthesis) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code2);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code2);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code2);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code2);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code2);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start2;
  function start2(code2) {
    effects.enter(types.thematicBreak);
    return before(code2);
  }
  function before(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.dash || code2 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code2);
    }
    if (size >= constants.thematicBreakMarkerCountMin && (code2 === codes.eof || markdownLineEnding(code2))) {
      effects.exit(types.thematicBreak);
      return ok3(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code2) ? factorySpace(effects, atBreak, types.whitespace)(code2) : atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start2;
  function start2(code2) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code2 === codes.asterisk || code2 === codes.plusSign || code2 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code2 === codes.asterisk || code2 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code2) && ++size < constants.listItemValueSizeMax) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === codes.rightParenthesis || code2 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    ok(self2.containerState, "expected state");
    ok(code2 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code2);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code2);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text5;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text5 = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === types.definition) {
        definition2 = index2;
      }
    }
  }
  ok(text5 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  ok(events[content3][2] === context, "enter context should be same");
  ok(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading2 = {
    type: types.setextHeading,
    start: { ...events[content3][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text5][1].type = types.setextHeadingText;
  if (definition2) {
    events.splice(text5, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = { ...events[definition2][1].end };
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    ok(
      code2 === codes.dash || code2 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph2 = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types.setextHeadingLine);
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code2) ? factorySpace(effects, after, types.lineSuffix)(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code2);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text5 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code2) {
      return atBreak(code2) ? text5(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === codes.eof) {
        effects.consume(code2);
        return;
      }
      effects.enter(types.data);
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit(types.data);
        return text5(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === codes.eof) {
        return true;
      }
      const list3 = constructs2[code2];
      let index2 = -1;
      if (list3) {
        ok(Array.isArray(list3), "expected `disable.null` to be populated");
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size = 0;
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text3
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text3 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point4 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit2,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now: now2,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now2() {
    const { _bufferIndex, _index, line, column, offset } = point4;
    return { _bufferIndex, _index, line, column, offset };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point4);
  }
  function main() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk = chunks[point4._index];
      if (typeof chunk === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code2, state && state.name);
    expectedCode = code2;
    ok(typeof state === "function", "expected state");
    state = state(code2);
  }
  function consume(code2) {
    ok(code2 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code2);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code2 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code2)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code2 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point4);
    } else if (code2 !== codes.virtualSpace) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now2();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now2();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start2;
        function start2(code2) {
          const left = code2 !== null && map2[code2];
          const all2 = code2 !== null && map2.null;
          const list3 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code2);
        }
      }
      function ok3(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now2();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point4);
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create2(content),
    defined: [],
    document: create2(document2),
    flow: create2(flow),
    lazy: {},
    string: create2(string),
    text: create2(text2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer2 = "";
    if (start2) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer2) chunks.push(buffer2);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html4, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html4, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile3;
  function compile3(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point3(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point3(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index2 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point3(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point3(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text5();
      tail.position = {
        start: point3(token.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point3(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point3(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point3(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html4() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text5() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point3(d3) {
  return { line: d3.line, column: d3.column, offset: d3.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  const language = node2.lang ? node2.lang.split(/\s+/) : [];
  if (language.length > 0) {
    properties.className = ["language-" + language[0]];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html3(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const text5 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text5);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text5]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition2.url || "") };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root2(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start2 = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start2 && end) body.position = { start: start2, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align2 = parent && parent.type === "table" ? parent.align : void 0;
  const length = align2 ? align2.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align2 ? align2[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last2 = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last2, match.index), last2 > 0, true),
      match[0]
    );
    last2 = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last2), last2 > 0, false));
  return lines.join("");
}
function trimLine(value, start2, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start2) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text4(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html: html3,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list: list2,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root: root2,
  strong,
  table,
  tableCell,
  tableRow,
  text: text4,
  thematicBreak: thematicBreak2,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($, _) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map2 = as(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map2.set(unpair(key), unpair(index3));
        return map2;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer: buffer2 } = new Uint8Array(value);
        return as(new DataView(buffer2), value);
      }
    }
    return as(new env[type](value), index2);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString: toString2 } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString2.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $, _) => {
  const as = (out, value) => {
    const index2 = _.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition2 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition2) {
      continue;
    }
    const content3 = state.all(definition2);
    const id = String(definition2.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(definition2, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propertiesFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d3) {
  return d3;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}

// node_modules/mdast-util-to-hast/lib/state.js
var own3 = {}.hasOwnProperty;
var emptyOptions3 = {};
function createState(tree, options) {
  const settings = options || emptyOptions3;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one3,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map2 = node2.type === "definition" ? definitionById : footnoteById;
      const id = String(node2.identifier).toUpperCase();
      if (!map2.has(id)) {
        map2.set(id, node2);
      }
    }
  });
  return state;
  function one3(node2, parent) {
    const type = node2.type;
    const handle = state.handlers[type];
    if (own3.call(state.handlers, type) && handle) {
      return handle(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = esm_default(shallow);
        result.children = state.all(node2);
        return result;
      }
      return esm_default(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all2(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch(from, to) {
  if (from.position) to.position = position(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own3.call(data, "hProperties") || own3.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// node_modules/remark-rehype/lib/index.js
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values2);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap2(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap2(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/vfile/lib/minpath.browser.js
var minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path);
  let start2 = 0;
  let end = -1;
  let index2 = path.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path.length) {
    while (index2--) {
      if (path.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start2 = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path.slice(start2, end);
  }
  if (extname2 === path) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start2 = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start2 === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path.length;
  }
  return path.slice(start2, end);
}
function dirname(path) {
  assertPath(path);
  if (path.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path.length;
  let unmatchedSlash;
  while (--index2) {
    if (path.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
}
function extname(path) {
  assertPath(path);
  let index2 = path.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize2(joined);
}
function normalize2(path) {
  assertPath(path);
  const absolute = path.codePointAt(0) === 47;
  let value = normalizeString(path, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path.codePointAt(path.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path.length) {
    if (index2 < path.length) {
      code2 = path.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path.slice(lastSlash + 1, index2);
        } else {
          result = path.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var minproc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path) {
  if (typeof path === "string") {
    path = new URL(path);
  } else if (!isUrl(path)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path) {
    if (isUrl(path)) {
      path = urlToPath(path);
    }
    assertNonEmpty(path, "path");
    if (this.path !== path) {
      this.history.push(path);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath2(path, name2) {
  if (!path) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  }
);

// node_modules/unified/lib/index.js
var own4 = {}.hasOwnProperty;
var Processor = class _Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own4.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(
        typeof file !== "function",
        "`file` cant be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/react-markdown/lib/index.js
var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var emptyPlugins = [];
var emptyRemarkRehypeOptions = { allowDangerousHtml: true };
var safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
var deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const processor = createProcessor(options);
  const file = createFile(options);
  return post(processor.runSync(processor.parse(file), file), options);
}
function createProcessor(options) {
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  return processor;
}
function createFile(options) {
  const children = options.children || "";
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  } else {
    unreachable(
      "Unexpected value `" + children + "` for `children` prop, expected `string`"
    );
  }
  return file;
}
function post(tree, options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  if (allowedElements && disallowedElements) {
    unreachable(
      "Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other"
    );
  }
  visit(tree, transform);
  return toJsxRuntime(tree, {
    Fragment: import_jsx_runtime.Fragment,
    components,
    ignoreInvalidStyle: true,
    jsx: import_jsx_runtime.jsx,
    jsxs: import_jsx_runtime.jsxs,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 === "number") {
      if (skipHtml) {
        parent.children.splice(index2, 1);
      } else {
        parent.children[index2] = { type: "text", value: node2.value };
      }
      return index2;
    }
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes) {
        if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
          const value = node2.properties[key];
          const test = urlAttributes[key];
          if (test === null || test.includes(node2.tagName)) {
            node2.properties[key] = urlTransform(String(value || ""), key, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index2 === "number") {
        remove = !allowElement(node2, index2, parent);
      }
      if (remove && parent && typeof index2 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index2, 1, ...node2.children);
        } else {
          parent.children.splice(index2, 1);
        }
        return index2;
      }
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, its relative.
    colon === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}

// node_modules/molstar/lib/mol-plugin-ui/state/animation.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var AnimationControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.updateParams = (p) => {
      this.plugin.managers.animation.updateParams({ [p.name]: p.value });
    };
    this.updateCurrentParams = (p) => {
      this.plugin.managers.animation.updateCurrentParams({ [p.name]: p.value });
    };
    this.startOrStop = () => {
      const anim = this.plugin.managers.animation;
      if (anim.state.animationState === "playing")
        anim.stop();
      else {
        if (this.props.onStart)
          this.props.onStart();
        anim.start();
      }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.animation.events.updated, () => this.forceUpdate());
  }
  render() {
    var _a, _b;
    const anim = this.plugin.managers.animation;
    if (anim.isEmpty)
      return null;
    const isDisabled = anim.state.animationState === "playing";
    const canApply = (_b = (_a = anim.current.anim).canApply) === null || _b === void 0 ? void 0 : _b.call(_a, this.plugin);
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(ParameterControls, { params: anim.getParams(), values: anim.state.params, onChange: this.updateParams, isDisabled }), (0, import_jsx_runtime2.jsx)(ParameterControls, { params: anim.current.params, values: anim.current.paramValues, onChange: this.updateCurrentParams, isDisabled }), (0, import_jsx_runtime2.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime2.jsx)(Button, { icon: anim.state.animationState !== "playing" ? void 0 : PlayArrowSvg, onClick: this.startOrStop, disabled: canApply !== void 0 && canApply.canApply === false, children: anim.state.animationState === "playing" ? "Stop" : canApply === void 0 || canApply.canApply ? "Start" : canApply.reason || "Start" }) })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/components.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-state/helpers/structure-overpaint.js
var OverpaintManagerTag = "overpaint-controls";
async function setStructureOverpaint(plugin, components, color2, lociGetter, types2) {
  await eachRepr(plugin, components, async (update, repr, overpaintCell) => {
    if (types2 && types2.length > 0 && !types2.includes(repr.params.values.type.name))
      return;
    const structure = repr.obj.data.sourceData;
    const loci = await lociGetter(structure.root);
    if (Loci.isEmpty(loci) || isEmptyLoci(loci))
      return;
    const layer = {
      bundle: element_exports.Bundle.fromLoci(loci),
      color: color2 === -1 ? Color(0) : color2,
      clear: color2 === -1
    };
    if (overpaintCell) {
      const bundleLayers = [...overpaintCell.params.values.layers, layer];
      const filtered = getFilteredBundle(bundleLayers, structure);
      update.to(overpaintCell).update(Overpaint.toBundle(filtered));
    } else {
      const filtered = getFilteredBundle([layer], structure);
      update.to(repr.transform.ref).apply(StateTransforms.Representation.OverpaintStructureRepresentation3DFromBundle, Overpaint.toBundle(filtered), { tags: OverpaintManagerTag });
    }
  });
}
async function eachRepr(plugin, components, callback) {
  const state = plugin.state.data;
  const update = state.build();
  for (const c4 of components) {
    for (const r of c4.representations) {
      const overpaint = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Representation.OverpaintStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(OverpaintManagerTag));
      await callback(update, r.cell, overpaint[0]);
    }
  }
  return update.commit({ doNotUpdateCurrent: true });
}
function getFilteredBundle(layers, structure) {
  const overpaint = Overpaint.ofBundle(layers, structure.root);
  const merged = Overpaint.merge(overpaint);
  return Overpaint.filter(merged, structure);
}

// node_modules/molstar/lib/mol-plugin-state/helpers/structure-clipping.js
var ClippingManagerTag = "clipping-controls";
async function setStructureClipping(plugin, components, groups, lociGetter, types2) {
  await eachRepr2(plugin, components, async (update, repr, clippingCell) => {
    if (types2 && types2.length > 0 && !types2.includes(repr.params.values.type.name))
      return;
    const structure = repr.obj.data.sourceData;
    const loci = await lociGetter(structure.root);
    if (Loci.isEmpty(loci) || isEmptyLoci(loci))
      return;
    const layer = {
      bundle: element_exports.Bundle.fromLoci(loci),
      groups
    };
    if (clippingCell) {
      const bundleLayers = [...clippingCell.params.values.layers, layer];
      const filtered = getFilteredBundle2(bundleLayers, structure);
      update.to(clippingCell).update(Clipping.toBundle(filtered));
    } else {
      const filtered = getFilteredBundle2([layer], structure);
      update.to(repr.transform.ref).apply(StateTransforms.Representation.ClippingStructureRepresentation3DFromBundle, Clipping.toBundle(filtered), { tags: ClippingManagerTag });
    }
  });
}
async function eachRepr2(plugin, components, callback) {
  const state = plugin.state.data;
  const update = state.build();
  for (const c4 of components) {
    for (const r of c4.representations) {
      const clipping = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Representation.ClippingStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(ClippingManagerTag));
      await callback(update, r.cell, clipping[0]);
    }
  }
  return update.commit({ doNotUpdateCurrent: true });
}
function getFilteredBundle2(layers, structure) {
  const clipping = Clipping.ofBundle(layers, structure.root);
  const merged = Clipping.merge(clipping);
  return Clipping.filter(merged, structure);
}

// node_modules/molstar/lib/mol-plugin-state/helpers/structure-transparency.js
var TransparencyManagerTag = "transparency-controls";
async function setStructureTransparency(plugin, components, value, lociGetter, types2) {
  await eachRepr3(plugin, components, async (update, repr, transparencyCell) => {
    if (types2 && types2.length > 0 && !types2.includes(repr.params.values.type.name))
      return;
    const structure = repr.obj.data.sourceData;
    const loci = await lociGetter(structure.root);
    if (Loci.isEmpty(loci) || isEmptyLoci(loci))
      return;
    const layer = {
      bundle: element_exports.Bundle.fromLoci(loci),
      value
    };
    if (transparencyCell) {
      const bundleLayers = [...transparencyCell.params.values.layers, layer];
      const filtered = getFilteredBundle3(bundleLayers, structure);
      update.to(transparencyCell).update(Transparency.toBundle(filtered));
    } else {
      const filtered = getFilteredBundle3([layer], structure);
      update.to(repr.transform.ref).apply(StateTransforms.Representation.TransparencyStructureRepresentation3DFromBundle, Transparency.toBundle(filtered), { tags: TransparencyManagerTag });
    }
  });
}
async function eachRepr3(plugin, components, callback) {
  const state = plugin.state.data;
  const update = state.build();
  for (const c4 of components) {
    for (const r of c4.representations) {
      const transparency = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Representation.TransparencyStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(TransparencyManagerTag));
      await callback(update, r.cell, transparency[0]);
    }
  }
  return update.commit({ doNotUpdateCurrent: true });
}
function getFilteredBundle3(layers, structure) {
  const transparency = Transparency.ofBundle(layers, structure.root);
  const merged = Transparency.merge(transparency);
  return Transparency.filter(merged, structure);
}

// node_modules/molstar/lib/mol-plugin-state/helpers/structure-substance.js
var SubstanceManagerTag = "substance-controls";
async function setStructureSubstance(plugin, components, material, lociGetter, types2) {
  await eachRepr4(plugin, components, async (update, repr, substanceCell) => {
    if (types2 && types2.length > 0 && !types2.includes(repr.params.values.type.name))
      return;
    const structure = repr.obj.data.sourceData;
    const loci = await lociGetter(structure.root);
    if (Loci.isEmpty(loci) || isEmptyLoci(loci))
      return;
    const layer = {
      bundle: element_exports.Bundle.fromLoci(loci),
      material: material !== null && material !== void 0 ? material : Material(),
      clear: !material
    };
    if (substanceCell) {
      const bundleLayers = [...substanceCell.params.values.layers, layer];
      const filtered = getFilteredBundle4(bundleLayers, structure);
      update.to(substanceCell).update(Substance.toBundle(filtered));
    } else {
      const filtered = getFilteredBundle4([layer], structure);
      update.to(repr.transform.ref).apply(StateTransforms.Representation.SubstanceStructureRepresentation3DFromBundle, Substance.toBundle(filtered), { tags: SubstanceManagerTag });
    }
  });
}
async function eachRepr4(plugin, components, callback) {
  const state = plugin.state.data;
  const update = state.build();
  for (const c4 of components) {
    for (const r of c4.representations) {
      const substance = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Representation.SubstanceStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(SubstanceManagerTag));
      await callback(update, r.cell, substance[0]);
    }
  }
  return update.commit({ doNotUpdateCurrent: true });
}
function getFilteredBundle4(layers, structure) {
  const substance = Substance.ofBundle(layers, structure.root);
  const merged = Substance.merge(substance);
  return Substance.filter(merged, structure);
}

// node_modules/molstar/lib/mol-plugin-state/helpers/structure-emissive.js
var EmissiveManagerTag = "emissive-controls";
async function setStructureEmissive(plugin, components, value, lociGetter, types2) {
  await eachRepr5(plugin, components, async (update, repr, emissiveCell) => {
    if (types2 && types2.length > 0 && !types2.includes(repr.params.values.type.name))
      return;
    const structure = repr.obj.data.sourceData;
    const loci = await lociGetter(structure.root);
    if (Loci.isEmpty(loci) || isEmptyLoci(loci))
      return;
    const layer = {
      bundle: element_exports.Bundle.fromLoci(loci),
      value
    };
    if (emissiveCell) {
      const bundleLayers = [...emissiveCell.params.values.layers, layer];
      const filtered = getFilteredBundle5(bundleLayers, structure);
      update.to(emissiveCell).update(Emissive.toBundle(filtered));
    } else {
      const filtered = getFilteredBundle5([layer], structure);
      update.to(repr.transform.ref).apply(StateTransforms.Representation.EmissiveStructureRepresentation3DFromBundle, Emissive.toBundle(filtered), { tags: EmissiveManagerTag });
    }
  });
}
async function eachRepr5(plugin, components, callback) {
  const state = plugin.state.data;
  const update = state.build();
  for (const c4 of components) {
    for (const r of c4.representations) {
      const emissive = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Representation.EmissiveStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(EmissiveManagerTag));
      await callback(update, r.cell, emissive[0]);
    }
  }
  return update.commit({ doNotUpdateCurrent: true });
}
function getFilteredBundle5(layers, structure) {
  const emissive = Emissive.ofBundle(layers, structure.root);
  const merged = Emissive.merge(emissive);
  return Emissive.filter(merged, structure);
}

// node_modules/molstar/lib/mol-plugin-state/manager/structure/component.js
var StructureComponentManager = class _StructureComponentManager extends StatefulPluginComponent {
  get currentStructures() {
    return this.plugin.managers.structure.hierarchy.selection.structures;
  }
  get pivotStructure() {
    return this.currentStructures[0];
  }
  // To be used only from PluginState.setSnapshot
  _setSnapshotState(options) {
    this.updateState({ options });
    this.events.optionsUpdated.next(void 0);
  }
  async setOptions(options) {
    const interactionChanged = options.interactions !== this.state.options.interactions;
    this.updateState({ options });
    this.events.optionsUpdated.next(void 0);
    const update = this.dataState.build();
    for (const s of this.currentStructures) {
      for (const c4 of s.components) {
        this.updateReprParams(update, c4);
      }
    }
    return this.plugin.dataTransaction(async () => {
      await update.commit();
      await this.plugin.state.updateBehavior(StructureFocusRepresentation, (p) => {
        p.ignoreHydrogens = options.hydrogens !== "all";
        p.ignoreHydrogensVariant = options.hydrogens === "only-polar" ? "non-polar" : "all";
        p.ignoreLight = options.ignoreLight;
        p.material = options.materialStyle;
        p.clip = options.clipObjects;
      });
      if (interactionChanged)
        await this.updateInterationProps();
    });
  }
  updateReprParams(update, component) {
    const { hydrogens, visualQuality: quality, ignoreLight, materialStyle: material, clipObjects: clip } = this.state.options;
    const ignoreHydrogens = hydrogens !== "all";
    const ignoreHydrogensVariant = hydrogens === "only-polar" ? "non-polar" : "all";
    for (const r of component.representations) {
      if (r.cell.transform.transformer !== StructureRepresentation3D)
        continue;
      const params = r.cell.transform.params;
      if (!!params.type.params.ignoreHydrogens !== ignoreHydrogens || params.type.params.ignoreHydrogensVariant !== ignoreHydrogensVariant || params.type.params.quality !== quality || params.type.params.ignoreLight !== ignoreLight || !shallowEqual(params.type.params.material, material) || !ParamDefinition.areEqual(Clip.Params, params.type.params.clip, clip)) {
        update.to(r.cell).update((old) => {
          old.type.params.ignoreHydrogens = ignoreHydrogens;
          old.type.params.ignoreHydrogensVariant = ignoreHydrogensVariant;
          old.type.params.quality = quality;
          old.type.params.ignoreLight = ignoreLight;
          old.type.params.material = material;
          old.type.params.clip = clip;
        });
      }
    }
  }
  async updateInterationProps() {
    var _a, _b, _c;
    for (const s of this.currentStructures) {
      const interactionParams = InteractionsProvider.getParams((_a = s.cell.obj) === null || _a === void 0 ? void 0 : _a.data);
      if (s.properties) {
        const oldParams = (_b = s.properties.cell.transform.params) === null || _b === void 0 ? void 0 : _b.properties[InteractionsProvider.descriptor.name];
        if (ParamDefinition.areEqual(interactionParams, oldParams, this.state.options.interactions))
          continue;
        await this.dataState.build().to(s.properties.cell).update((old) => {
          old.properties[InteractionsProvider.descriptor.name] = this.state.options.interactions;
        }).commit();
      } else {
        const pd2 = this.plugin.customStructureProperties.getParams((_c = s.cell.obj) === null || _c === void 0 ? void 0 : _c.data);
        const params = ParamDefinition.getDefaultValues(pd2);
        if (ParamDefinition.areEqual(interactionParams, params.properties[InteractionsProvider.descriptor.name], this.state.options.interactions))
          continue;
        params.properties[InteractionsProvider.descriptor.name] = this.state.options.interactions;
        await this.plugin.builders.structure.insertStructureProperties(s.cell, params);
      }
    }
  }
  applyPreset(structures, provider, params) {
    return this.plugin.dataTransaction(async () => {
      for (const s of structures) {
        const preset = await this.plugin.builders.structure.representation.applyPreset(s.cell, provider, params);
        await this.syncPreset(s, preset);
      }
    }, { canUndo: "Preset" });
  }
  syncPreset(root3, preset) {
    if (!preset || !preset.components)
      return this.clearComponents([root3]);
    const keptRefs = /* @__PURE__ */ new Set();
    objectForEach(preset.components, (c4) => {
      if (c4)
        keptRefs.add(c4.ref);
    });
    if (preset.representations) {
      objectForEach(preset.representations, (r) => {
        if (r)
          keptRefs.add(r.ref);
      });
    }
    if (keptRefs.size === 0)
      return this.clearComponents([root3]);
    let changed = false;
    const update = this.dataState.build();
    const sync = (r) => {
      if (!keptRefs.has(r.cell.transform.ref)) {
        changed = true;
        update.delete(r.cell);
      }
    };
    for (const c4 of root3.components) {
      sync(c4);
      for (const r of c4.representations)
        sync(r);
      if (c4.genericRepresentations) {
        for (const r of c4.genericRepresentations)
          sync(r);
      }
    }
    if (root3.genericRepresentations) {
      for (const r of root3.genericRepresentations) {
        sync(r);
      }
    }
    if (changed)
      return update.commit();
  }
  clear(structures) {
    return this.clearComponents(structures);
  }
  selectThis(components) {
    var _a;
    const mng = this.plugin.managers.structure.selection;
    mng.clear();
    for (const c4 of components) {
      const loci = Structure.toSubStructureElementLoci(c4.structure.cell.obj.data, (_a = c4.cell.obj) === null || _a === void 0 ? void 0 : _a.data);
      mng.fromLoci("set", loci);
    }
  }
  canBeModified(ref) {
    return this.plugin.builders.structure.isComponentTransform(ref.cell);
  }
  modifyByCurrentSelection(components, action) {
    return this.plugin.runTask(Task.create("Modify Component", async (taskCtx) => {
      const b4 = this.dataState.build();
      for (const c4 of components) {
        if (!this.canBeModified(c4))
          continue;
        const selection = this.plugin.managers.structure.selection.getStructure(c4.structure.cell.obj.data);
        if (!selection || selection.elementCount === 0)
          continue;
        this.modifyComponent(b4, c4, selection, action);
      }
      await this.dataState.updateTree(b4, { canUndo: "Modify Selection" }).runInContext(taskCtx);
    }));
  }
  toggleVisibility(components, reprPivot) {
    if (components.length === 0)
      return;
    if (!reprPivot) {
      const isHidden = !components[0].cell.state.isHidden;
      for (const c4 of components) {
        setSubtreeVisibility(this.dataState, c4.cell.transform.ref, isHidden);
      }
    } else {
      const index2 = components[0].representations.indexOf(reprPivot);
      const isHidden = !reprPivot.cell.state.isHidden;
      for (const c4 of components) {
        const repr = c4.representations[index2];
        if (!repr)
          continue;
        setSubtreeVisibility(this.dataState, repr.cell.transform.ref, isHidden);
      }
    }
  }
  removeRepresentations(components, pivot) {
    if (components.length === 0)
      return;
    const toRemove = [];
    if (pivot) {
      const index2 = components[0].representations.indexOf(pivot);
      if (index2 < 0)
        return;
      for (const c4 of components) {
        if (c4.representations[index2])
          toRemove.push(c4.representations[index2]);
      }
    } else {
      for (const c4 of components) {
        for (const r of c4.representations) {
          toRemove.push(r);
        }
      }
    }
    return this.plugin.managers.structure.hierarchy.remove(toRemove, true);
  }
  updateRepresentations(components, pivot, params) {
    if (components.length === 0)
      return Promise.resolve();
    const index2 = components[0].representations.indexOf(pivot);
    if (index2 < 0)
      return Promise.resolve();
    const update = this.dataState.build();
    for (const c4 of components) {
      const repr = c4.representations[index2];
      if (!repr)
        continue;
      if (repr.cell.transform.transformer !== pivot.cell.transform.transformer)
        continue;
      update.to(repr.cell).update(params);
    }
    return update.commit({ canUndo: "Update Representation" });
  }
  updateRepresentationsTheme(components, paramsOrProvider) {
    var _a, _b, _c, _d;
    if (components.length === 0)
      return;
    const update = this.dataState.build();
    for (const c4 of components) {
      for (const repr of c4.representations) {
        const old = repr.cell.transform.params;
        const params = typeof paramsOrProvider === "function" ? paramsOrProvider(c4, repr) : paramsOrProvider;
        const colorTheme = params.color === "default" ? createStructureColorThemeParams(this.plugin, (_a = c4.structure.cell.obj) === null || _a === void 0 ? void 0 : _a.data, old === null || old === void 0 ? void 0 : old.type.name) : params.color ? createStructureColorThemeParams(this.plugin, (_b = c4.structure.cell.obj) === null || _b === void 0 ? void 0 : _b.data, old === null || old === void 0 ? void 0 : old.type.name, params.color, params.colorParams) : void 0;
        const sizeTheme = params.size === "default" ? createStructureSizeThemeParams(this.plugin, (_c = c4.structure.cell.obj) === null || _c === void 0 ? void 0 : _c.data, old === null || old === void 0 ? void 0 : old.type.name) : params.color ? createStructureSizeThemeParams(this.plugin, (_d = c4.structure.cell.obj) === null || _d === void 0 ? void 0 : _d.data, old === null || old === void 0 ? void 0 : old.type.name, params.size, params.sizeParams) : void 0;
        if (colorTheme || sizeTheme) {
          update.to(repr.cell).update((prev) => {
            if (colorTheme)
              prev.colorTheme = colorTheme;
            if (sizeTheme)
              prev.sizeTheme = sizeTheme;
          });
        }
      }
    }
    return update.commit({ canUndo: "Update Theme" });
  }
  addRepresentation(components, type) {
    if (components.length === 0)
      return;
    const { hydrogens, visualQuality: quality, ignoreLight, materialStyle: material, clipObjects: clip } = this.state.options;
    const ignoreHydrogens = hydrogens !== "all";
    const ignoreHydrogensVariant = hydrogens === "only-polar" ? "non-polar" : "all";
    const typeParams = { ignoreHydrogens, ignoreHydrogensVariant, quality, ignoreLight, material, clip };
    return this.plugin.dataTransaction(async () => {
      for (const component of components) {
        await this.plugin.builders.structure.representation.addRepresentation(component.cell, {
          type: this.plugin.representation.structure.registry.get(type),
          typeParams
        });
      }
    }, { canUndo: "Add Representation" });
  }
  tryFindComponent(structure, selection) {
    if (structure.components.length === 0)
      return;
    return this.plugin.runTask(Task.create("Find Component", async (taskCtx) => {
      var _a, _b;
      const data = (_a = structure.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
      if (!data)
        return;
      const sel = StructureSelection.unionStructure(await selection.getSelection(this.plugin, taskCtx, data));
      for (const c4 of structure.components) {
        const comp = (_b = c4.cell.obj) === null || _b === void 0 ? void 0 : _b.data;
        if (!comp || !c4.cell.parent)
          continue;
        if (structureAreEqual(sel, comp))
          return c4.cell;
      }
    }));
  }
  async add(params, structures) {
    return this.plugin.dataTransaction(async () => {
      const xs = structures || this.currentStructures;
      if (xs.length === 0)
        return;
      const { hydrogens, visualQuality: quality, ignoreLight, materialStyle: material, clipObjects: clip } = this.state.options;
      const ignoreHydrogens = hydrogens !== "all";
      const ignoreHydrogensVariant = hydrogens === "only-polar" ? "non-polar" : "all";
      const typeParams = { ignoreHydrogens, ignoreHydrogensVariant, quality, ignoreLight, material, clip };
      const componentKey2 = UUID.create22();
      for (const s of xs) {
        let component = void 0;
        if (params.options.checkExisting) {
          component = await this.tryFindComponent(s, params.selection);
        }
        if (!component) {
          component = await this.plugin.builders.structure.tryCreateComponentFromSelection(s.cell, params.selection, componentKey2, {
            label: params.options.label || (params.selection === StructureSelectionQueries.current ? "Custom Selection" : "")
          });
        }
        if (params.representation === "none" || !component)
          continue;
        await this.plugin.builders.structure.representation.addRepresentation(component, {
          type: this.plugin.representation.structure.registry.get(params.representation),
          typeParams
        });
      }
    }, { canUndo: "Add Selection" });
  }
  async applyTheme(params, structures) {
    return this.plugin.dataTransaction(async (ctx) => {
      const xs = structures || this.currentStructures;
      if (xs.length === 0)
        return;
      const getLoci = async (s) => StructureSelection.toLociWithSourceUnits(await params.selection.getSelection(this.plugin, ctx, s));
      for (const s of xs) {
        if (params.action.name === "color") {
          const p = params.action.params;
          await setStructureOverpaint(this.plugin, s.components, p.color, getLoci, params.representations);
        } else if (params.action.name === "resetColor") {
          await setStructureOverpaint(this.plugin, s.components, -1, getLoci, params.representations);
        } else if (params.action.name === "transparency") {
          const p = params.action.params;
          await setStructureTransparency(this.plugin, s.components, p.value, getLoci, params.representations);
        } else if (params.action.name === "emissive") {
          const p = params.action.params;
          await setStructureEmissive(this.plugin, s.components, p.value, getLoci, params.representations);
        } else if (params.action.name === "material") {
          const p = params.action.params;
          await setStructureSubstance(this.plugin, s.components, p.material, getLoci, params.representations);
        } else if (params.action.name === "resetMaterial") {
          await setStructureSubstance(this.plugin, s.components, void 0, getLoci, params.representations);
        } else if (params.action.name === "clipping") {
          const p = params.action.params;
          await setStructureClipping(this.plugin, s.components, Clipping.Groups.fromNames(p.excludeGroups), getLoci, params.representations);
        }
      }
    }, { canUndo: "Apply Theme" });
  }
  modifyComponent(builder, component, by, action) {
    var _a, _b, _c;
    const structure = (_a = component.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
    if (!structure)
      return;
    if ((action === "subtract" || action === "intersect") && !structureAreIntersecting(structure, by))
      return;
    const parent = (_b = component.structure.cell.obj) === null || _b === void 0 ? void 0 : _b.data;
    const modified = action === "union" ? structureUnion(parent, [structure, by]) : action === "intersect" ? structureIntersect(structure, by) : structureSubtract(structure, by);
    if (modified.elementCount === 0) {
      builder.delete(component.cell.transform.ref);
    } else {
      const bundle = element_exports.Bundle.fromSubStructure(parent, modified);
      const params = {
        type: { name: "bundle", params: bundle },
        nullIfEmpty: true,
        label: (_c = component.cell.obj) === null || _c === void 0 ? void 0 : _c.label
      };
      builder.to(component.cell).update(params);
    }
  }
  updateLabel(component, label) {
    var _a, _b;
    const params = {
      type: (_a = component.cell.params) === null || _a === void 0 ? void 0 : _a.values.type,
      nullIfEmpty: (_b = component.cell.params) === null || _b === void 0 ? void 0 : _b.values.nullIfEmpty,
      label
    };
    this.dataState.build().to(component.cell).update(params).commit();
  }
  get dataState() {
    return this.plugin.state.data;
  }
  clearComponents(structures) {
    const deletes = this.dataState.build();
    for (const s of structures) {
      for (const c4 of s.components) {
        deletes.delete(c4.cell.transform.ref);
      }
    }
    return deletes.commit({ canUndo: "Clear Selections" });
  }
  constructor(plugin) {
    super({ options: ParamDefinition.getDefaultValues(_StructureComponentManager.OptionsParams) });
    this.plugin = plugin;
    this.events = {
      optionsUpdated: this.ev()
    };
  }
};
(function(StructureComponentManager2) {
  StructureComponentManager2.OptionsParams = {
    hydrogens: ParamDefinition.Select("all", [["all", "Show All"], ["hide-all", "Hide All"], ["only-polar", "Only Polar"]], { description: "Determine display of hydrogen atoms in representations" }),
    visualQuality: ParamDefinition.Select("auto", VisualQualityOptions, { description: "Control the visual/rendering quality of representations" }),
    ignoreLight: ParamDefinition.Boolean(false, { description: "Ignore light for stylized rendering of representations" }),
    materialStyle: Material.getParam(),
    clipObjects: ParamDefinition.Group(Clip.Params),
    interactions: ParamDefinition.Group(InteractionsProvider.defaultParams, { label: "Non-covalent Interactions" })
  };
  function getAddParams(plugin, params) {
    const { options } = plugin.query.structure.registry;
    params = {
      pivot: plugin.managers.structure.component.pivotStructure,
      allowNone: true,
      hideSelection: false,
      checkExisting: false,
      ...params
    };
    return {
      selection: ParamDefinition.Select(options[1][0], options, { isHidden: params === null || params === void 0 ? void 0 : params.hideSelection }),
      representation: getRepresentationTypesSelect(plugin, params === null || params === void 0 ? void 0 : params.pivot, (params === null || params === void 0 ? void 0 : params.allowNone) ? [["none", "< Create Later >"]] : []),
      options: ParamDefinition.Group({
        label: ParamDefinition.Text(""),
        checkExisting: ParamDefinition.Boolean(!!(params === null || params === void 0 ? void 0 : params.checkExisting), { help: () => ({ description: "Checks if a selection with the specifield elements already exists to avoid creating duplicate components." }) })
      })
    };
  }
  StructureComponentManager2.getAddParams = getAddParams;
  function getThemeParams(plugin, pivot) {
    const { options } = plugin.query.structure.registry;
    return {
      selection: ParamDefinition.Select(options[1][0], options, { isHidden: false }),
      action: ParamDefinition.MappedStatic("color", {
        color: ParamDefinition.Group({
          color: ParamDefinition.Color(ColorNames.blue, { isExpanded: true })
        }, { isFlat: true }),
        resetColor: ParamDefinition.EmptyGroup({ label: "Reset Color" }),
        transparency: ParamDefinition.Group({
          value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 })
        }, { isFlat: true }),
        emissive: ParamDefinition.Group({
          value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 })
        }, { isFlat: true }),
        material: ParamDefinition.Group({
          material: Material.getParam({ isFlat: true })
        }, { isFlat: true }),
        resetMaterial: ParamDefinition.EmptyGroup({ label: "Reset Material" }),
        clipping: ParamDefinition.Group({
          excludeGroups: ParamDefinition.MultiSelect([], ParamDefinition.objectToOptions(Clipping.Groups.Names))
        }, { isFlat: true })
      }),
      representations: ParamDefinition.MultiSelect([], getRepresentationTypes(plugin, pivot), { emptyValue: "All" })
    };
  }
  StructureComponentManager2.getThemeParams = getThemeParams;
  function getRepresentationTypes(plugin, pivot) {
    var _a, _b;
    return ((_a = pivot === null || pivot === void 0 ? void 0 : pivot.cell.obj) === null || _a === void 0 ? void 0 : _a.data) ? plugin.representation.structure.registry.getApplicableTypes((_b = pivot.cell.obj) === null || _b === void 0 ? void 0 : _b.data) : plugin.representation.structure.registry.types;
  }
  StructureComponentManager2.getRepresentationTypes = getRepresentationTypes;
  function getRepresentationTypesSelect(plugin, pivot, custom, label) {
    const types2 = [
      ...custom,
      ...getRepresentationTypes(plugin, pivot)
    ];
    return ParamDefinition.Select(types2[0][0], types2, { label });
  }
})(StructureComponentManager || (StructureComponentManager = {}));

// node_modules/molstar/lib/mol-plugin-state/manager/structure/hierarchy-state.js
function buildStructureHierarchy(state, previous2) {
  const build = BuildState(state, previous2 || StructureHierarchy());
  doPreOrder(state.tree, build);
  if (previous2)
    previous2.refs.forEach(isRemoved, build);
  return { hierarchy: build.hierarchy, added: build.added, changed: build.changed };
}
function StructureHierarchy() {
  return { trajectories: [], models: [], structures: [], refs: /* @__PURE__ */ new Map() };
}
function TrajectoryRef(cell) {
  return { kind: "trajectory", cell, version: cell.transform.version, models: [] };
}
function ModelRef(cell, trajectory) {
  return { kind: "model", cell, version: cell.transform.version, trajectory, structures: [] };
}
function ModelPropertiesRef(cell, model) {
  return { kind: "model-properties", cell, version: cell.transform.version, model };
}
function ModelUnitcellRef(cell, model) {
  return { kind: "model-unitcell", cell, version: cell.transform.version, model };
}
function StructureRef(cell, model) {
  return { kind: "structure", cell, version: cell.transform.version, model, components: [] };
}
function StructurePropertiesRef(cell, structure) {
  return { kind: "structure-properties", cell, version: cell.transform.version, structure };
}
function StructureTransformRef(cell, structure) {
  return { kind: "structure-transform", cell, version: cell.transform.version, structure };
}
function StructureVolumeStreamingRef(cell, structure) {
  return { kind: "structure-volume-streaming", cell, version: cell.transform.version, structure };
}
function componentKey(cell) {
  if (!cell.transform.tags)
    return cell.transform.ref;
  return [...cell.transform.tags].sort().join();
}
function StructureComponentRef(cell, structure) {
  return { kind: "structure-component", cell, version: cell.transform.version, structure, key: componentKey(cell), representations: [] };
}
function StructureRepresentationRef(cell, component) {
  return { kind: "structure-representation", cell, version: cell.transform.version, component };
}
function GenericRepresentationRef(cell, parent) {
  return { kind: "generic-representation", cell, version: cell.transform.version, parent };
}
function BuildState(state, oldHierarchy) {
  return { state, oldHierarchy, hierarchy: StructureHierarchy(), changed: false, added: /* @__PURE__ */ new Set() };
}
function createOrUpdateRefList(state, cell, list3, ctor, ...args) {
  const ref = ctor(...args);
  list3.push(ref);
  state.hierarchy.refs.set(cell.transform.ref, ref);
  const old = state.oldHierarchy.refs.get(cell.transform.ref);
  if (old) {
    if (old.version !== cell.transform.version)
      state.changed = true;
  } else {
    state.added.add(ref.cell.transform.ref);
    state.changed = true;
  }
  return ref;
}
function createOrUpdateRef(state, cell, ctor, ...args) {
  const ref = ctor(...args);
  state.hierarchy.refs.set(cell.transform.ref, ref);
  const old = state.oldHierarchy.refs.get(cell.transform.ref);
  if (old) {
    if (old.version !== cell.transform.version)
      state.changed = true;
  } else {
    state.added.add(ref.cell.transform.ref);
    state.changed = true;
  }
  return ref;
}
function isType(t4) {
  return (cell) => t4.is(cell.obj);
}
function isTypeRoot(t4, target) {
  return (cell, state) => !target(state) && t4.is(cell.obj);
}
function isTransformer(t4) {
  return (cell) => cell.transform.transformer === t4;
}
function noop() {
}
var Mapping = [
  // Trajectory
  [isType(PluginStateObject.Molecule.Trajectory), (state, cell) => {
    state.currentTrajectory = createOrUpdateRefList(state, cell, state.hierarchy.trajectories, TrajectoryRef, cell);
  }, (state) => state.currentTrajectory = void 0],
  // Model
  [isTypeRoot(PluginStateObject.Molecule.Model, (s) => s.currentModel), (state, cell) => {
    if (state.currentTrajectory) {
      state.currentModel = createOrUpdateRefList(state, cell, state.currentTrajectory.models, ModelRef, cell, state.currentTrajectory);
    } else {
      state.currentModel = createOrUpdateRef(state, cell, ModelRef, cell);
    }
    state.hierarchy.models.push(state.currentModel);
  }, (state) => state.currentModel = void 0],
  [isTransformer(StateTransforms.Model.CustomModelProperties), (state, cell) => {
    if (!state.currentModel)
      return false;
    state.currentModel.properties = createOrUpdateRef(state, cell, ModelPropertiesRef, cell, state.currentModel);
  }, noop],
  [isTransformer(StateTransforms.Representation.ModelUnitcell3D), (state, cell) => {
    if (!state.currentModel)
      return false;
    state.currentModel.unitcell = createOrUpdateRef(state, cell, ModelUnitcellRef, cell, state.currentModel);
  }, noop],
  // Structure
  [isTypeRoot(PluginStateObject.Molecule.Structure, (s) => s.currentStructure), (state, cell) => {
    if (state.currentModel) {
      state.currentStructure = createOrUpdateRefList(state, cell, state.currentModel.structures, StructureRef, cell, state.currentModel);
    } else {
      state.currentStructure = createOrUpdateRef(state, cell, StructureRef, cell);
    }
    state.hierarchy.structures.push(state.currentStructure);
  }, (state) => state.currentStructure = void 0],
  [isTransformer(StateTransforms.Model.CustomStructureProperties), (state, cell) => {
    if (!state.currentStructure)
      return false;
    state.currentStructure.properties = createOrUpdateRef(state, cell, StructurePropertiesRef, cell, state.currentStructure);
  }, noop],
  [isTransformer(StateTransforms.Model.TransformStructureConformation), (state, cell) => {
    if (!state.currentStructure)
      return false;
    state.currentStructure.transform = createOrUpdateRef(state, cell, StructureTransformRef, cell, state.currentStructure);
  }, noop],
  // Volume Streaming
  [isType(VolumeStreaming), (state, cell) => {
    if (!state.currentStructure)
      return false;
    state.currentStructure.volumeStreaming = createOrUpdateRef(state, cell, StructureVolumeStreamingRef, cell, state.currentStructure);
    return false;
  }, noop],
  // Component
  [(cell, state) => {
    if (!state.currentStructure || cell.transform.transformer.definition.isDecorator)
      return false;
    return PluginStateObject.Molecule.Structure.is(cell.obj);
  }, (state, cell) => {
    if (state.currentStructure) {
      if (state.currentComponent) {
        if (!state.parentComponents)
          state.parentComponents = [];
        state.parentComponents.push(state.currentComponent);
      }
      state.currentComponent = createOrUpdateRefList(state, cell, state.currentStructure.components, StructureComponentRef, cell, state.currentStructure);
    }
  }, (state) => {
    if (state.parentComponents && state.parentComponents.length > 0) {
      state.currentComponent = state.parentComponents.pop();
    } else
      state.currentComponent = void 0;
  }],
  // Component Representation
  [(cell, state) => {
    return !cell.state.isGhost && !!state.currentComponent && PluginStateObject.Molecule.Structure.Representation3D.is(cell.obj);
  }, (state, cell) => {
    if (state.currentComponent) {
      createOrUpdateRefList(state, cell, state.currentComponent.representations, StructureRepresentationRef, cell, state.currentComponent);
    }
    return false;
  }, noop],
  // Generic Representation
  [(cell) => !cell.state.isGhost && PluginStateObject.isRepresentation3D(cell.obj), (state, cell) => {
    const genericTarget = state.currentComponent || state.currentStructure || state.currentModel;
    if (genericTarget) {
      if (!genericTarget.genericRepresentations)
        genericTarget.genericRepresentations = [];
      createOrUpdateRefList(state, cell, genericTarget.genericRepresentations, GenericRepresentationRef, cell, genericTarget);
    }
  }, noop]
];
function isValidCell(cell) {
  if (!cell || !(cell === null || cell === void 0 ? void 0 : cell.parent) || !cell.parent.cells.has(cell.transform.ref))
    return false;
  const { obj } = cell;
  if (!obj || obj === StateObject.Null || cell.status !== "ok" && cell.status !== "error")
    return false;
  return true;
}
function isRemoved(ref) {
  const { cell } = ref;
  if (isValidCell(cell))
    return;
  this.changed = true;
}
function _preOrderFunc(c4) {
  _doPreOrder(this, this.tree.transforms.get(c4));
}
function _doPreOrder(ctx, root3) {
  const { state } = ctx;
  const cell = state.state.cells.get(root3.ref);
  if (!isValidCell(cell))
    return;
  let onLeave = void 0;
  let end = false;
  for (const [test, f, l] of Mapping) {
    if (test(cell, state)) {
      const cont2 = f(state, cell);
      if (cont2 === false) {
        end = true;
        break;
      }
      onLeave = l;
      break;
    }
  }
  if (end)
    return;
  const children = ctx.tree.children.get(root3.ref);
  if (children && children.size) {
    children.forEach(_preOrderFunc, ctx);
  }
  if (onLeave)
    onLeave(state);
}
function doPreOrder(tree, state) {
  const ctx = { tree, state };
  _doPreOrder(ctx, tree.root);
  return ctx.state;
}

// node_modules/molstar/lib/mol-plugin-state/manager/structure/hierarchy.js
var StructureHierarchyManager = class _StructureHierarchyManager extends PluginComponent {
  get dataState() {
    return this.plugin.state.data;
  }
  get currentComponentGroups() {
    if (this._currentComponentGroups)
      return this._currentComponentGroups;
    this._currentComponentGroups = _StructureHierarchyManager.getComponentGroups(this.selection.structures);
    return this._currentComponentGroups;
  }
  get seletionSet() {
    if (this._currentSelectionSet)
      return this._currentSelectionSet;
    this._currentSelectionSet = /* @__PURE__ */ new Set();
    for (const r of this.selection.trajectories)
      this._currentSelectionSet.add(r.cell.transform.ref);
    for (const r of this.selection.models)
      this._currentSelectionSet.add(r.cell.transform.ref);
    for (const r of this.selection.structures)
      this._currentSelectionSet.add(r.cell.transform.ref);
    return this._currentSelectionSet;
  }
  get current() {
    this.sync(false);
    return this.state.hierarchy;
  }
  get selection() {
    this.sync(false);
    return this.state.selection;
  }
  getStructuresWithSelection() {
    const xs = this.plugin.managers.structure.hierarchy.current.structures;
    const ret = [];
    for (const s of xs) {
      if (this.plugin.managers.structure.selection.structureHasSelection(s)) {
        ret.push(s);
      }
    }
    return ret;
  }
  findStructure(structure) {
    if (!structure)
      return void 0;
    const parent = this.plugin.helpers.substructureParent.get(structure);
    if (!parent)
      return void 0;
    const root3 = this.plugin.state.data.selectQ((q) => q.byValue(parent).rootOfType(PluginStateObject.Molecule.Structure))[0];
    if (!root3)
      return void 0;
    return this.behaviors.selection.value.structures.find((s) => s.cell === root3);
  }
  syncCurrent(all2, added) {
    const current = this.seletionSet;
    const newCurrent = [];
    for (const r of all2) {
      const ref = r.cell.transform.ref;
      if (current.has(ref) || added.has(ref))
        newCurrent.push(r);
    }
    if (newCurrent.length === 0)
      return all2.length > 0 ? [all2[0]] : [];
    return newCurrent;
  }
  sync(notify) {
    if (!notify && this.dataState.inUpdate)
      return;
    if (this.state.syncedTree === this.dataState.tree) {
      if (notify && !this.state.notified) {
        this.state.notified = true;
        this.behaviors.selection.next({ hierarchy: this.state.hierarchy, ...this.state.selection });
      }
      return;
    }
    this.state.syncedTree = this.dataState.tree;
    const update = buildStructureHierarchy(this.plugin.state.data, this.current);
    if (!update.changed) {
      return;
    }
    const { hierarchy } = update;
    const trajectories = this.syncCurrent(hierarchy.trajectories, update.added);
    const models = this.syncCurrent(hierarchy.models, update.added);
    const structures = this.syncCurrent(hierarchy.structures, update.added);
    this._currentComponentGroups = void 0;
    this._currentSelectionSet = void 0;
    this.state.hierarchy = hierarchy;
    this.state.selection.trajectories = trajectories;
    this.state.selection.models = models;
    this.state.selection.structures = structures;
    if (notify) {
      this.state.notified = true;
      this.behaviors.selection.next({ hierarchy, trajectories, models, structures });
    } else {
      this.state.notified = false;
    }
  }
  updateCurrent(refs, action) {
    const hierarchy = this.current;
    const set = action === "add" ? SetUtils.union(this.seletionSet, new Set(refs.map((r) => r.cell.transform.ref))) : SetUtils.difference(this.seletionSet, new Set(refs.map((r) => r.cell.transform.ref)));
    const trajectories = [];
    const models = [];
    const structures = [];
    for (const t4 of hierarchy.trajectories) {
      if (set.has(t4.cell.transform.ref))
        trajectories.push(t4);
    }
    for (const m of hierarchy.models) {
      if (set.has(m.cell.transform.ref))
        models.push(m);
    }
    for (const s of hierarchy.structures) {
      if (set.has(s.cell.transform.ref))
        structures.push(s);
    }
    this._currentComponentGroups = void 0;
    this._currentSelectionSet = void 0;
    this.state.selection.trajectories = trajectories;
    this.state.selection.models = models;
    this.state.selection.structures = structures;
    this.behaviors.selection.next({ hierarchy, trajectories, models, structures });
  }
  remove(refs, canUndo) {
    if (refs.length === 0)
      return;
    const deletes = this.plugin.state.data.build();
    for (const r of refs)
      deletes.delete(typeof r === "string" ? r : r.cell.transform.ref);
    return deletes.commit({ canUndo: canUndo ? "Remove" : false });
  }
  toggleVisibility(refs, action) {
    if (refs.length === 0)
      return;
    const isHidden = action !== void 0 ? action === "show" ? false : true : !refs[0].cell.state.isHidden;
    for (const c4 of refs) {
      setSubtreeVisibility(this.dataState, c4.cell.transform.ref, isHidden);
    }
  }
  applyPreset(trajectories, provider, params) {
    return this.plugin.dataTransaction(async () => {
      for (const t4 of trajectories) {
        if (t4.models.length > 0) {
          await this.clearTrajectory(t4);
        }
        await this.plugin.builders.structure.hierarchy.applyPreset(t4.cell, provider, params);
      }
    });
  }
  async updateStructure(s, params) {
    await this.plugin.dataTransaction(async () => {
      const root3 = StateTree.getDecoratorRoot(this.dataState.tree, s.cell.transform.ref);
      const children = this.dataState.tree.children.get(root3).toArray();
      await this.remove(children, false);
      await this.plugin.state.updateTransform(this.plugin.state.data, s.cell.transform.ref, params, "Structure Type");
      await this.plugin.builders.structure.representation.applyPreset(s.cell.transform.ref, "auto");
    }, { canUndo: "Structure Type" });
    PluginCommands.Camera.Reset(this.plugin);
  }
  clearTrajectory(trajectory) {
    const builder = this.dataState.build();
    for (const m of trajectory.models) {
      builder.delete(m.cell);
    }
    return builder.commit();
  }
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.state = {
      syncedTree: this.dataState.tree,
      notified: false,
      hierarchy: StructureHierarchy(),
      selection: {
        trajectories: [],
        models: [],
        structures: []
      }
    };
    this.behaviors = {
      selection: this.ev.behavior({
        hierarchy: this.current,
        trajectories: this.selection.trajectories,
        models: this.selection.models,
        structures: this.selection.structures
      })
    };
    this._currentComponentGroups = void 0;
    this._currentSelectionSet = void 0;
    this.subscribe(plugin.state.data.events.changed, (e) => {
      if (e.inTransaction || plugin.behaviors.state.isAnimating.value)
        return;
      this.sync(true);
    });
    this.subscribe(plugin.behaviors.state.isAnimating, (isAnimating) => {
      if (!isAnimating && !plugin.behaviors.state.isUpdating.value)
        this.sync(true);
    });
  }
};
(function(StructureHierarchyManager2) {
  function getComponentGroups(structures) {
    if (!structures.length)
      return [];
    if (structures.length === 1)
      return structures[0].components.map((c4) => [c4]);
    const groups = [];
    const map2 = /* @__PURE__ */ new Map();
    for (const s of structures) {
      for (const c4 of s.components) {
        const key = c4.key;
        if (!key)
          continue;
        let component = map2.get(key);
        if (!component) {
          component = [];
          map2.set(key, component);
          groups.push(component);
        }
        component.push(c4);
      }
    }
    return groups;
  }
  StructureHierarchyManager2.getComponentGroups = getComponentGroups;
  function getSelectedStructuresDescription(plugin) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { structures } = plugin.managers.structure.hierarchy.selection;
    if (structures.length === 0)
      return "";
    if (structures.length === 1) {
      const s = structures[0];
      const data = (_a = s.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
      if (!data)
        return ((_b = s.cell.obj) === null || _b === void 0 ? void 0 : _b.label) || "Structure";
      const model = data.models[0] || data.representativeModel || data.masterModel;
      if (!model)
        return ((_c = s.cell.obj) === null || _c === void 0 ? void 0 : _c.label) || "Structure";
      const entryId = model.entryId;
      if (((_e = (_d = s.model) === null || _d === void 0 ? void 0 : _d.trajectory) === null || _e === void 0 ? void 0 : _e.models) && s.model.trajectory.models.length === 1)
        return entryId;
      if (s.model)
        return `${(_f = s.model.cell.obj) === null || _f === void 0 ? void 0 : _f.label} | ${entryId}`;
      return entryId;
    }
    const p = structures[0];
    const t4 = (_g = p === null || p === void 0 ? void 0 : p.model) === null || _g === void 0 ? void 0 : _g.trajectory;
    let sameTraj = true;
    for (const s of structures) {
      if (((_h = s === null || s === void 0 ? void 0 : s.model) === null || _h === void 0 ? void 0 : _h.trajectory) !== t4) {
        sameTraj = false;
        break;
      }
    }
    return sameTraj && t4 ? `${(_j = t4.cell.obj) === null || _j === void 0 ? void 0 : _j.label} | ${structures.length} structures` : `${structures.length} structures`;
  }
  StructureHierarchyManager2.getSelectedStructuresDescription = getSelectedStructuresDescription;
})(StructureHierarchyManager || (StructureHierarchyManager = {}));

// node_modules/molstar/lib/mol-plugin-ui/state/update-transform.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-ui/state/common.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var StateTransformParameters = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.onChange = ({ name: name2, value }) => {
      const params = { ...this.props.params, [name2]: value };
      this.props.events.onChange(params, this.areInitial(params), this.validate(params));
    };
  }
  validate(params) {
    return void 0;
  }
  areInitial(params) {
    return ParamDefinition.areEqual(this.props.info.params, params, this.props.info.initialValues);
  }
  render() {
    return (0, import_jsx_runtime3.jsx)(ParameterControls, { params: this.props.info.params, values: this.props.params, onChange: this.onChange, onEnter: this.props.events.onEnter, isDisabled: this.props.isDisabled });
  }
};
(function(StateTransformParameters2) {
  function areParamsEmpty(params) {
    const keys2 = Object.keys(params);
    for (const k of keys2) {
      if (!params[k].isHidden)
        return false;
    }
    return true;
  }
  function infoFromAction(plugin, state, action, nodeRef) {
    const source = state.cells.get(nodeRef).obj;
    const params = action.definition.params ? action.definition.params(source, plugin) : {};
    const initialValues = ParamDefinition.getDefaultValues(params);
    return {
      initialValues,
      params,
      isEmpty: areParamsEmpty(params)
    };
  }
  StateTransformParameters2.infoFromAction = infoFromAction;
  function infoFromTransform(plugin, state, transform) {
    const cell = state.cells.get(transform.ref);
    const params = cell.params && cell.params.definition || {};
    const initialValues = cell.params && cell.params.values || {};
    return {
      initialValues,
      params,
      isEmpty: areParamsEmpty(params)
    };
  }
  StateTransformParameters2.infoFromTransform = infoFromTransform;
})(StateTransformParameters || (StateTransformParameters = {}));
var TransformControlBase = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.busy = new BehaviorSubject(false);
    this.onEnter = () => {
      if (this.state.error)
        return;
      this.apply();
    };
    this.autoApplyHandle = void 0;
    this.events = {
      onEnter: this.onEnter,
      onChange: (params, isInitial, errors) => {
        this.clearAutoApply();
        this.setState({ params, isInitial, error: errors && errors[0] }, () => {
          if (!isInitial && !this.state.error && this.canAutoApply(params)) {
            this.clearAutoApply();
            this.autoApplyHandle = setTimeout(this.apply, 50);
          }
        });
      }
    };
    this.apply = async () => {
      var _a, _b;
      this.clearAutoApply();
      this.setState({ busy: true });
      try {
        await this.applyAction();
      } catch (e) {
        console.error(e);
      } finally {
        (_b = (_a = this.props).onApply) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.busy.next(false);
      }
    };
    this.refresh = () => {
      this.setState({ params: this.getInfo().initialValues, isInitial: true, error: void 0 });
    };
    this.setDefault = () => {
      const info = this.getInfo();
      const params = ParamDefinition.getDefaultValues(info.params);
      this.setState({ params, isInitial: ParamDefinition.areEqual(info.params, params, info.initialValues), error: void 0 });
    };
    this.toggleExpanded = () => {
      this.setState({ isCollapsed: !this.state.isCollapsed });
    };
  }
  clearAutoApply() {
    if (this.autoApplyHandle !== void 0) {
      clearTimeout(this.autoApplyHandle);
      this.autoApplyHandle = void 0;
    }
  }
  componentDidMount() {
    this.subscribe(this.plugin.behaviors.state.isBusy, (busy) => {
      if (this.busy.value !== busy)
        this.busy.next(busy);
    });
    this.subscribe(this.busy.pipe(skip(1)), (busy) => {
      this.setState({ busy });
    });
  }
  renderApply() {
    const canApply = this.canApply();
    if (this.props.autoHideApply && (!canApply || this.canAutoApply(this.state.params)))
      return null;
    return (0, import_jsx_runtime3.jsxs)("div", { className: "msp-transform-apply-wrap", children: [(0, import_jsx_runtime3.jsx)(IconButton, { svg: RefreshSvg, className: "msp-transform-default-params", onClick: this.setDefault, disabled: this.state.busy, title: "Set default params" }), (0, import_jsx_runtime3.jsx)("div", { className: `msp-transform-apply-wider`, children: (0, import_jsx_runtime3.jsx)(Button, { icon: canApply ? CheckSvg : void 0, className: `msp-btn-commit msp-btn-commit-${canApply ? "on" : "off"}`, onClick: this.apply, disabled: !canApply, children: this.props.applyLabel || this.applyText() }) })] });
  }
  renderDefault() {
    const info = this.getInfo();
    const isEmpty2 = info.isEmpty && this.isUpdate();
    const display = this.getHeader();
    const tId = this.getTransformerId();
    const ParamEditor = this.plugin.customParamEditors.has(tId) ? this.plugin.customParamEditors.get(tId) : StateTransformParameters;
    const wrapClass = this.state.isCollapsed ? "msp-transform-wrapper msp-transform-wrapper-collapsed" : "msp-transform-wrapper";
    let params = null;
    if (!isEmpty2 && !this.state.isCollapsed) {
      const { a: a4, b: b4, bCell } = this.getSourceAndTarget();
      const applyControl = this.renderApply();
      params = (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)(ParamEditor, { info, a: a4, b: b4, bCell, events: this.events, params: this.state.params, isDisabled: this.state.busy }), applyControl] });
    }
    const ctrl = (0, import_jsx_runtime3.jsxs)("div", { className: wrapClass, style: { marginBottom: this.props.noMargin ? 0 : void 0 }, children: [display !== "none" && !this.props.wrapInExpander && (0, import_jsx_runtime3.jsx)("div", { className: "msp-transform-header", children: (0, import_jsx_runtime3.jsxs)(Button, { onClick: this.toggleExpanded, title: display.description, children: [!isEmpty2 && (0, import_jsx_runtime3.jsx)(Icon, { svg: this.state.isCollapsed ? ArrowRightSvg : ArrowDropDownSvg }), display.name] }) }), params] });
    if (isEmpty2 || !this.props.wrapInExpander)
      return ctrl;
    return (0, import_jsx_runtime3.jsx)(ExpandGroup, { header: this.isUpdate() ? `Update ${display === "none" ? "" : display.name}` : `Apply ${display === "none" ? "" : display.name}`, headerLeftMargin: this.props.expanderHeaderLeftMargin, children: ctrl });
  }
  renderSimple() {
    var _a, _b, _c;
    const info = this.getInfo();
    const canApply = this.canApply();
    const apply = (0, import_jsx_runtime3.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime3.jsx)(Button, { icon: (_a = this.props.simpleApply) === null || _a === void 0 ? void 0 : _a.icon, title: (_b = this.props.simpleApply) === null || _b === void 0 ? void 0 : _b.title, disabled: this.state.busy || !canApply, onClick: this.apply, className: "msp-btn-apply-simple", children: (_c = this.props.simpleApply) === null || _c === void 0 ? void 0 : _c.header }), !info.isEmpty && (0, import_jsx_runtime3.jsx)(ToggleButton, { icon: TuneSvg, label: "", title: "Options", toggle: this.toggleExpanded, isSelected: !this.state.isCollapsed, disabled: this.state.busy, style: { flex: "0 0 40px", padding: 0 } })] });
    if (this.state.isCollapsed)
      return apply;
    const tId = this.getTransformerId();
    const ParamEditor = this.plugin.customParamEditors.has(tId) ? this.plugin.customParamEditors.get(tId) : StateTransformParameters;
    const { a: a4, b: b4, bCell } = this.getSourceAndTarget();
    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [apply, (0, import_jsx_runtime3.jsx)(ParamEditor, { info, a: a4, b: b4, bCell, events: this.events, params: this.state.params, isDisabled: this.state.busy })] });
  }
  render() {
    return this.props.simpleApply ? this.renderSimple() : this.renderDefault();
  }
};

// node_modules/molstar/lib/mol-plugin-ui/state/update-transform.js
var UpdateTransformControl = class extends TransformControlBase {
  constructor() {
    super(...arguments);
    this._getInfo = memoizeLatest((t4) => StateTransformParameters.infoFromTransform(this.plugin, this.props.state, t4));
    this.state = { error: void 0, isInitial: true, params: this.getInfo().initialValues, busy: false, isCollapsed: this.props.initiallyCollapsed };
  }
  applyAction() {
    if (this.props.customUpdate)
      return this.props.customUpdate(this.state.params);
    return this.plugin.state.updateTransform(this.props.state, this.props.transform.ref, this.state.params);
  }
  getInfo() {
    return this._getInfo(this.props.transform);
  }
  getTransformerId() {
    return this.props.transform.transformer.id;
  }
  getHeader() {
    return this.props.customHeader || this.props.transform.transformer.definition.display;
  }
  canApply() {
    const { state } = this.props;
    const cell = state.cells.get(this.props.transform.ref);
    if (!cell)
      return false;
    if (cell.status === "error") {
      const parent = state.cells.get(this.props.transform.parent);
      if (!parent)
        return false;
      return parent.status === "ok";
    }
    return !this.state.error && !this.state.busy && !this.state.isInitial;
  }
  applyText() {
    return this.canApply() ? "Update" : "Nothing to Update";
  }
  isUpdate() {
    return true;
  }
  getSourceAndTarget() {
    const bCell = this.props.state.cells.get(this.props.transform.ref);
    return {
      a: this.props.state.cells.get(this.props.transform.parent).obj,
      b: bCell === null || bCell === void 0 ? void 0 : bCell.obj,
      bCell
    };
  }
  canAutoApply(newParams) {
    const autoUpdate = this.props.transform.transformer.definition.canAutoUpdate;
    if (!autoUpdate)
      return false;
    const { state } = this.props;
    const cell = state.cells.get(this.props.transform.ref);
    if (!cell || !cell.sourceRef || cell.status !== "ok")
      return false;
    const parentCell = state.cells.get(cell.sourceRef);
    return autoUpdate({ a: parentCell.obj, b: cell.obj, oldParams: this.getInfo().initialValues, newParams }, this.plugin);
  }
  componentDidMount() {
    super.componentDidMount();
    if (this.props.toggleCollapsed)
      this.subscribe(this.props.toggleCollapsed, () => this.setState({ isCollapsed: !this.state.isCollapsed }));
    this.subscribe(this.plugin.state.events.object.updated, ({ ref, state }) => {
      if (this.props.transform.ref !== ref || this.props.state !== state)
        return;
      if (this.state.params !== this.props.transform.params) {
        this._getInfo = memoizeLatest((t4) => StateTransformParameters.infoFromTransform(this.plugin, this.props.state, t4));
        this.setState({ params: this.props.transform.params, isInitial: true });
      }
    });
  }
  componentDidUpdate(prevProps) {
    var _a;
    if (this.props.transform !== prevProps.transform) {
      const cell = this.props.state.cells.get(this.props.transform.ref);
      this.setState({
        params: ((_a = cell.params) === null || _a === void 0 ? void 0 : _a.values) || {},
        isInitial: true,
        error: void 0,
        simpleOnly: this.state.simpleOnly
      });
    }
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/generic.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var GenericEntryListControls = class extends PurePluginUIComponent {
  get current() {
    return this.plugin.managers.structure.hierarchy.behaviors.selection;
  }
  componentDidMount() {
    this.subscribe(this.current, () => this.forceUpdate());
  }
  get unitcell() {
    var _a;
    const { selection } = this.plugin.managers.structure.hierarchy;
    if (selection.structures.length === 0)
      return null;
    const refs = [];
    for (const s of selection.structures) {
      const model = s.model;
      if ((model === null || model === void 0 ? void 0 : model.unitcell) && ((_a = model.unitcell) === null || _a === void 0 ? void 0 : _a.cell.obj))
        refs.push(model.unitcell);
    }
    if (refs.length === 0)
      return null;
    return (0, import_jsx_runtime5.jsx)(GenericEntry, { refs, labelMultiple: "Unit Cells" });
  }
  get customControls() {
    const controls = [];
    this.plugin.genericRepresentationControls.forEach((provider, key) => {
      const [refs, labelMultiple] = provider(this.plugin.managers.structure.hierarchy.selection);
      if (refs.length > 0) {
        controls.push((0, import_jsx_runtime5.jsx)("div", { children: (0, import_jsx_runtime5.jsx)(GenericEntry, { refs, labelMultiple }) }, key));
      }
    });
    return controls.length > 0 ? controls : null;
  }
  render() {
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: (0, import_jsx_runtime5.jsxs)("div", { style: { marginTop: "6px" }, children: [this.unitcell, this.customControls] }) });
  }
};
var GenericEntry = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { showOptions: false };
    this.toggleVisibility = (e) => {
      e.preventDefault();
      this.plugin.managers.structure.hierarchy.toggleVisibility(this.props.refs);
      e.currentTarget.blur();
    };
    this.highlight = (e) => {
      e.preventDefault();
      if (!this.pivot.cell.parent)
        return;
      PluginCommands.Interactivity.Object.Highlight(this.plugin, {
        state: this.pivot.cell.parent,
        ref: this.props.refs.map((c4) => c4.cell.transform.ref)
      });
    };
    this.clearHighlight = (e) => {
      e.preventDefault();
      PluginCommands.Interactivity.ClearHighlights(this.plugin);
    };
    this.focus = (e) => {
      var _a;
      e.preventDefault();
      let allHidden = true;
      for (const uc of this.props.refs) {
        if (!uc.cell.state.isHidden) {
          allHidden = false;
          break;
        }
      }
      if (allHidden) {
        this.plugin.managers.structure.hierarchy.toggleVisibility(this.props.refs, "show");
      }
      const loci = [];
      for (const uc of this.props.refs) {
        if (uc.cell.state.isHidden) {
          continue;
        }
        const l = (_a = uc.cell.obj) === null || _a === void 0 ? void 0 : _a.data.repr.getLoci();
        if (l)
          loci.push(l);
      }
      this.plugin.managers.camera.focusLoci(loci);
    };
    this.toggleOptions = () => this.setState({ showOptions: !this.state.showOptions });
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      var _a;
      if (State.ObjectEvent.isCell(e, (_a = this.pivot) === null || _a === void 0 ? void 0 : _a.cell))
        this.forceUpdate();
    });
  }
  get pivot() {
    return this.props.refs[0];
  }
  render() {
    const { refs, labelMultiple } = this.props;
    if (refs.length === 0)
      return null;
    const pivot = refs[0];
    let label, description;
    if (refs.length === 1) {
      const { obj } = pivot.cell;
      if (!obj)
        return null;
      label = obj === null || obj === void 0 ? void 0 : obj.label;
      description = obj === null || obj === void 0 ? void 0 : obj.description;
    } else {
      label = `${refs.length} ${labelMultiple || "Objects"}`;
    }
    return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [(0, import_jsx_runtime5.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime5.jsxs)("button", { className: "msp-form-control msp-control-button-label", title: `${label}. Click to focus.`, onClick: this.focus, onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, style: { textAlign: "left" }, children: [label, " ", (0, import_jsx_runtime5.jsx)("small", { children: description })] }), (0, import_jsx_runtime5.jsx)(IconButton, { svg: pivot.cell.state.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, className: "msp-form-control", onClick: this.toggleVisibility, title: `${pivot.cell.state.isHidden ? "Show" : "Hide"}`, small: true, flex: true }), refs.length === 1 && (0, import_jsx_runtime5.jsx)(IconButton, { svg: MoreHorizSvg, className: "msp-form-control", onClick: this.toggleOptions, title: "Options", toggleState: this.state.showOptions, flex: true })] }), refs.length === 1 && this.state.showOptions && pivot.cell.parent && (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: (0, import_jsx_runtime5.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime5.jsx)(UpdateTransformControl, { state: pivot.cell.parent, transform: pivot.cell.transform, customHeader: "none", autoHideApply: true }) }) })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/components.js
var StructureComponentControls = class extends CollapsableControls {
  defaultState() {
    return {
      header: "Components",
      isCollapsed: false,
      isDisabled: false,
      brand: { accent: "blue", svg: CubeOutlineSvg }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (c4) => this.setState({
      description: StructureHierarchyManager.getSelectedStructuresDescription(this.plugin)
    }));
  }
  renderControls() {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(ComponentEditorControls, {}), (0, import_jsx_runtime6.jsx)(ComponentListControls, {}), (0, import_jsx_runtime6.jsx)(GenericEntryListControls, {})] });
  }
};
var ComponentEditorControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isEmpty: true,
      isBusy: false,
      canUndo: false
    };
    this.togglePreset = this.toggleAction("preset");
    this.toggleAdd = this.toggleAction("add");
    this.toggleOptions = this.toggleAction("options");
    this.hideAction = () => this.setState({ action: void 0 });
    this.applyPreset = (item) => {
      this.hideAction();
      if (!item)
        return;
      const mng = this.plugin.managers.structure;
      const { structures } = mng.hierarchy.selection;
      if (item.value === null)
        mng.component.clear(structures);
      else
        mng.component.applyPreset(structures, item.value);
    };
    this.undo = () => {
      const task = this.plugin.state.data.undo();
      if (task)
        this.plugin.runTask(task);
    };
  }
  get isDisabled() {
    return this.state.isBusy || this.state.isEmpty;
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (c4) => this.setState({
      action: this.state.action !== "options" || c4.structures.length === 0 ? void 0 : "options",
      isEmpty: c4.structures.length === 0
    }));
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2, action: this.state.action !== "options" ? void 0 : "options" });
    });
    this.subscribe(this.plugin.state.data.events.historyUpdated, ({ state }) => {
      this.setState({ canUndo: state.canUndo });
    });
  }
  toggleAction(action) {
    return () => this.setState({ action: this.state.action === action ? void 0 : action });
  }
  get presetControls() {
    return (0, import_jsx_runtime6.jsx)(ActionMenu, { items: this.presetActions, onSelect: this.applyPreset });
  }
  get presetActions() {
    const pivot = this.plugin.managers.structure.component.pivotStructure;
    const providers = this.plugin.builders.structure.representation.getPresets(pivot === null || pivot === void 0 ? void 0 : pivot.cell.obj);
    return ActionMenu.createItems(providers, { label: (p) => p.display.name, category: (p) => p.display.group, description: (p) => p.display.description });
  }
  render() {
    const undoTitle = this.state.canUndo ? `Undo ${this.plugin.state.data.latestUndoLabel}` : "Some mistakes of the past can be undone.";
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime6.jsx)(ToggleButton, { icon: BookmarksOutlinedSvg, label: "Preset", title: "Apply a representation preset for the current structure(s).", toggle: this.togglePreset, isSelected: this.state.action === "preset", disabled: this.isDisabled }), (0, import_jsx_runtime6.jsx)(ToggleButton, { icon: AddSvg, label: "Add", title: "Add a new representation component for a selection.", toggle: this.toggleAdd, isSelected: this.state.action === "add", disabled: this.isDisabled }), (0, import_jsx_runtime6.jsx)(ToggleButton, { icon: TuneSvg, label: "", title: "Options that are applied to all applicable representations.", style: { flex: "0 0 40px", padding: 0 }, toggle: this.toggleOptions, isSelected: this.state.action === "options", disabled: this.isDisabled }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: RestoreSvg, className: "msp-flex-item", flex: "40px", onClick: this.undo, disabled: !this.state.canUndo || this.isDisabled, title: undoTitle })] }), this.state.action === "preset" && this.presetControls, this.state.action === "add" && (0, import_jsx_runtime6.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime6.jsx)(AddComponentControls, { onApply: this.hideAction }) }), this.state.action === "options" && (0, import_jsx_runtime6.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime6.jsx)(ComponentOptionsControls, { isDisabled: this.isDisabled }) })] });
  }
};
var AddComponentControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = this.createState();
    this.apply = () => {
      const structures = this.props.forSelection ? this.currentStructures : this.selectedStructures;
      this.props.onApply();
      this.plugin.managers.structure.component.add(this.state.values, structures);
    };
    this.paramsChanged = (values2) => this.setState({ values: values2 });
  }
  createState() {
    const params = StructureComponentManager.getAddParams(this.plugin);
    return { params, values: ParamDefinition.getDefaultValues(params) };
  }
  get selectedStructures() {
    return this.plugin.managers.structure.component.currentStructures;
  }
  get currentStructures() {
    return this.plugin.managers.structure.hierarchy.current.structures;
  }
  render() {
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(ParameterControls, { params: this.state.params, values: this.state.values, onChangeValues: this.paramsChanged }), (0, import_jsx_runtime6.jsx)(Button, { icon: AddSvg, title: "Use Selection and optional Representation to create a new Component.", className: "msp-btn-commit msp-btn-commit-on", onClick: this.apply, style: { marginTop: "1px" }, children: "Create Component" })] });
  }
};
var ComponentOptionsControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.update = (options) => this.plugin.managers.structure.component.setOptions(options);
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.component.events.optionsUpdated, () => this.forceUpdate());
  }
  render() {
    return (0, import_jsx_runtime6.jsx)(ParameterControls, { params: StructureComponentManager.OptionsParams, values: this.plugin.managers.structure.component.state.options, onChangeValues: this.update, isDisabled: this.props.isDisabled });
  }
};
var ComponentListControls = class extends PurePluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, () => {
      this.forceUpdate();
    });
  }
  render() {
    const componentGroups = this.plugin.managers.structure.hierarchy.currentComponentGroups;
    if (componentGroups.length === 0)
      return null;
    return (0, import_jsx_runtime6.jsx)("div", { style: { marginTop: "6px" }, children: componentGroups.map((g) => (0, import_jsx_runtime6.jsx)(StructureComponentGroup, { group: g }, g[0].cell.transform.ref)) });
  }
};
var StructureComponentGroup = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { action: void 0 };
    this.toggleVisible = (e) => {
      e.preventDefault();
      e.currentTarget.blur();
      this.plugin.managers.structure.component.toggleVisibility(this.props.group);
    };
    this.selectAction = (item) => {
      if (!item)
        return;
      (item === null || item === void 0 ? void 0 : item.value)();
    };
    this.remove = () => this.plugin.managers.structure.hierarchy.remove(this.props.group, true);
    this.toggleAction = () => this.setState({ action: this.state.action === "action" ? void 0 : "action" });
    this.toggleLabel = () => this.setState({ action: this.state.action === "label" ? void 0 : "label" });
    this.highlight = (e) => {
      e.preventDefault();
      if (!this.props.group[0].cell.parent)
        return;
      PluginCommands.Interactivity.Object.Highlight(this.plugin, { state: this.props.group[0].cell.parent, ref: this.props.group.map((c4) => c4.cell.transform.ref) });
    };
    this.clearHighlight = (e) => {
      e.preventDefault();
      PluginCommands.Interactivity.ClearHighlights(this.plugin);
    };
    this.focus = () => {
      let allHidden = true;
      for (const c4 of this.props.group) {
        if (!c4.cell.state.isHidden) {
          allHidden = false;
          break;
        }
      }
      if (allHidden) {
        this.plugin.managers.structure.hierarchy.toggleVisibility(this.props.group, "show");
      }
      this.plugin.managers.camera.focusSpheres(this.props.group, (e) => {
        var _a;
        if (e.cell.state.isHidden)
          return;
        return (_a = e.cell.obj) === null || _a === void 0 ? void 0 : _a.data.boundary.sphere;
      });
    };
    this.updateLabel = (v2) => {
      this.plugin.managers.structure.component.updateLabel(this.pivot, v2);
    };
  }
  get pivot() {
    return this.props.group[0];
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      if (State.ObjectEvent.isCell(e, this.pivot.cell))
        this.forceUpdate();
    });
  }
  get colorByActions() {
    var _a, _b;
    const mng = this.plugin.managers.structure.component;
    const repr = this.pivot.representations[0];
    const name2 = (_a = repr.cell.transform.params) === null || _a === void 0 ? void 0 : _a.colorTheme.name;
    const themes = getStructureThemeTypes(this.plugin, (_b = this.pivot.cell.obj) === null || _b === void 0 ? void 0 : _b.data);
    return ActionMenu.createItemsFromSelectOptions(themes, {
      value: (o) => () => mng.updateRepresentationsTheme(this.props.group, { color: o[0] }),
      selected: (o) => o[0] === name2
    });
  }
  get actions() {
    const mng = this.plugin.managers.structure.component;
    const ret = [
      [
        ActionMenu.Header("Add Representation"),
        ...StructureComponentManager.getRepresentationTypes(this.plugin, this.props.group[0]).map((t4) => ActionMenu.Item(t4[1], () => mng.addRepresentation(this.props.group, t4[0])))
      ]
    ];
    if (this.pivot.representations.length > 0) {
      ret.push([
        ActionMenu.Header("Set Coloring", { isIndependent: true }),
        ...this.colorByActions
      ]);
    }
    if (mng.canBeModified(this.props.group[0])) {
      ret.push([
        ActionMenu.Header("Modify by Selection"),
        ActionMenu.Item("Include", () => mng.modifyByCurrentSelection(this.props.group, "union"), { icon: UnionSvg }),
        ActionMenu.Item("Subtract", () => mng.modifyByCurrentSelection(this.props.group, "subtract"), { icon: SubtractSvg }),
        ActionMenu.Item("Intersect", () => mng.modifyByCurrentSelection(this.props.group, "intersect"), { icon: IntersectSvg })
      ]);
    }
    ret.push(ActionMenu.Item("Select This", () => mng.selectThis(this.props.group), { icon: SetSvg }));
    if (mng.canBeModified(this.props.group[0])) {
      ret.push(ActionMenu.Item("Edit Label", this.toggleLabel));
    }
    return ret;
  }
  get reprLabel() {
    var _a;
    const pivot = this.pivot;
    if (pivot.representations.length === 0)
      return "No repr.";
    if (pivot.representations.length === 1)
      return (_a = pivot.representations[0].cell.obj) === null || _a === void 0 ? void 0 : _a.label;
    return `${pivot.representations.length} reprs`;
  }
  render() {
    var _a;
    const component = this.pivot;
    const cell = component.cell;
    const label = (_a = cell.obj) === null || _a === void 0 ? void 0 : _a.label;
    const reprLabel = this.reprLabel;
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime6.jsxs)(Button, { noOverflow: true, className: "msp-control-button-label", title: `${label}. Click to focus.`, onClick: this.focus, onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, style: { textAlign: "left" }, children: [label, (0, import_jsx_runtime6.jsx)("small", { className: "msp-25-lower-contrast-text", style: { float: "right" }, children: reprLabel })] }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: cell.state.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, onClick: this.toggleVisible, title: `${cell.state.isHidden ? "Show" : "Hide"} component`, small: true, className: "msp-form-control", flex: true }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: DeleteOutlinedSvg, toggleState: false, onClick: this.remove, title: "Remove", small: true, className: "msp-form-control", flex: true }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: MoreHorizSvg, onClick: this.toggleAction, title: "Actions", toggleState: this.state.action === "action", className: "msp-form-control", flex: true })] }), this.state.action === "label" && (0, import_jsx_runtime6.jsx)("div", { className: "msp-control-offset", style: { marginBottom: "6px" }, children: (0, import_jsx_runtime6.jsx)(ControlRow, { label: "Label", control: (0, import_jsx_runtime6.jsxs)("div", { style: { display: "flex", textAlignLast: "center" }, children: [(0, import_jsx_runtime6.jsx)(TextInput, { onChange: this.updateLabel, value: label, style: { flex: "1 1 auto", minWidth: 0 }, className: "msp-form-control", blurOnEnter: true, blurOnEscape: true }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: CheckSvg, onClick: this.toggleLabel, className: "msp-form-control msp-control-button-label", flex: true })] }) }) }), this.state.action === "action" && (0, import_jsx_runtime6.jsxs)("div", { className: "msp-accent-offset", children: [(0, import_jsx_runtime6.jsx)("div", { style: { marginBottom: "6px" }, children: (0, import_jsx_runtime6.jsx)(ActionMenu, { items: this.actions, onSelect: this.selectAction, noOffset: true }) }), (0, import_jsx_runtime6.jsx)("div", { style: { marginBottom: "6px" }, children: component.representations.map((r) => (0, import_jsx_runtime6.jsx)(StructureRepresentationEntry, { group: this.props.group, representation: r }, r.cell.transform.ref)) })] })] });
  }
};
var StructureRepresentationEntry = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.remove = () => this.plugin.managers.structure.component.removeRepresentations(this.props.group, this.props.representation);
    this.toggleVisible = (e) => {
      e.preventDefault();
      e.currentTarget.blur();
      this.plugin.managers.structure.component.toggleVisibility(this.props.group, this.props.representation);
    };
    this.update = (params) => this.plugin.managers.structure.component.updateRepresentations(this.props.group, this.props.representation, params);
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      if (State.ObjectEvent.isCell(e, this.props.representation.cell))
        this.forceUpdate();
    });
  }
  render() {
    var _a;
    const repr = this.props.representation.cell;
    return (0, import_jsx_runtime6.jsxs)("div", { className: "msp-representation-entry", children: [repr.parent && (0, import_jsx_runtime6.jsx)(ExpandGroup, { header: `${((_a = repr.obj) === null || _a === void 0 ? void 0 : _a.label) || ""} Representation`, noOffset: true, children: (0, import_jsx_runtime6.jsx)(UpdateTransformControl, { state: repr.parent, transform: repr.transform, customHeader: "none", customUpdate: this.update, noMargin: true }) }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: DeleteOutlinedSvg, onClick: this.remove, title: "Remove", small: true, className: "msp-default-bg", toggleState: false, style: {
      position: "absolute",
      top: 0,
      right: "32px",
      lineHeight: "24px",
      height: "24px",
      textAlign: "right",
      width: "44px",
      paddingRight: "6px",
      background: "none"
    } }), (0, import_jsx_runtime6.jsx)(IconButton, { svg: this.props.representation.cell.state.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, onClick: this.toggleVisible, title: "Toggle Visibility", small: true, className: "msp-default-bg", style: {
      position: "absolute",
      top: 0,
      right: 0,
      lineHeight: "24px",
      height: "24px",
      textAlign: "right",
      width: "32px",
      paddingRight: "6px",
      background: "none"
    } })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/measurements.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-state/manager/structure/measurement.js
var MeasurementGroupTag = "measurement-group";
var MeasurementOrderLabelTag = "measurement-order-label";
var StructureMeasurementParams = {
  distanceUnitLabel: ParamDefinition.Text("", { isEssential: true }),
  textColor: MeasurementRepresentationCommonTextParams.textColor
};
var DefaultStructureMeasurementOptions = ParamDefinition.getDefaultValues(StructureMeasurementParams);
function serializeLoci(loci) {
  return { bundle: element_exports.Bundle.fromLoci(loci) };
}
var StructureMeasurementManager = class extends StatefulPluginComponent {
  stateUpdated() {
    this.behaviors.state.next(this.state);
  }
  getGroup() {
    const state = this.plugin.state.data;
    const groupRef = StateSelection.findTagInSubtree(state.tree, Transform.RootRef, MeasurementGroupTag);
    const builder = this.plugin.state.data.build();
    if (groupRef)
      return builder.to(groupRef);
    return builder.toRoot().group(StateTransforms.Misc.CreateGroup, { label: `Measurements` }, { tags: MeasurementGroupTag });
  }
  async setOptions(options) {
    if (this.updateState({ options }))
      this.stateUpdated();
    const update = this.plugin.state.data.build();
    for (const cell of this.state.distances) {
      update.to(cell).update((old) => {
        old.unitLabel = options.distanceUnitLabel;
        old.textColor = options.textColor;
      });
    }
    for (const cell of this.state.labels) {
      update.to(cell).update((old) => {
        old.textColor = options.textColor;
      });
    }
    for (const cell of this.state.angles) {
      update.to(cell).update((old) => {
        old.textColor = options.textColor;
      });
    }
    for (const cell of this.state.dihedrals) {
      update.to(cell).update((old) => {
        old.textColor = options.textColor;
      });
    }
    if (update.editInfo.count === 0)
      return;
    await PluginCommands.State.Update(this.plugin, { state: this.plugin.state.data, tree: update, options: { doNotLogTiming: true } });
  }
  async addDistance(a4, b4, options) {
    const cellA = this.plugin.helpers.substructureParent.get(a4.structure);
    const cellB = this.plugin.helpers.substructureParent.get(b4.structure);
    if (!cellA || !cellB)
      return;
    const dependsOn = [cellA.transform.ref];
    arraySetAdd(dependsOn, cellB.transform.ref);
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections: [
        { key: "a", groupId: "a", ref: cellA.transform.ref, ...serializeLoci(a4) },
        { key: "b", groupId: "b", ref: cellB.transform.ref, ...serializeLoci(b4) }
      ],
      isTransitive: true,
      label: "Distance"
    }, { dependsOn, tags: options === null || options === void 0 ? void 0 : options.selectionTags });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsDistance3D, {
      customText: (options === null || options === void 0 ? void 0 : options.customText) || "",
      unitLabel: this.state.options.distanceUnitLabel,
      textColor: this.state.options.textColor,
      ...options === null || options === void 0 ? void 0 : options.lineParams,
      ...options === null || options === void 0 ? void 0 : options.labelParams,
      ...options === null || options === void 0 ? void 0 : options.visualParams
    }, { tags: options === null || options === void 0 ? void 0 : options.reprTags });
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: representation, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addAngle(a4, b4, c4, options) {
    const cellA = this.plugin.helpers.substructureParent.get(a4.structure);
    const cellB = this.plugin.helpers.substructureParent.get(b4.structure);
    const cellC = this.plugin.helpers.substructureParent.get(c4.structure);
    if (!cellA || !cellB || !cellC)
      return;
    const dependsOn = [cellA.transform.ref];
    arraySetAdd(dependsOn, cellB.transform.ref);
    arraySetAdd(dependsOn, cellC.transform.ref);
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections: [
        { key: "a", ref: cellA.transform.ref, ...serializeLoci(a4) },
        { key: "b", ref: cellB.transform.ref, ...serializeLoci(b4) },
        { key: "c", ref: cellC.transform.ref, ...serializeLoci(c4) }
      ],
      isTransitive: true,
      label: "Angle"
    }, { dependsOn, tags: options === null || options === void 0 ? void 0 : options.selectionTags });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsAngle3D, {
      customText: (options === null || options === void 0 ? void 0 : options.customText) || "",
      textColor: this.state.options.textColor,
      ...options === null || options === void 0 ? void 0 : options.lineParams,
      ...options === null || options === void 0 ? void 0 : options.labelParams,
      ...options === null || options === void 0 ? void 0 : options.visualParams
    }, { tags: options === null || options === void 0 ? void 0 : options.reprTags });
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: representation, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addDihedral(a4, b4, c4, d3, options) {
    const cellA = this.plugin.helpers.substructureParent.get(a4.structure);
    const cellB = this.plugin.helpers.substructureParent.get(b4.structure);
    const cellC = this.plugin.helpers.substructureParent.get(c4.structure);
    const cellD = this.plugin.helpers.substructureParent.get(d3.structure);
    if (!cellA || !cellB || !cellC || !cellD)
      return;
    const dependsOn = [cellA.transform.ref];
    arraySetAdd(dependsOn, cellB.transform.ref);
    arraySetAdd(dependsOn, cellC.transform.ref);
    arraySetAdd(dependsOn, cellD.transform.ref);
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections: [
        { key: "a", ref: cellA.transform.ref, ...serializeLoci(a4) },
        { key: "b", ref: cellB.transform.ref, ...serializeLoci(b4) },
        { key: "c", ref: cellC.transform.ref, ...serializeLoci(c4) },
        { key: "d", ref: cellD.transform.ref, ...serializeLoci(d3) }
      ],
      isTransitive: true,
      label: "Dihedral"
    }, { dependsOn, tags: options === null || options === void 0 ? void 0 : options.selectionTags });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsDihedral3D, {
      customText: (options === null || options === void 0 ? void 0 : options.customText) || "",
      textColor: this.state.options.textColor,
      ...options === null || options === void 0 ? void 0 : options.lineParams,
      ...options === null || options === void 0 ? void 0 : options.labelParams,
      ...options === null || options === void 0 ? void 0 : options.visualParams
    }, { tags: options === null || options === void 0 ? void 0 : options.reprTags });
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: representation, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addLabel(a4, options) {
    const cellA = this.plugin.helpers.substructureParent.get(a4.structure);
    if (!cellA)
      return;
    const dependsOn = [cellA.transform.ref];
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections: [
        { key: "a", ref: cellA.transform.ref, ...serializeLoci(a4) }
      ],
      isTransitive: true,
      label: "Label"
    }, { dependsOn, tags: options === null || options === void 0 ? void 0 : options.selectionTags });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsLabel3D, {
      textColor: this.state.options.textColor,
      ...options === null || options === void 0 ? void 0 : options.labelParams,
      ...options === null || options === void 0 ? void 0 : options.visualParams
    }, { tags: options === null || options === void 0 ? void 0 : options.reprTags });
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: representation, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addOrientation(locis) {
    const selections = [];
    const dependsOn = [];
    for (let i = 0, il = locis.length; i < il; ++i) {
      const l = locis[i];
      const cell = this.plugin.helpers.substructureParent.get(l.structure);
      if (!cell)
        continue;
      arraySetAdd(dependsOn, cell.transform.ref);
      selections.push({ key: `l${i}`, ref: cell.transform.ref, ...serializeLoci(l) });
    }
    if (selections.length === 0)
      return;
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections,
      isTransitive: true,
      label: "Orientation"
    }, { dependsOn });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsOrientation3D);
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: representation, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addPlane(locis) {
    const selections = [];
    const dependsOn = [];
    for (let i = 0, il = locis.length; i < il; ++i) {
      const l = locis[i];
      const cell = this.plugin.helpers.substructureParent.get(l.structure);
      if (!cell)
        continue;
      arraySetAdd(dependsOn, cell.transform.ref);
      selections.push({ key: `l${i}`, ref: cell.transform.ref, ...serializeLoci(l) });
    }
    if (selections.length === 0)
      return;
    const update = this.getGroup();
    const selection = update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
      selections,
      isTransitive: true,
      label: "Plane"
    }, { dependsOn });
    const representation = selection.apply(StateTransforms.Representation.StructureSelectionsPlane3D);
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: update, options: { doNotLogTiming: true } });
    return { selection: selection.selector, representation: representation.selector };
  }
  async addOrderLabels(locis) {
    const update = this.getGroup();
    const current = this.plugin.state.data.select(StateSelection.Generators.ofType(PluginStateObject.Molecule.Structure.Selections).withTag(MeasurementOrderLabelTag));
    for (const obj of current)
      update.delete(obj);
    let order2 = 1;
    for (const loci of locis) {
      const cell = this.plugin.helpers.substructureParent.get(loci.structure);
      if (!cell)
        continue;
      const dependsOn = [cell.transform.ref];
      update.apply(StateTransforms.Model.MultiStructureSelectionFromBundle, {
        selections: [
          { key: "a", ref: cell.transform.ref, ...serializeLoci(loci) }
        ],
        isTransitive: true,
        label: "Order"
      }, { dependsOn, tags: MeasurementOrderLabelTag }).apply(StateTransforms.Representation.StructureSelectionsLabel3D, {
        textColor: Color.fromRgb(255, 255, 255),
        borderColor: Color.fromRgb(0, 0, 0),
        textSize: 0.33,
        borderWidth: 0.3,
        offsetZ: 0.75,
        customText: `${order2++}`
      }, { tags: MeasurementOrderLabelTag });
    }
    const state = this.plugin.state.data;
    await PluginCommands.State.Update(this.plugin, { state, tree: update, options: { doNotLogTiming: true } });
    return { representation: update.selector };
  }
  getTransforms(transformer) {
    const state = this.plugin.state.data;
    const groupRef = StateSelection.findTagInSubtree(state.tree, Transform.RootRef, MeasurementGroupTag);
    const ret = groupRef ? state.select(StateSelection.Generators.ofTransformer(transformer, groupRef)) : this._empty;
    if (ret.length === 0)
      return this._empty;
    return ret;
  }
  sync() {
    const labels = [];
    for (const cell of this.getTransforms(StateTransforms.Representation.StructureSelectionsLabel3D)) {
      const tags = cell.obj["tags"];
      if (!tags || !tags.includes(MeasurementOrderLabelTag))
        labels.push(cell);
    }
    const updated = this.updateState({
      labels,
      distances: this.getTransforms(StateTransforms.Representation.StructureSelectionsDistance3D),
      angles: this.getTransforms(StateTransforms.Representation.StructureSelectionsAngle3D),
      dihedrals: this.getTransforms(StateTransforms.Representation.StructureSelectionsDihedral3D),
      orientations: this.getTransforms(StateTransforms.Representation.StructureSelectionsOrientation3D),
      planes: this.getTransforms(StateTransforms.Representation.StructureSelectionsPlane3D)
    });
    if (updated)
      this.stateUpdated();
  }
  constructor(plugin) {
    super({ labels: [], distances: [], angles: [], dihedrals: [], orientations: [], planes: [], options: DefaultStructureMeasurementOptions });
    this.plugin = plugin;
    this.behaviors = {
      state: this.ev.behavior(this.state)
    };
    this._empty = [];
    plugin.state.data.events.changed.subscribe((e) => {
      if (e.inTransaction || plugin.behaviors.state.isAnimating.value)
        return;
      this.sync();
    });
    plugin.behaviors.state.isAnimating.subscribe((isAnimating) => {
      if (!isAnimating && !plugin.behaviors.state.isUpdating.value)
        this.sync();
    });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/selection.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var React2 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin-state/manager/interactivity.js
var InteractivityManager = class _InteractivityManager extends StatefulPluginComponent {
  get props() {
    return { ...this.state.props };
  }
  setProps(props) {
    const old = this.props;
    const _new = { ...this.state.props, ...props };
    if (shallowEqual2(old, _new))
      return;
    this.updateState({ props: _new });
    this.lociSelects.setProps(_new);
    this.lociHighlights.setProps(_new);
    this.events.propsUpdated.next(void 0);
  }
  dispose() {
    super.dispose();
    this.lociSelects.dispose();
    this.lociHighlights.dispose();
  }
  constructor(plugin, props = {}) {
    super({ props: { ...ParamDefinition.getDefaultValues(_InteractivityManager.Params), ...props } });
    this.plugin = plugin;
    this._props = ParamDefinition.getDefaultValues(_InteractivityManager.Params);
    this.events = {
      propsUpdated: this.ev()
    };
    this.lociSelects = new _InteractivityManager.LociSelectManager(plugin, this._props);
    this.lociHighlights = new _InteractivityManager.LociHighlightManager(plugin, this._props);
  }
};
(function(InteractivityManager2) {
  InteractivityManager2.Params = {
    granularity: ParamDefinition.Select("residue", Loci.GranularityOptions, { label: "Picking Level", description: "Controls if selections are expanded upon picking to whole residues, chains, structures, instances, or left as atoms and coarse elements" })
  };
  class LociMarkManager {
    setProps(props) {
      Object.assign(this.props, props);
    }
    addProvider(provider) {
      this.providers.push(provider);
    }
    removeProvider(provider) {
      this.providers = this.providers.filter((p) => p !== provider);
    }
    normalizedLoci(reprLoci, applyGranularity, alwaysConvertBonds = false) {
      const { loci, repr } = reprLoci;
      const granularity = applyGranularity ? this.props.granularity : void 0;
      return { loci: Loci.normalize(loci, granularity, alwaysConvertBonds), repr };
    }
    mark(current, action, noRender = false) {
      if (!Loci.isEmpty(current.loci)) {
        for (const p of this.providers)
          p(current, action, noRender);
      }
    }
    dispose() {
      this.providers.length = 0;
      this.sel.dispose();
    }
    constructor(ctx, props = {}) {
      this.ctx = ctx;
      this.providers = [];
      this.props = ParamDefinition.getDefaultValues(InteractivityManager2.Params);
      this.sel = ctx.managers.structure.selection;
      this.setProps(props);
    }
  }
  InteractivityManager2.LociMarkManager = LociMarkManager;
  class LociHighlightManager extends LociMarkManager {
    constructor() {
      super(...arguments);
      this.prev = [];
      this.clearHighlights = (noRender = false) => {
        for (const p of this.prev) {
          this.mark(p, MarkerAction.RemoveHighlight, noRender);
        }
        this.prev.length = 0;
      };
    }
    isHighlighted(loci) {
      for (const p of this.prev) {
        if (Representation.Loci.areEqual(p, loci))
          return true;
      }
      return false;
    }
    addHighlight(loci) {
      this.mark(loci, MarkerAction.Highlight);
      this.prev.push(loci);
    }
    highlight(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity);
      if (!this.isHighlighted(normalized)) {
        this.addHighlight(normalized);
      }
    }
    highlightOnly(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity);
      if (!this.isHighlighted(normalized)) {
        if (Loci.isEmpty(normalized.loci)) {
          this.clearHighlights();
        } else {
          this.clearHighlights(true);
          this.addHighlight(normalized);
        }
      }
    }
    highlightOnlyExtend(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity);
      if (element_exports.Loci.is(normalized.loci)) {
        const range = this.ctx.selectionMode ? this.sel.tryGetRange(normalized.loci) : this.ctx.managers.structure.focus.tryGetRange(normalized.loci);
        const extended = {
          loci: range !== null && range !== void 0 ? range : normalized.loci,
          repr: normalized.repr
        };
        if (!this.isHighlighted(extended)) {
          if (Loci.isEmpty(extended.loci)) {
            this.clearHighlights();
          } else {
            this.clearHighlights(true);
            this.addHighlight(extended);
          }
        }
      }
    }
    dispose() {
      super.dispose();
      this.prev.length = 0;
    }
  }
  InteractivityManager2.LociHighlightManager = LociHighlightManager;
  class LociSelectManager extends LociMarkManager {
    toggle(current, applyGranularity = true) {
      if (Loci.isEmpty(current.loci))
        return;
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        this.toggleSel(normalized);
      } else {
        super.mark(normalized, MarkerAction.Toggle);
      }
    }
    toggleExtend(current, applyGranularity = true) {
      if (Loci.isEmpty(current.loci))
        return;
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        const loci = this.sel.tryGetRange(normalized.loci) || normalized.loci;
        this.toggleSel({ loci, repr: normalized.repr });
      }
    }
    select(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        this.sel.modify("add", normalized.loci);
      }
      this.mark(normalized, MarkerAction.Select);
    }
    selectJoin(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        this.sel.modify("intersect", normalized.loci);
      }
      this.mark(normalized, MarkerAction.Select);
    }
    selectOnly(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        this.mark({ loci: Structure.Loci(normalized.loci.structure), repr: normalized.repr }, MarkerAction.Deselect);
        this.sel.modify("set", normalized.loci);
      }
      this.mark(normalized, MarkerAction.Select);
    }
    deselect(current, applyGranularity = true) {
      const normalized = this.normalizedLoci(current, applyGranularity, true);
      if (element_exports.Loci.is(normalized.loci)) {
        this.sel.modify("remove", normalized.loci);
      }
      this.mark(normalized, MarkerAction.Deselect);
    }
    deselectAll() {
      this.sel.clear();
      this.mark({ loci: EveryLoci }, MarkerAction.Deselect);
    }
    deselectAllOnEmpty(current) {
      if (isEmptyLoci(current.loci))
        this.deselectAll();
    }
    mark(current, action) {
      const { loci } = current;
      if (!Loci.isEmpty(loci)) {
        if (element_exports.Loci.is(loci)) {
          const selLoci = this.sel.getLoci(loci.structure);
          super.mark({ loci: Structure.Loci(loci.structure) }, MarkerAction.Deselect, !Loci.isEmpty(selLoci));
          super.mark({ loci: selLoci }, MarkerAction.Select);
        } else {
          super.mark(current, action);
        }
      }
    }
    toggleSel(current) {
      if (this.sel.has(current.loci)) {
        this.sel.modify("remove", current.loci);
        this.mark(current, MarkerAction.Deselect);
      } else {
        this.sel.modify("add", current.loci);
        this.mark(current, MarkerAction.Select);
      }
    }
  }
  InteractivityManager2.LociSelectManager = LociSelectManager;
})(InteractivityManager || (InteractivityManager = {}));

// node_modules/molstar/lib/mol-script/util/id-list.js
function residueEntriesToQuery(xs, kind) {
  var _a;
  const groups = [];
  const asym_id_key = kind === "auth" ? "auth_asym_id" : "label_asym_id";
  const seq_id_key = kind === "auth" ? "auth_seq_id" : "label_seq_id";
  for (const x of xs) {
    if (x.kind === "range") {
      groups.push(MolScriptBuilder.struct.generator.atomGroups({
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp(asym_id_key), x.asym_id]),
        "residue-test": MolScriptBuilder.core.rel.inRange([MolScriptBuilder.ammp(seq_id_key), x.seq_id_beg, x.seq_id_end])
      }));
    } else {
      const ins_code = ((_a = x.ins_code) !== null && _a !== void 0 ? _a : "").trim();
      groups.push(MolScriptBuilder.struct.generator.atomGroups({
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp(asym_id_key), x.asym_id]),
        "residue-test": MolScriptBuilder.core.logic.and([
          MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp(seq_id_key), x.seq_id]),
          MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("pdbx_PDB_ins_code"), ins_code])
        ])
      }));
    }
  }
  const query = MolScriptBuilder.struct.combinator.merge(groups);
  return compile(query);
}
function atomEntriesToQuery(xs) {
  const set = UniqueArray.create();
  for (const [a4, b4] of xs) {
    for (let i = a4; i <= b4; i++) {
      UniqueArray.add(set, i, i);
    }
  }
  const query = MolScriptBuilder.struct.generator.atomGroups({
    "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...set.array), MolScriptBuilder.ammp("id")])
  });
  return compile(query);
}
function elementSymbolNumberEntriesToQuery(xs) {
  const set = UniqueArray.create();
  for (const [a4, b4] of xs) {
    for (let i = a4; i <= b4; i++) {
      UniqueArray.add(set, i.toString(), i.toString());
    }
  }
  const query = MolScriptBuilder.struct.generator.atomGroups({
    "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...set.array), MolScriptBuilder.acp("elementSymbol")])
  });
  return compile(query);
}
function elementSymbolStringEntriesToQuery(names) {
  const query = MolScriptBuilder.struct.generator.atomGroups({
    "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...names), MolScriptBuilder.acp("elementSymbol")])
  });
  return compile(query);
}
function parseRange(c4, s, e) {
  if (!c4 || s.length === 0 || Number.isNaN(+s[0]))
    return;
  if (Number.isNaN(e)) {
    return { kind: "single", asym_id: c4, seq_id: +s[0], ins_code: s[1] };
  }
  return { kind: "range", asym_id: c4, seq_id_beg: +s[0], seq_id_end: e };
}
function parseInsCode(e) {
  if (!e)
    return [];
  return e.split(":");
}
function parseResidueListSelection(input) {
  return input.split(",").map((e) => e.trim().split(/\s+|[-]/g).filter((e2) => !!e2)).map((e) => parseRange(e[0], parseInsCode(e[1]), +e[2])).filter((e) => !!e);
}
function parseAtomListSelection(input) {
  return input.split(",").map((e) => e.trim().split(/\s+|[-]/g).filter((e2) => !!e2)).filter((e) => e.length === 1 || e.length === 2).map((e) => e.length === 1 ? [+e[0], +e[0]] : [+e[0], +e[1]]);
}
function compileIdListSelection(input, idType) {
  if (idType === "atom-id") {
    const entries = parseAtomListSelection(input);
    return atomEntriesToQuery(entries);
  } else if (idType === "element-symbol") {
    const containsLetters = /[a-zA-Z]/.test(input);
    if (containsLetters) {
      return elementSymbolStringEntriesToQuery(input.split(",").map((e) => e.trim()));
    } else {
      const entries = parseAtomListSelection(input);
      return elementSymbolNumberEntriesToQuery(entries);
    }
  } else {
    const entries = parseResidueListSelection(input);
    return residueEntriesToQuery(entries, idType);
  }
}

// node_modules/molstar/lib/mol-plugin-ui/viewport/help.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var React = __toESM(require_react());
function getBindingsList(bindings) {
  return Object.keys(bindings).map((k) => [k, bindings[k]]).filter((b4) => Binding.isBinding(b4[1]));
}
var BindingsHelp = class extends React.PureComponent {
  getBindingComponents() {
    const bindingsList = getBindingsList(this.props.bindings);
    return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: bindingsList.map((value) => {
      const [name2, binding] = value;
      return !Binding.isEmpty(binding) ? (0, import_jsx_runtime7.jsxs)("div", { style: { marginBottom: "6px" }, children: [(0, import_jsx_runtime7.jsx)("b", { children: binding.action }), (0, import_jsx_runtime7.jsx)("br", {}), (0, import_jsx_runtime7.jsx)("span", { dangerouslySetInnerHTML: { __html: Binding.format(binding, name2) } })] }, name2) : null;
    }) });
  }
  render() {
    return (0, import_jsx_runtime7.jsx)(HelpText, { children: this.getBindingComponents() });
  }
};
var HelpText = class extends React.PureComponent {
  render() {
    return (0, import_jsx_runtime7.jsx)("div", { className: "msp-help-text", children: (0, import_jsx_runtime7.jsx)("div", { children: this.props.children }) });
  }
};
var HelpGroup = class extends React.PureComponent {
  constructor() {
    super(...arguments);
    this.state = {
      header: this.props.header,
      isExpanded: !!this.props.initiallyExpanded
    };
    this.toggleExpanded = () => this.setState({ isExpanded: !this.state.isExpanded });
  }
  render() {
    return (0, import_jsx_runtime7.jsxs)("div", { className: "msp-control-group-wrapper", children: [(0, import_jsx_runtime7.jsx)("div", { className: "msp-control-group-header", children: (0, import_jsx_runtime7.jsxs)(Button, { onClick: this.toggleExpanded, children: [(0, import_jsx_runtime7.jsx)(Icon, { svg: this.state.isExpanded ? ArrowDropDownSvg : ArrowRightSvg }), this.props.header] }) }), this.state.isExpanded && (0, import_jsx_runtime7.jsx)("div", { className: "msp-control-offset", style: { display: this.state.isExpanded ? "block" : "none" }, children: this.props.children })] });
  }
};
function HelpSection(props) {
  return (0, import_jsx_runtime7.jsx)("div", { className: "msp-simple-help-section", children: props.header });
}
var ViewportHelpContent = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.getInteractionBindings = memoizeLatest((cells) => {
      let interactionBindings = void 0;
      cells.forEach((c4) => {
        var _a;
        const params = (_a = c4.params) === null || _a === void 0 ? void 0 : _a.values;
        if ((params === null || params === void 0 ? void 0 : params.bindings) && Object.keys(params.bindings).length > 0) {
          if (!interactionBindings)
            interactionBindings = {};
          Object.assign(interactionBindings, params.bindings);
        }
      });
      return interactionBindings;
    });
  }
  componentDidMount() {
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
  }
  render() {
    const interactionBindings = this.getInteractionBindings(this.plugin.state.behaviors.cells);
    return (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [!this.props.selectOnly && this.plugin.canvas3d && (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Moving in 3D", children: (0, import_jsx_runtime7.jsx)(BindingsHelp, { bindings: this.plugin.canvas3d.props.trackball.bindings }) }, "trackball"), !!interactionBindings && (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Mouse & Key Controls", children: (0, import_jsx_runtime7.jsx)(BindingsHelp, { bindings: interactionBindings }) }, "interactions")] });
  }
};
var HelpContent = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
  }
  formatTriggers(binding) {
    return binding.triggers.map((t4) => Binding.Trigger.format(t4)).join(" or ");
  }
  getTriggerFor(transformer, name2) {
    const state = this.plugin.state.behaviors;
    const selections = state.select(StateSelection.Generators.ofTransformer(transformer));
    const params = selections.length === 1 ? selections[0].params : void 0;
    const bindings = params ? params.values.bindings : {};
    const binding = name2 in bindings ? bindings[name2] : Binding.Empty;
    return this.formatTriggers(binding);
  }
  render() {
    const selectToggleTriggers = this.getTriggerFor(SelectLoci, "clickSelectToggle");
    const focusTriggers = this.getTriggerFor(FocusLoci, "clickFocus");
    return (0, import_jsx_runtime7.jsxs)("div", { children: [(0, import_jsx_runtime7.jsx)(HelpSection, { header: "Interface Controls" }), (0, import_jsx_runtime7.jsxs)(HelpGroup, { header: "Inline Help", children: [(0, import_jsx_runtime7.jsx)(HelpText, { children: "Many user interface elements show a little questionmark icon when hovered over. Clicking the icon toggles the display of an inline help text." }), (0, import_jsx_runtime7.jsx)(HelpText, { children: "Tooltips may provide additional information on a user interface element and are shown when hovering over it with the mouse." })] }), (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Selections", children: (0, import_jsx_runtime7.jsxs)(HelpText, { children: ["The viewer allows changing colors and representations for selections of atoms, residues or chains. Selections can be created by", (0, import_jsx_runtime7.jsxs)("ul", { style: { paddingLeft: "20px" }, children: [(0, import_jsx_runtime7.jsxs)("li", { children: ["picking elements on the 3D canvas or the sequence view using the mouse, e.g. toggle selection using ", selectToggleTriggers, " (for more see help section on ", (0, import_jsx_runtime7.jsx)("i", { children: "Mouse Controls" }), ")"] }), (0, import_jsx_runtime7.jsxs)("li", { children: ["using the ", (0, import_jsx_runtime7.jsx)("i", { children: "Add" }), ", ", (0, import_jsx_runtime7.jsx)("i", { children: "Remove" }), " and ", (0, import_jsx_runtime7.jsx)("i", { children: "Only" }), " dropdown buttons in the ", (0, import_jsx_runtime7.jsx)("i", { children: "Manage Selection" }), " panel which allow modifing the current selection by predefined sets"] })] })] }) }), (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Coloring", children: (0, import_jsx_runtime7.jsxs)(HelpText, { children: ["There are two ways to color structures. Every representation (e.g. cartoon or spacefill) has a color theme which can be changed using the dropdown for each representation in the ", (0, import_jsx_runtime7.jsx)("i", { children: "Structure Settings" }), " panel. Additionally any selection atoms, residues or chains can by given a custom color. For that, first select the parts of the structure to be colored (see help section on ", (0, import_jsx_runtime7.jsx)("i", { children: "Selections" }), ") and, second, choose a color from the color dropdown botton in the ", (0, import_jsx_runtime7.jsx)("i", { children: "Selection" }), " row of the ", (0, import_jsx_runtime7.jsx)("i", { children: "Change Representation" }), " panel. The theme color can be seen as a base color that is overpainted by the custom color. Custom colors can be removed for a selection with the 'Clear' option in the color dropdown."] }) }), (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Representations", children: (0, import_jsx_runtime7.jsxs)(HelpText, { children: ["Structures can be shown with many different representations (e.g. cartoon or spacefill). The ", (0, import_jsx_runtime7.jsx)("i", { children: "Change Representation" }), " panel offers a collection of predefined styles which can be applied using the ", (0, import_jsx_runtime7.jsx)("i", { children: "Preset" }), " dropdown button. Additionally any selection atoms, residues or chains can by shown with a custom representation. For that, first select the parts of the structure to be mofified (see help section on ", (0, import_jsx_runtime7.jsx)("i", { children: "Selections" }), ") and, second, choose a representation to hide or show from the ", (0, import_jsx_runtime7.jsx)("i", { children: "Show" }), " and ", (0, import_jsx_runtime7.jsx)("i", { children: "Hide" }), " dropdown bottons in the ", (0, import_jsx_runtime7.jsx)("i", { children: "Selection" }), " row of the ", (0, import_jsx_runtime7.jsx)("i", { children: "Change Representation" }), " panel. The ", (0, import_jsx_runtime7.jsx)("i", { children: "Everything" }), " row applies the action to the whole structure instead of the current selection."] }) }), (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Surroundings", children: (0, import_jsx_runtime7.jsxs)(HelpText, { children: ["To show the surroundings of a residue or ligand, click it in the 3D scene or in the sequence widget using ", focusTriggers, "."] }) }), (0, import_jsx_runtime7.jsx)(HelpSection, { header: "How-to Guides" }), (0, import_jsx_runtime7.jsx)(HelpGroup, { header: "Create an Image", children: (0, import_jsx_runtime7.jsxs)(HelpText, { children: [(0, import_jsx_runtime7.jsxs)("p", { children: ["Use the ", (0, import_jsx_runtime7.jsx)(Icon, { svg: CameraSvg }), " icon in the viewport to bring up the screenshot controls."] }), (0, import_jsx_runtime7.jsxs)("p", { children: ["To adjust the size of the image, use the ", (0, import_jsx_runtime7.jsx)("i", { children: "Resolution" }), " dropdown."] })] }) }), (0, import_jsx_runtime7.jsx)(HelpSection, { header: "Mouse Controls" }), (0, import_jsx_runtime7.jsx)(ViewportHelpContent, {})] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/selection.js
var ToggleSelectionModeButton = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this._toggleSelMode = () => {
      this.plugin.selectionMode = !this.plugin.selectionMode;
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
    this.subscribe(this.plugin.layout.events.updated, () => this.forceUpdate());
    this.subscribe(this.plugin.behaviors.interaction.selectionMode, () => this.forceUpdate());
  }
  render() {
    const style = this.props.inline ? { background: "transparent", width: "auto", height: "auto", lineHeight: "unset" } : { background: "transparent" };
    return (0, import_jsx_runtime8.jsx)(IconButton, { svg: SelectionModeSvg, onClick: this._toggleSelMode, title: "Toggle Selection Mode", style, toggleState: this.plugin.selectionMode });
  }
};
var StructureSelectionParams = {
  granularity: InteractivityManager.Params.granularity
};
var ActionHeader = /* @__PURE__ */ new Map([
  ["add", "Add/Union Selection"],
  ["remove", "Remove/Subtract Selection"],
  ["intersect", "Intersect Selection"],
  ["set", "Set Selection"]
]);
var StructureSelectionActionsControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      action: void 0,
      helper: void 0,
      isEmpty: true,
      isBusy: false,
      canUndo: false,
      structureSelectionParams: StructureSelectionParams
    };
    this.set = (modifier, selectionQuery) => {
      this.plugin.managers.structure.selection.fromSelectionQuery(modifier, selectionQuery, false);
    };
    this.selectQuery = (item, e) => {
      if (!item || !this.state.action) {
        this.setState({ action: void 0 });
        return;
      }
      const q = this.state.action;
      if (e === null || e === void 0 ? void 0 : e.shiftKey) {
        this.set(q, item.value);
      } else {
        this.setState({ action: void 0 }, () => {
          this.set(q, item.value);
        });
      }
    };
    this.selectHelper = (item, e) => {
      console.log(item);
      if (!item || !this.state.action) {
        this.setState({ action: void 0, helper: void 0 });
        return;
      }
      this.setState({ helper: item.value.kind });
    };
    this.queriesItems = [];
    this.queriesVersion = -1;
    this.helpersItems = void 0;
    this.toggleAdd = this.showAction("add");
    this.toggleRemove = this.showAction("remove");
    this.toggleIntersect = this.showAction("intersect");
    this.toggleSet = this.showAction("set");
    this.toggleTheme = this.showAction("theme");
    this.toggleAddComponent = this.showAction("add-component");
    this.toggleHelp = this.showAction("help");
    this.setGranuality = ({ value }) => {
      this.plugin.managers.interactivity.setProps({ granularity: value });
    };
    this.turnOff = () => this.plugin.selectionMode = false;
    this.undo = () => {
      const task = this.plugin.state.data.undo();
      if (task)
        this.plugin.runTask(task);
    };
    this.subtract = () => {
      const sel = this.plugin.managers.structure.hierarchy.getStructuresWithSelection();
      const components = [];
      for (const s of sel)
        components.push(...s.components);
      if (components.length === 0)
        return;
      this.plugin.managers.structure.component.modifyByCurrentSelection(components, "subtract");
    };
  }
  componentDidMount() {
    var _a, _b;
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (c4) => {
      const isEmpty2 = c4.hierarchy.structures.length === 0;
      if (this.state.isEmpty !== isEmpty2) {
        this.setState({ isEmpty: isEmpty2 });
      }
      this.queriesVersion = -1;
      this.forceUpdate();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2, action: void 0 });
    });
    this.subscribe(this.plugin.managers.interactivity.events.propsUpdated, () => {
      this.forceUpdate();
    });
    this.subscribe(this.plugin.state.data.events.historyUpdated, ({ state }) => {
      this.setState({ canUndo: state.canUndo });
    });
    const granularityOptions = (_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.selectionTools) === null || _b === void 0 ? void 0 : _b.granularityOptions;
    if (granularityOptions) {
      const granularitySet = new Set(granularityOptions);
      const structureSelectionParams = {
        ...StructureSelectionParams,
        granularity: {
          ...StructureSelectionParams.granularity,
          options: StructureSelectionParams.granularity.options.filter(([firstItem]) => granularitySet.has(firstItem))
        }
      };
      this.setState({ structureSelectionParams });
    }
  }
  get isDisabled() {
    return this.state.isBusy || this.state.isEmpty;
  }
  get structures() {
    var _a;
    const structures = [];
    for (const s of this.plugin.managers.structure.hierarchy.selection.structures) {
      const structure = (_a = s.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
      if (structure)
        structures.push(structure);
    }
    return structures;
  }
  get queries() {
    const { registry } = this.plugin.query.structure;
    if (registry.version !== this.queriesVersion) {
      const structures = this.structures;
      const queries = [
        ...registry.list,
        ...getPolymerAndBranchedEntityQueries(structures),
        ...getNonStandardResidueQueries(structures),
        ...getElementQueries(structures)
      ].sort((a4, b4) => b4.priority - a4.priority);
      this.queriesItems = ActionMenu.createItems(queries, {
        filter: (q) => q !== StructureSelectionQueries.current && !q.isHidden,
        label: (q) => q.label,
        category: (q) => q.category,
        description: (q) => q.description
      });
      this.queriesVersion = registry.version;
    }
    return this.queriesItems;
  }
  get helpers() {
    if (this.helpersItems)
      return this.helpersItems;
    const helpers = [
      { kind: "residue-list", category: "Helpers", label: "Atom/Residue Identifier List", description: "Create a selection from a list of atom/residue ranges." }
    ];
    this.helpersItems = ActionMenu.createItems(helpers, {
      label: (q) => q.label,
      category: (q) => q.category,
      description: (q) => q.description
    });
    return this.helpersItems;
  }
  showAction(q) {
    return () => this.setState({ action: this.state.action === q ? void 0 : q, helper: void 0 });
  }
  render() {
    var _a, _b;
    const granularity = this.plugin.managers.interactivity.props.granularity;
    const hide = (_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.selectionTools) === null || _b === void 0 ? void 0 : _b.hide;
    const undoTitle = this.state.canUndo ? `Undo ${this.plugin.state.data.latestUndoLabel}` : "Some mistakes of the past can be undone.";
    let children = void 0;
    if (this.state.action && !this.state.helper) {
      children = (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [this.state.action && this.state.action !== "theme" && this.state.action !== "add-component" && this.state.action !== "help" && (0, import_jsx_runtime8.jsxs)("div", { className: "msp-selection-viewport-controls-actions", children: [(0, import_jsx_runtime8.jsx)(ActionMenu, { header: ActionHeader.get(this.state.action), title: "Click to close.", items: this.queries, onSelect: this.selectQuery, noOffset: true }), (0, import_jsx_runtime8.jsx)(ActionMenu, { items: this.helpers, onSelect: this.selectHelper, noOffset: true })] }), this.state.action === "theme" && (0, import_jsx_runtime8.jsx)("div", { className: "msp-selection-viewport-controls-actions", children: (0, import_jsx_runtime8.jsx)(ControlGroup, { header: "Theme", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleTheme, topRightIcon: CloseSvg, children: (0, import_jsx_runtime8.jsx)(ApplyThemeControls, { onApply: this.toggleTheme }) }) }), this.state.action === "add-component" && (0, import_jsx_runtime8.jsx)("div", { className: "msp-selection-viewport-controls-actions", children: (0, import_jsx_runtime8.jsx)(ControlGroup, { header: "Add Component", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleAddComponent, topRightIcon: CloseSvg, children: (0, import_jsx_runtime8.jsx)(AddComponentControls, { onApply: this.toggleAddComponent, forSelection: true }) }) }), this.state.action === "help" && (0, import_jsx_runtime8.jsx)("div", { className: "msp-selection-viewport-controls-actions", children: (0, import_jsx_runtime8.jsxs)(ControlGroup, { header: "Help", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleHelp, topRightIcon: CloseSvg, maxHeight: "300px", children: [(0, import_jsx_runtime8.jsx)(HelpGroup, { header: "Selection Operations", children: (0, import_jsx_runtime8.jsxs)(HelpText, { children: ["Use ", (0, import_jsx_runtime8.jsx)(Icon, { svg: UnionSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: SubtractSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: IntersectSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: SetSvg, inline: true }), " to modify the selection."] }) }), (0, import_jsx_runtime8.jsx)(HelpGroup, { header: "Representation Operations", children: (0, import_jsx_runtime8.jsxs)(HelpText, { children: ["Use ", (0, import_jsx_runtime8.jsx)(Icon, { svg: BrushSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: CubeOutlineSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: RemoveSvg, inline: true }), " ", (0, import_jsx_runtime8.jsx)(Icon, { svg: RestoreSvg, inline: true }), " to color, create components, remove from components, or undo actions."] }) }), (0, import_jsx_runtime8.jsx)(ViewportHelpContent, { selectOnly: true })] }) })] });
    } else if (ActionHeader.has(this.state.action) && this.state.helper === "residue-list") {
      const close = () => this.setState({ action: void 0, helper: void 0 });
      children = (0, import_jsx_runtime8.jsx)("div", { className: "msp-selection-viewport-controls-actions", children: (0, import_jsx_runtime8.jsx)(ControlGroup, { header: "Atom/Residue Identifier List", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: close, topRightIcon: CloseSvg, children: (0, import_jsx_runtime8.jsx)(ResidueListSelectionHelper, { modifier: this.state.action, plugin: this.plugin, close }) }) });
    }
    return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsxs)("div", { className: "msp-flex-row", style: { background: "none" }, children: [!(hide === null || hide === void 0 ? void 0 : hide.granularity) && (0, import_jsx_runtime8.jsx)(PureSelectControl, { title: `Picking Level for selecting and highlighting`, param: this.state.structureSelectionParams.granularity, name: "granularity", value: granularity, onChange: this.setGranuality, isDisabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.union) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: UnionSvg, title: `${ActionHeader.get("add")}. Hold shift key to keep menu open.`, toggle: this.toggleAdd, isSelected: this.state.action === "add", disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.subtract) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: SubtractSvg, title: `${ActionHeader.get("remove")}. Hold shift key to keep menu open.`, toggle: this.toggleRemove, isSelected: this.state.action === "remove", disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.intersect) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: IntersectSvg, title: `${ActionHeader.get("intersect")}. Hold shift key to keep menu open.`, toggle: this.toggleIntersect, isSelected: this.state.action === "intersect", disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.set) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: SetSvg, title: `${ActionHeader.get("set")}. Hold shift key to keep menu open.`, toggle: this.toggleSet, isSelected: this.state.action === "set", disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.theme) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: BrushSvg, title: "Apply Theme to Selection", toggle: this.toggleTheme, isSelected: this.state.action === "theme", disabled: this.isDisabled, style: { marginLeft: "10px" } }), !(hide === null || hide === void 0 ? void 0 : hide.componentAdd) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: CubeOutlineSvg, title: "Create Component of Selection with Representation", toggle: this.toggleAddComponent, isSelected: this.state.action === "add-component", disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.componentRemove) && (0, import_jsx_runtime8.jsx)(IconButton, { svg: RemoveSvg, title: "Remove/subtract Selection from all Components", onClick: this.subtract, disabled: this.isDisabled }), !(hide === null || hide === void 0 ? void 0 : hide.undo) && (0, import_jsx_runtime8.jsx)(IconButton, { svg: RestoreSvg, onClick: this.undo, disabled: !this.state.canUndo || this.isDisabled, title: undoTitle }), !(hide === null || hide === void 0 ? void 0 : hide.help) && (0, import_jsx_runtime8.jsx)(ToggleButton, { icon: HelpOutlineSvg, title: "Show/hide help", toggle: this.toggleHelp, style: { marginLeft: "10px" }, isSelected: this.state.action === "help" }), !(hide === null || hide === void 0 ? void 0 : hide.cancel) && this.plugin.config.get(PluginConfig.Viewport.ShowSelectionMode) && (0, import_jsx_runtime8.jsx)(IconButton, { svg: CancelOutlinedSvg, title: "Turn selection mode off", onClick: this.turnOff })] }), children] });
  }
};
var StructureSelectionStatsControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isEmpty: true,
      isBusy: false
    };
    this.clear = () => this.plugin.managers.interactivity.lociSelects.deselectAll();
    this.focus = () => {
      if (this.plugin.managers.structure.selection.stats.elementCount === 0)
        return;
      const { sphere } = this.plugin.managers.structure.selection.getBoundary();
      this.plugin.managers.camera.focusSphere(sphere);
    };
    this.highlight = (e) => {
      this.plugin.managers.interactivity.lociHighlights.clearHighlights();
      this.plugin.managers.structure.selection.entries.forEach((e2) => {
        this.plugin.managers.interactivity.lociHighlights.highlight({ loci: e2.selection }, false);
      });
    };
    this.clearHighlight = () => {
      this.plugin.managers.interactivity.lociHighlights.clearHighlights();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.selection.events.changed, () => {
      this.forceUpdate();
    });
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (c4) => {
      const isEmpty2 = c4.structures.length === 0;
      if (this.state.isEmpty !== isEmpty2) {
        this.setState({ isEmpty: isEmpty2 });
      }
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
  }
  get isDisabled() {
    return this.state.isBusy || this.state.isEmpty;
  }
  get stats() {
    const stats = this.plugin.managers.structure.selection.stats;
    if (stats.structureCount === 0 || stats.elementCount === 0) {
      return "Nothing Selected";
    } else {
      return `${stripTags(stats.label)} Selected`;
    }
  }
  render() {
    const stats = this.plugin.managers.structure.selection.stats;
    const empty3 = stats.structureCount === 0 || stats.elementCount === 0;
    if (empty3 && this.props.hideOnEmpty)
      return null;
    return (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: (0, import_jsx_runtime8.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime8.jsx)(Button, { noOverflow: true, onClick: this.focus, title: "Click to Focus Selection", disabled: empty3, onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, style: { textAlignLast: !empty3 ? "left" : void 0 }, children: this.stats }), !empty3 && (0, import_jsx_runtime8.jsx)(IconButton, { svg: CancelOutlinedSvg, onClick: this.clear, title: "Clear", className: "msp-form-control", flex: true })] }) });
  }
};
var ApplyThemeControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this._params = memoizeLatest((pivot) => StructureComponentManager.getThemeParams(this.plugin, pivot));
    this.state = { values: ParamDefinition.getDefaultValues(this.params) };
    this.apply = () => {
      var _a, _b;
      this.plugin.managers.structure.component.applyTheme(this.state.values, this.plugin.managers.structure.hierarchy.current.structures);
      (_b = (_a = this.props).onApply) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    this.paramsChanged = (values2) => this.setState({ values: values2 });
  }
  get params() {
    return this._params(this.plugin.managers.structure.component.pivotStructure);
  }
  render() {
    return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsx)(ParameterControls, { params: this.params, values: this.state.values, onChangeValues: this.paramsChanged }), (0, import_jsx_runtime8.jsx)(Button, { icon: BrushSvg, className: "msp-btn-commit msp-btn-commit-on", onClick: this.apply, style: { marginTop: "1px" }, children: "Apply Theme" })] });
  }
};
var ResidueListIdTypeParams = {
  idType: ParamDefinition.Select("auth", ParamDefinition.arrayToOptions(["auth", "label", "atom-id", "element-symbol"])),
  identifiers: ParamDefinition.Text("", { description: "A comma separated list of atom identifiers (e.g. 10, 15-25), element symbols (e.g. N, C or 20-200) or residue ranges in given chain (e.g. A 10-15, B 25, C 30:i)" })
};
var DefaultResidueListIdTypeParams = ParamDefinition.getDefaultValues(ResidueListIdTypeParams);
function ResidueListSelectionHelper({ modifier, plugin, close }) {
  const [state, setState] = React2.useState(DefaultResidueListIdTypeParams);
  const apply = () => {
    if (state.identifiers.trim().length === 0)
      return;
    try {
      close();
      const query = compileIdListSelection(state.identifiers, state.idType);
      plugin.managers.structure.selection.fromCompiledQuery(modifier, query, false);
    } catch (e) {
      console.error(e);
      plugin.log.error("Failed to create selection");
    }
  };
  return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsx)(ParameterControls, { params: ResidueListIdTypeParams, values: state, onChangeValues: setState, onEnter: apply }), (0, import_jsx_runtime8.jsxs)(Button, { className: "msp-btn-commit msp-btn-commit-on", disabled: state.identifiers.trim().length === 0, onClick: apply, style: { marginTop: "1px" }, children: [capitalize(modifier), " Selection"] })] });
}

// node_modules/molstar/lib/mol-plugin-ui/structure/measurements.js
var StructureMeasurementsControls = class extends CollapsableControls {
  defaultState() {
    return {
      isCollapsed: false,
      header: "Measurements",
      brand: { accent: "gray", svg: PencilRulerSvg }
    };
  }
  renderControls() {
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsx)(MeasurementControls, {}), (0, import_jsx_runtime9.jsx)(MeasurementList, {})] });
  }
};
var MeasurementList = class extends PurePluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.measurement.behaviors.state, () => {
      this.forceUpdate();
    });
  }
  renderGroup(cells, header) {
    const group = [];
    for (const cell of cells) {
      if (cell.obj)
        group.push((0, import_jsx_runtime9.jsx)(MeasurementEntry, { cell }, cell.obj.id));
    }
    return group.length ? (0, import_jsx_runtime9.jsx)(ExpandGroup, { header, initiallyExpanded: true, children: group }) : null;
  }
  render() {
    const measurements = this.plugin.managers.structure.measurement.state;
    return (0, import_jsx_runtime9.jsxs)("div", { style: { marginTop: "6px" }, children: [this.renderGroup(measurements.labels, "Labels"), this.renderGroup(measurements.distances, "Distances"), this.renderGroup(measurements.angles, "Angles"), this.renderGroup(measurements.dihedrals, "Dihedrals"), this.renderGroup(measurements.orientations, "Orientations"), this.renderGroup(measurements.planes, "Planes")] });
  }
};
var MeasurementControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { isBusy: false, action: void 0 };
    this.measureDistance = () => {
      const loci = this.plugin.managers.structure.selection.additionsHistory;
      this.plugin.managers.structure.measurement.addDistance(loci[0].loci, loci[1].loci);
    };
    this.measureAngle = () => {
      const loci = this.plugin.managers.structure.selection.additionsHistory;
      this.plugin.managers.structure.measurement.addAngle(loci[0].loci, loci[1].loci, loci[2].loci);
    };
    this.measureDihedral = () => {
      const loci = this.plugin.managers.structure.selection.additionsHistory;
      this.plugin.managers.structure.measurement.addDihedral(loci[0].loci, loci[1].loci, loci[2].loci, loci[3].loci);
    };
    this.addLabel = () => {
      const loci = this.plugin.managers.structure.selection.additionsHistory;
      this.plugin.managers.structure.measurement.addLabel(loci[0].loci);
    };
    this.addOrientation = () => {
      const locis = [];
      this.plugin.managers.structure.selection.entries.forEach((v2) => {
        locis.push(v2.selection);
      });
      this.plugin.managers.structure.measurement.addOrientation(locis);
    };
    this.addPlane = () => {
      const locis = [];
      this.plugin.managers.structure.selection.entries.forEach((v2) => {
        locis.push(v2.selection);
      });
      this.plugin.managers.structure.measurement.addPlane(locis);
    };
    this.selectAction = (item) => {
      this.toggleAdd();
      if (!item)
        return;
      (item === null || item === void 0 ? void 0 : item.value)();
    };
    this.toggleAdd = () => this.setState({ action: this.state.action === "add" ? void 0 : "add" });
    this.toggleOptions = () => this.setState({ action: this.state.action === "options" ? void 0 : "options" });
  }
  componentDidMount() {
    this.subscribe(this.selection.events.additionsHistoryUpdated, () => {
      this.forceUpdate();
      this.updateOrderLabels();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
  }
  componentWillUnmount() {
    this.clearOrderLabels();
    super.componentWillUnmount();
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.state.action !== prevState.action)
      this.updateOrderLabels();
  }
  clearOrderLabels() {
    this.plugin.managers.structure.measurement.addOrderLabels([]);
  }
  updateOrderLabels() {
    if (this.state.action !== "add") {
      this.clearOrderLabels();
      return;
    }
    const locis = [];
    const history = this.selection.additionsHistory;
    for (let idx = 0; idx < history.length && idx < 4; idx++)
      locis.push(history[idx].loci);
    this.plugin.managers.structure.measurement.addOrderLabels(locis);
  }
  get selection() {
    return this.plugin.managers.structure.selection;
  }
  get actions() {
    const history = this.selection.additionsHistory;
    const ret = [
      { kind: "item", label: `Label ${history.length === 0 ? " (1 selection item required)" : " (1st selection item)"}`, value: this.addLabel, disabled: history.length === 0 },
      { kind: "item", label: `Distance ${history.length < 2 ? " (2 selection items required)" : " (top 2 selection items)"}`, value: this.measureDistance, disabled: history.length < 2 },
      { kind: "item", label: `Angle ${history.length < 3 ? " (3 selection items required)" : " (top 3 items)"}`, value: this.measureAngle, disabled: history.length < 3 },
      { kind: "item", label: `Dihedral ${history.length < 4 ? " (4 selection items required)" : " (top 4 selection items)"}`, value: this.measureDihedral, disabled: history.length < 4 },
      { kind: "item", label: `Orientation ${history.length === 0 ? " (selection required)" : " (current selection)"}`, value: this.addOrientation, disabled: history.length === 0 },
      { kind: "item", label: `Plane ${history.length === 0 ? " (selection required)" : " (current selection)"}`, value: this.addPlane, disabled: history.length === 0 }
    ];
    return ret;
  }
  highlight(loci) {
    this.plugin.managers.interactivity.lociHighlights.highlightOnly({ loci }, false);
  }
  moveHistory(e, direction) {
    this.plugin.managers.structure.selection.modifyHistory(e, direction, 4);
  }
  focusLoci(loci) {
    this.plugin.managers.camera.focusLoci(loci);
  }
  historyEntry(e, idx) {
    const history = this.plugin.managers.structure.selection.additionsHistory;
    return (0, import_jsx_runtime9.jsxs)("div", { className: "msp-flex-row", onMouseEnter: () => this.highlight(e.loci), onMouseLeave: () => this.plugin.managers.interactivity.lociHighlights.clearHighlights(), children: [(0, import_jsx_runtime9.jsxs)(Button, { noOverflow: true, title: "Click to focus. Hover to highlight.", onClick: () => this.focusLoci(e.loci), style: { width: "auto", textAlign: "left" }, children: [idx, ". ", (0, import_jsx_runtime9.jsx)("span", { dangerouslySetInnerHTML: { __html: e.label } })] }), history.length > 1 && (0, import_jsx_runtime9.jsx)(IconButton, { svg: ArrowUpwardSvg, small: true, className: "msp-form-control", onClick: () => this.moveHistory(e, "up"), flex: "20px", title: "Move up" }), history.length > 1 && (0, import_jsx_runtime9.jsx)(IconButton, { svg: ArrowDownwardSvg, small: true, className: "msp-form-control", onClick: () => this.moveHistory(e, "down"), flex: "20px", title: "Move down" }), (0, import_jsx_runtime9.jsx)(IconButton, { svg: DeleteOutlinedSvg, small: true, className: "msp-form-control", onClick: () => this.plugin.managers.structure.selection.modifyHistory(e, "remove"), flex: true, title: "Remove" })] }, e.id);
  }
  add() {
    const history = this.plugin.managers.structure.selection.additionsHistory;
    const entries = [];
    for (let i = 0, _i = Math.min(history.length, 4); i < _i; i++) {
      entries.push(this.historyEntry(history[i], i + 1));
    }
    const shouldShowToggleHint = this.plugin.config.get(PluginConfig.Viewport.ShowSelectionMode);
    const toggleHint = shouldShowToggleHint ? (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [" ", "(toggle ", (0, import_jsx_runtime9.jsx)(ToggleSelectionModeButton, { inline: true }), " mode)"] }) : null;
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsx)(ActionMenu, { items: this.actions, onSelect: this.selectAction }), entries.length > 0 && (0, import_jsx_runtime9.jsx)("div", { className: "msp-control-offset", children: entries }), entries.length === 0 && (0, import_jsx_runtime9.jsx)("div", { className: "msp-control-offset msp-help-text", children: (0, import_jsx_runtime9.jsxs)("div", { className: "msp-help-description", children: [(0, import_jsx_runtime9.jsx)(Icon, { svg: HelpOutlineSvg, inline: true }), "Add one or more selections", toggleHint] }) })] });
  }
  render() {
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime9.jsx)(ToggleButton, { icon: AddSvg, label: "Add", toggle: this.toggleAdd, isSelected: this.state.action === "add", disabled: this.state.isBusy, className: "msp-btn-apply-simple" }), (0, import_jsx_runtime9.jsx)(ToggleButton, { icon: TuneSvg, label: "", title: "Options", toggle: this.toggleOptions, isSelected: this.state.action === "options", disabled: this.state.isBusy, style: { flex: "0 0 40px", padding: 0 } })] }), this.state.action === "add" && this.add(), this.state.action === "options" && (0, import_jsx_runtime9.jsx)(MeasurementsOptions, {})] });
  }
};
var MeasurementsOptions = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { isDisabled: false };
    this.changed = (options) => {
      this.plugin.managers.structure.measurement.setOptions(options);
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.measurement.behaviors.state, () => {
      this.forceUpdate();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isDisabled: v2 });
    });
  }
  render() {
    const measurements = this.plugin.managers.structure.measurement.state;
    return (0, import_jsx_runtime9.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime9.jsx)(ParameterControls, { params: StructureMeasurementParams, values: measurements.options, onChangeValues: this.changed, isDisabled: this.state.isDisabled }) });
  }
};
var MeasurementEntry = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { showUpdate: false };
    this.delete = () => {
      PluginCommands.State.RemoveObject(this.plugin, { state: this.props.cell.parent, ref: this.props.cell.transform.parent, removeParentGhosts: true });
    };
    this.toggleVisibility = (e) => {
      e.preventDefault();
      PluginCommands.State.ToggleVisibility(this.plugin, { state: this.props.cell.parent, ref: this.props.cell.transform.parent });
      e.currentTarget.blur();
    };
    this.highlight = () => {
      var _a;
      const selections = this.selections;
      if (!selections)
        return;
      this.plugin.managers.interactivity.lociHighlights.clearHighlights();
      for (const loci of this.lociArray) {
        this.plugin.managers.interactivity.lociHighlights.highlight({ loci }, false);
      }
      const reprLocis = (_a = this.props.cell.obj) === null || _a === void 0 ? void 0 : _a.data.repr.getAllLoci();
      if (reprLocis) {
        for (const loci of reprLocis) {
          this.plugin.managers.interactivity.lociHighlights.highlight({ loci }, false);
        }
      }
    };
    this.clearHighlight = () => {
      this.plugin.managers.interactivity.lociHighlights.clearHighlights();
    };
    this.toggleUpdate = () => this.setState({ showUpdate: !this.state.showUpdate });
    this.focus = () => {
      const selections = this.selections;
      if (!selections)
        return;
      const sphere = Loci.getBundleBoundingSphere({ loci: this.lociArray });
      if (sphere) {
        this.plugin.managers.camera.focusSphere(sphere);
      }
    };
    this.selectAction = (item) => {
      if (!item)
        return;
      this.setState({ showUpdate: false });
      (item === null || item === void 0 ? void 0 : item.value)();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      this.forceUpdate();
    });
  }
  get selections() {
    var _a;
    return (_a = this.props.cell.obj) === null || _a === void 0 ? void 0 : _a.data.sourceData;
  }
  get lociArray() {
    const selections = this.selections;
    if (!selections)
      return [];
    if (selections.infos)
      return [selections.infos[0].loci];
    if (selections.pairs)
      return selections.pairs[0].loci;
    if (selections.triples)
      return selections.triples[0].loci;
    if (selections.quads)
      return selections.quads[0].loci;
    if (selections.locis)
      return selections.locis;
    return [];
  }
  get label() {
    const selections = this.selections;
    if (!selections)
      return "<empty>";
    if (selections.infos)
      return lociLabel(selections.infos[0].loci, { condensed: true });
    if (selections.pairs)
      return distanceLabel(selections.pairs[0], { condensed: true, unitLabel: this.plugin.managers.structure.measurement.state.options.distanceUnitLabel });
    if (selections.triples)
      return angleLabel(selections.triples[0], { condensed: true });
    if (selections.quads)
      return dihedralLabel(selections.quads[0], { condensed: true });
    if (selections.locis)
      return structureElementLociLabelMany(selections.locis, { countsOnly: true });
    return "<empty>";
  }
  get actions() {
    this.props.cell.sourceRef;
    return [ActionMenu.Item("Select This", () => this.plugin.managers.structure.selection.fromSelections(this.props.cell.sourceRef), { icon: SetSvg })];
  }
  render() {
    const { cell } = this.props;
    const { obj } = cell;
    if (!obj)
      return null;
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsxs)("div", { className: "msp-flex-row", onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, children: [(0, import_jsx_runtime9.jsx)("button", { className: "msp-form-control msp-control-button-label msp-no-overflow", title: "Click to focus. Hover to highlight.", onClick: this.focus, style: { width: "auto", textAlign: "left" }, children: (0, import_jsx_runtime9.jsx)("span", { dangerouslySetInnerHTML: { __html: this.label } }) }), (0, import_jsx_runtime9.jsx)(IconButton, { svg: cell.state.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, small: true, className: "msp-form-control", onClick: this.toggleVisibility, flex: true, title: cell.state.isHidden ? "Show" : "Hide" }), (0, import_jsx_runtime9.jsx)(IconButton, { svg: DeleteOutlinedSvg, small: true, className: "msp-form-control", onClick: this.delete, flex: true, title: "Delete", toggleState: false }), (0, import_jsx_runtime9.jsx)(IconButton, { svg: MoreHorizSvg, className: "msp-form-control", onClick: this.toggleUpdate, flex: true, title: "Actions", toggleState: this.state.showUpdate })] }, obj.id), this.state.showUpdate && cell.parent && (0, import_jsx_runtime9.jsx)(import_jsx_runtime9.Fragment, { children: (0, import_jsx_runtime9.jsxs)("div", { className: "msp-accent-offset", children: [(0, import_jsx_runtime9.jsx)(ActionMenu, { items: this.actions, onSelect: this.selectAction, noOffset: true }), (0, import_jsx_runtime9.jsx)(ExpandGroup, { header: "Options", noOffset: true, children: (0, import_jsx_runtime9.jsx)(UpdateTransformControl, { state: cell.parent, transform: cell.transform, customHeader: "none", autoHideApply: true }) })] }) })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/source.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-ui/structure/focus.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function addSymmetryGroupEntries(entries, location, unitSymmetryGroup, granularity) {
  const idx = SortedArray.indexOf(location.unit.elements, location.element);
  const base = element_exports.Loci(location.structure, [
    { unit: location.unit, indices: OrderedSet.ofSingleton(idx) }
  ]);
  const extended = granularity === "residue" ? element_exports.Loci.extendToWholeResidues(base) : element_exports.Loci.extendToWholeChains(base);
  const name2 = StructureProperties.entity.pdbx_description(location).join(", ");
  for (const u2 of unitSymmetryGroup.units) {
    const loci = element_exports.Loci(extended.structure, [
      { unit: u2, indices: extended.elements[0].indices }
    ]);
    let label = lociLabel(loci, { reverse: true, hidePrefix: true, htmlStyling: false, granularity });
    if (!label)
      label = lociLabel(loci, { hidePrefix: false, htmlStyling: false });
    if (unitSymmetryGroup.units.length > 1) {
      label += ` | ${loci.elements[0].unit.conformation.operator.name}`;
    }
    const item = { label, category: name2, loci };
    if (entries.has(name2))
      entries.get(name2).push(item);
    else
      entries.set(name2, [item]);
  }
}
function getFocusEntries(structure) {
  const entityEntries = /* @__PURE__ */ new Map();
  const l = element_exports.Location.create(structure);
  for (const ug of structure.unitSymmetryGroups) {
    if (!Unit.isAtomic(ug.units[0]))
      continue;
    l.unit = ug.units[0];
    l.element = ug.elements[0];
    const isMultiChain = Unit.Traits.is(l.unit.traits, Unit.Trait.MultiChain);
    const entityType = StructureProperties.entity.type(l);
    const isNonPolymer = entityType === "non-polymer";
    const isBranched = entityType === "branched";
    const isBirdMolecule = !!StructureProperties.entity.prd_id(l);
    if (isBirdMolecule) {
      addSymmetryGroupEntries(entityEntries, l, ug, "chain");
    } else if (isNonPolymer && !isMultiChain) {
      addSymmetryGroupEntries(entityEntries, l, ug, "residue");
    } else if (isBranched || isNonPolymer && isMultiChain) {
      const u2 = l.unit;
      const { index: residueIndex } = u2.model.atomicHierarchy.residueAtomSegments;
      let prev = -1;
      for (let i = 0, il = u2.elements.length; i < il; ++i) {
        const eI = u2.elements[i];
        const rI = residueIndex[eI];
        if (rI !== prev) {
          l.element = eI;
          addSymmetryGroupEntries(entityEntries, l, ug, "residue");
          prev = rI;
        }
      }
    }
  }
  const entries = [];
  entityEntries.forEach((e, name2) => {
    if (e.length === 1) {
      entries.push({ label: `${name2}: ${e[0].label}`, loci: e[0].loci });
    } else if (e.length < 2e3) {
      entries.push(...e);
    }
  });
  return entries;
}
var StructureFocusControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { isBusy: false, showAction: false };
    this.getSelectionItems = memoizeLatest((structures) => {
      var _a;
      const presetItems = [];
      for (const s of structures) {
        const d3 = (_a = s.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
        if (d3) {
          const entries = getFocusEntries(d3);
          if (entries.length > 0) {
            presetItems.push([
              ActionMenu.Header(d3.label, { description: d3.label }),
              ...ActionMenu.createItems(entries, {
                label: (f) => f.label,
                category: (f) => f.category,
                description: (f) => f.label
              })
            ]);
          }
        }
      }
      return presetItems;
    });
    this.selectAction = (item, e) => {
      if (!item || !this.state.showAction) {
        this.setState({ showAction: false });
        return;
      }
      const f = item.value;
      if (e === null || e === void 0 ? void 0 : e.shiftKey) {
        this.plugin.managers.structure.focus.addFromLoci(f.loci);
      } else {
        this.plugin.managers.structure.focus.set(f);
      }
      this.focusCamera();
    };
    this.toggleAction = () => this.setState({ showAction: !this.state.showAction });
    this.focusCamera = () => {
      const { current } = this.plugin.managers.structure.focus;
      if (current)
        this.plugin.managers.camera.focusLoci(current.loci);
    };
    this.clear = () => {
      this.plugin.managers.structure.focus.clear();
      this.plugin.managers.camera.reset();
    };
    this.highlightCurrent = () => {
      const { current } = this.plugin.managers.structure.focus;
      if (current)
        this.plugin.managers.interactivity.lociHighlights.highlightOnly({ loci: current.loci }, false);
    };
    this.clearHighlights = () => {
      this.plugin.managers.interactivity.lociHighlights.clearHighlights();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.focus.behaviors.current, (c4) => {
      this.getSelectionItems([]);
      this.forceUpdate();
    });
    this.subscribe(this.plugin.managers.structure.focus.events.historyUpdated, (c4) => {
      this.forceUpdate();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2, showAction: false });
    });
  }
  get isDisabled() {
    return this.state.isBusy || this.plugin.managers.structure.hierarchy.selection.structures.length === 0;
  }
  get actionItems() {
    const historyItems = [];
    const { history } = this.plugin.managers.structure.focus;
    if (history.length > 0) {
      historyItems.push([
        ActionMenu.Header("History", { description: "Previously focused on items." }),
        ...ActionMenu.createItems(history, {
          label: (f) => f.label,
          description: (f) => {
            return f.category && f.label !== f.category ? `${f.category} | ${f.label}` : f.label;
          }
        })
      ]);
    }
    const presetItems = this.getSelectionItems(this.plugin.managers.structure.hierarchy.selection.structures);
    if (presetItems.length === 1) {
      const item = presetItems[0];
      const header = item[0];
      header.initiallyExpanded = true;
    }
    const items = [];
    if (presetItems.length > 0)
      items.push(...presetItems);
    if (historyItems.length > 0)
      items.push(...historyItems);
    return items;
  }
  getToggleBindingLabel() {
    var _a;
    const t4 = this.plugin.state.behaviors.transforms.get(FocusLoci.id);
    if (!t4)
      return "";
    const binding = (_a = t4.params) === null || _a === void 0 ? void 0 : _a.bindings.clickFocus;
    if (!binding || Binding.isEmpty(binding))
      return "";
    return Binding.formatTriggers(binding);
  }
  render() {
    const { current } = this.plugin.managers.structure.focus;
    const label = (current === null || current === void 0 ? void 0 : current.label) || "Nothing Focused";
    let title = "Click to Center Camera";
    if (!current) {
      title = "Select focus using the menu";
      const binding = this.getToggleBindingLabel();
      if (binding) {
        title += `
or use '${binding}' on element`;
      }
    }
    return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [(0, import_jsx_runtime10.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime10.jsx)(Button, { noOverflow: true, onClick: this.focusCamera, title, onMouseEnter: this.highlightCurrent, onMouseLeave: this.clearHighlights, disabled: this.isDisabled || !current, style: { textAlignLast: current ? "left" : void 0 }, children: label }), current && (0, import_jsx_runtime10.jsx)(IconButton, { svg: CancelOutlinedSvg, onClick: this.clear, title: "Clear", className: "msp-form-control", flex: true, disabled: this.isDisabled }), (0, import_jsx_runtime10.jsx)(ToggleButton, { icon: CenterFocusStrongSvg, title: "Select a focus target to center on an show its surroundings. Hold shift to focus on multiple targets.", toggle: this.toggleAction, isSelected: this.state.showAction, disabled: this.isDisabled, style: { flex: "0 0 40px", padding: 0 } })] }), this.state.showAction && (0, import_jsx_runtime10.jsx)(ActionMenu, { items: this.actionItems, onSelect: this.selectAction })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/source.js
var StructureSourceControls = class extends CollapsableControls {
  constructor() {
    super(...arguments);
    this.item = (ref) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const selected = this.plugin.managers.structure.hierarchy.seletionSet;
      let label;
      switch (ref.kind) {
        case "model": {
          const model = (_a = ref.cell.obj) === null || _a === void 0 ? void 0 : _a.data;
          if (model && Model.TrajectoryInfo.get(model).size > 1) {
            label = `${(_b = ref.cell.obj) === null || _b === void 0 ? void 0 : _b.data.entryId} | Model ${Model.TrajectoryInfo.get(model).index + 1} of ${Model.TrajectoryInfo.get(model).size}`;
          }
          label = `${(_c = ref.cell.obj) === null || _c === void 0 ? void 0 : _c.data.entryId} | ${(_d = ref.cell.obj) === null || _d === void 0 ? void 0 : _d.label}`;
          break;
        }
        case "structure": {
          const model = (_e = ref.cell.obj) === null || _e === void 0 ? void 0 : _e.data.models[0];
          if (model && Model.TrajectoryInfo.get(model).size > 1) {
            label = `${model.entryId} | ${(_f = ref.cell.obj) === null || _f === void 0 ? void 0 : _f.label} (Model ${Model.TrajectoryInfo.get(model).index + 1} of ${Model.TrajectoryInfo.get(model).size})`;
            break;
          } else if (model) {
            label = `${model.entryId} | ${(_g = ref.cell.obj) === null || _g === void 0 ? void 0 : _g.label}`;
            break;
          } else {
            label = `${(_h = ref.cell.obj) === null || _h === void 0 ? void 0 : _h.label}`;
            break;
          }
        }
        default:
          label = (_j = ref.cell.obj) === null || _j === void 0 ? void 0 : _j.label;
          break;
      }
      const item = { kind: "item", label: label || ref.kind, selected: selected.has(ref.cell.transform.ref), value: [ref] };
      return item;
    };
    this.getTrajectoryItems = (t4) => {
      var _a;
      if (t4.models.length === 0)
        return this.item(t4);
      return [ActionMenu.Header((_a = t4.cell.obj) === null || _a === void 0 ? void 0 : _a.label), ...t4.models.map(this.getModelItems)];
    };
    this.getModelItems = (m) => {
      var _a, _b, _c;
      if (m.structures.length === 0)
        return this.item(m);
      if (m.structures.length === 1) {
        const selected = this.plugin.managers.structure.hierarchy.seletionSet;
        const ref = m.structures[0];
        return { label: `${(_a = m.cell.obj) === null || _a === void 0 ? void 0 : _a.label} | ${(_b = ref.cell.obj) === null || _b === void 0 ? void 0 : _b.label}`, selected: selected.has(ref.cell.transform.ref), value: [m, ref] };
      }
      return [ActionMenu.Header((_c = m.cell.obj) === null || _c === void 0 ? void 0 : _c.label), ...m.structures.map(this.item)];
    };
    this.selectHierarchy = (items) => {
      if (!items || items.length === 0)
        return;
      const refs = [];
      for (const i of items) {
        for (const r of i.value)
          refs.push(r);
      }
      this.plugin.managers.structure.hierarchy.updateCurrent(refs, items[0].selected ? "remove" : "add");
    };
    this.toggleHierarchy = () => this.setState({ show: this.state.show !== "hierarchy" ? "hierarchy" : void 0 });
    this.togglePreset = () => this.setState({ show: this.state.show !== "presets" ? "presets" : void 0 });
    this.applyPreset = (item) => {
      this.setState({ show: void 0 });
      if (!item)
        return;
      const mng = this.plugin.managers.structure;
      const { trajectories } = mng.hierarchy.selection;
      mng.hierarchy.applyPreset(trajectories, item.value);
    };
    this.updateModelQueueParams = void 0;
    this.isUpdatingModel = false;
    this.updateStructureModel = (params) => {
      this.updateModelQueueParams = params;
      this._updateStructureModel();
    };
    this.updateStructure = (params) => {
      const { selection } = this.plugin.managers.structure.hierarchy;
      const s = selection.structures[0];
      return this.plugin.managers.structure.hierarchy.updateStructure(s, params);
    };
  }
  defaultState() {
    return {
      header: "Structure",
      isCollapsed: false,
      isBusy: false,
      brand: { accent: "purple", svg: MoleculeSvg }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, () => this.forceUpdate());
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
  }
  get hierarchyItems() {
    const mng = this.plugin.managers.structure.hierarchy;
    const { current } = mng;
    const ret = [];
    if (current.trajectories.length > 1) {
      ret.push([
        ActionMenu.Header("Trajectories"),
        ...current.trajectories.map(this.item)
      ]);
    }
    if (current.models.length > 1 || current.trajectories.length > 1) {
      ret.push([
        ActionMenu.Header("Models"),
        ...current.models.map(this.item)
      ]);
    }
    if (current.trajectories.length === 1 && current.models.length === 1) {
      ret.push(...current.structures.map(this.item));
    } else if (current.structures.length > 0) {
      ret.push([
        ActionMenu.Header("Structures"),
        ...current.structures.map(this.item)
      ]);
    }
    return ret;
  }
  get isEmpty() {
    const { structures, models, trajectories } = this.plugin.managers.structure.hierarchy.current;
    return trajectories.length === 0 && models.length === 0 && structures.length === 0;
  }
  get label() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const { structures, models, trajectories } = this.plugin.managers.structure.hierarchy.selection;
    if (structures.length === 1) {
      const s = structures[0];
      if (((_b = (_a = s.model) === null || _a === void 0 ? void 0 : _a.trajectory) === null || _b === void 0 ? void 0 : _b.models) && s.model.trajectory.models.length === 1)
        return (_c = s.cell.obj) === null || _c === void 0 ? void 0 : _c.data.label;
      if (s.model)
        return `${(_d = s.model.cell.obj) === null || _d === void 0 ? void 0 : _d.label} | ${(_e = s.cell.obj) === null || _e === void 0 ? void 0 : _e.data.label}`;
      return (_f = s.cell.obj) === null || _f === void 0 ? void 0 : _f.data.label;
    }
    if (structures.length > 1) {
      const p = structures[0];
      const t4 = (_g = p === null || p === void 0 ? void 0 : p.model) === null || _g === void 0 ? void 0 : _g.trajectory;
      let sameTraj = true;
      for (const s of structures) {
        if (((_h = s === null || s === void 0 ? void 0 : s.model) === null || _h === void 0 ? void 0 : _h.trajectory) !== t4) {
          sameTraj = false;
          break;
        }
      }
      return sameTraj && t4 ? `${(_j = t4.cell.obj) === null || _j === void 0 ? void 0 : _j.label} | ${structures.length} structures` : `${structures.length} structures`;
    }
    if (models.length > 0) {
      const t4 = models[0].trajectory;
      if (models.length === 1) {
        const model = (_k = models[0].cell.obj) === null || _k === void 0 ? void 0 : _k.data;
        if (model && Model.TrajectoryInfo.get(model).size > 1) {
          return `${(_l = t4 === null || t4 === void 0 ? void 0 : t4.cell.obj) === null || _l === void 0 ? void 0 : _l.label} | Model ${Model.TrajectoryInfo.get(model).index + 1} of ${Model.TrajectoryInfo.get(model).size}`;
        } else {
          return `${(_m = t4 === null || t4 === void 0 ? void 0 : t4.cell.obj) === null || _m === void 0 ? void 0 : _m.label} | Model`;
        }
      }
      let sameTraj = true;
      for (const m of models) {
        if (m.trajectory !== t4) {
          sameTraj = false;
          break;
        }
      }
      return sameTraj ? `${(_o = t4 === null || t4 === void 0 ? void 0 : t4.cell.obj) === null || _o === void 0 ? void 0 : _o.label} | ${models.length} models` : `${models.length} models`;
    }
    if (trajectories.length > 0) {
      return trajectories.length === 1 ? `${(_p = trajectories[0].cell.obj) === null || _p === void 0 ? void 0 : _p.label} trajectory` : `${trajectories.length} trajectories`;
    }
    if (trajectories.length === 0 && models.length === 0 && structures.length === 0) {
      return "Nothing Loaded";
    }
    return "Nothing Selected";
  }
  get presetActions() {
    const actions = [];
    const { trajectories } = this.plugin.managers.structure.hierarchy.selection;
    if (trajectories.length === 0)
      return actions;
    let providers = this.plugin.builders.structure.hierarchy.getPresets(trajectories[0].cell.obj);
    if (trajectories.length > 1) {
      const providerSet = new Set(providers);
      for (let i = 1; i < trajectories.length; i++) {
        const providers2 = this.plugin.builders.structure.hierarchy.getPresets(trajectories[i].cell.obj);
        const current = new Set(providers2);
        for (const p of providers2) {
          if (!current.has(p))
            providerSet.delete(p);
        }
      }
      providers = providers.filter((p) => providerSet.has(p));
    }
    for (const p of providers) {
      actions.push(ActionMenu.Item(p.display.name, p, { description: p.display.description }));
    }
    return actions;
  }
  async _updateStructureModel() {
    if (!this.updateModelQueueParams || this.isUpdatingModel)
      return;
    const params = this.updateModelQueueParams;
    this.updateModelQueueParams = void 0;
    try {
      this.isUpdatingModel = true;
      const { selection } = this.plugin.managers.structure.hierarchy;
      const m = selection.structures[0].model;
      await this.plugin.state.updateTransform(this.plugin.state.data, m.cell.transform.ref, params, "Model Index");
    } finally {
      this.isUpdatingModel = false;
      this._updateStructureModel();
    }
  }
  get modelIndex() {
    var _a, _b;
    const { selection } = this.plugin.managers.structure.hierarchy;
    if (selection.structures.length !== 1)
      return null;
    const m = selection.structures[0].model;
    if (!m || m.cell.transform.transformer !== StateTransforms.Model.ModelFromTrajectory)
      return null;
    if (!m.cell.obj || Model.TrajectoryInfo.get(m.cell.obj.data).size <= 1)
      return null;
    const params = (_a = m.cell.params) === null || _a === void 0 ? void 0 : _a.definition;
    if (!params)
      return null;
    return (0, import_jsx_runtime11.jsx)(ParameterControls, { params, values: (_b = m.cell.params) === null || _b === void 0 ? void 0 : _b.values, onChangeValues: this.updateStructureModel, isDisabled: this.state.isBusy });
  }
  get structureType() {
    var _a;
    const { selection } = this.plugin.managers.structure.hierarchy;
    if (selection.structures.length !== 1)
      return null;
    const s = selection.structures[0];
    const params = (_a = s.cell.params) === null || _a === void 0 ? void 0 : _a.definition;
    if (!params || !s.cell.parent)
      return null;
    return (0, import_jsx_runtime11.jsx)(UpdateTransformControl, { state: s.cell.parent, transform: s.cell.transform, customHeader: "none", customUpdate: this.updateStructure, noMargin: true, autoHideApply: true });
  }
  get transform() {
    const { selection } = this.plugin.managers.structure.hierarchy;
    if (selection.structures.length !== 1)
      return null;
    const pivot = selection.structures[0];
    if (!pivot.cell.parent)
      return null;
    const t4 = StateSelection.tryFindDecorator(this.plugin.state.data, pivot.cell.transform.ref, StateTransforms.Model.TransformStructureConformation);
    if (!t4)
      return;
    return (0, import_jsx_runtime11.jsx)(ExpandGroup, { header: `Conformation Transform`, children: (0, import_jsx_runtime11.jsx)(UpdateTransformControl, { state: t4.parent, transform: t4.transform, customHeader: "none", noMargin: true, autoHideApply: true }) });
  }
  renderControls() {
    const disabled = this.state.isBusy || this.isEmpty;
    const presets = this.presetActions;
    const label = this.label;
    return (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [(0, import_jsx_runtime11.jsxs)("div", { className: "msp-flex-row", style: { marginTop: "1px" }, children: [(0, import_jsx_runtime11.jsx)(Button, { noOverflow: true, flex: true, onClick: this.toggleHierarchy, disabled, title: label, children: label }), presets.length > 0 && (0, import_jsx_runtime11.jsx)(IconButton, { svg: BookmarksOutlinedSvg, className: "msp-form-control", flex: "40px", onClick: this.togglePreset, title: "Apply a structure presets to the current hierarchy.", toggleState: this.state.show === "presets", disabled })] }), this.state.show === "hierarchy" && (0, import_jsx_runtime11.jsx)(ActionMenu, { items: this.hierarchyItems, onSelect: this.selectHierarchy, multiselect: true }), this.state.show === "presets" && (0, import_jsx_runtime11.jsx)(ActionMenu, { items: presets, onSelect: this.applyPreset }), this.modelIndex, this.structureType, this.transform, (0, import_jsx_runtime11.jsxs)("div", { style: { marginTop: "6px" }, children: [(0, import_jsx_runtime11.jsx)(StructureFocusControls, {}), (0, import_jsx_runtime11.jsx)(StructureSelectionStatsControls, { hideOnEmpty: true })] })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/volume.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-state/helpers/volume-representation-params.js
function createVolumeRepresentationParams(ctx, volume, props = {}) {
  const p = props;
  if (typeof p.type === "string" || typeof p.color === "string" || typeof p.size === "string")
    return createParamsByName(ctx, volume || Volume.One, props);
  return createParamsProvider(ctx, volume || Volume.One, props);
}
function createParamsByName(ctx, volume, props) {
  const typeProvider = props.type && ctx.representation.volume.registry.get(props.type) || ctx.representation.volume.registry.default.provider;
  const colorProvider = props.color && ctx.representation.volume.themes.colorThemeRegistry.get(props.color) || ctx.representation.volume.themes.colorThemeRegistry.get(typeProvider.defaultColorTheme.name);
  const sizeProvider = props.size && ctx.representation.volume.themes.sizeThemeRegistry.get(props.size) || ctx.representation.volume.themes.sizeThemeRegistry.get(typeProvider.defaultSizeTheme.name);
  return createParamsProvider(ctx, volume, {
    type: typeProvider,
    typeParams: props.typeParams,
    color: colorProvider,
    colorParams: props.colorParams,
    size: sizeProvider,
    sizeParams: props.sizeParams
  });
}
function createParamsProvider(ctx, volume, props = {}) {
  const { themes: themeCtx } = ctx.representation.volume;
  const themeDataCtx = { volume };
  const repr = props.type || ctx.representation.volume.registry.default.provider;
  const reprDefaultParams = ParamDefinition.getDefaultValues(repr.getParams(themeCtx, volume));
  const reprParams = Object.assign(reprDefaultParams, props.typeParams);
  const color2 = props.color || themeCtx.colorThemeRegistry.get(repr.defaultColorTheme.name);
  const colorDefaultParams = ParamDefinition.getDefaultValues(color2.getParams(themeDataCtx));
  if (color2.name === repr.defaultColorTheme.name)
    Object.assign(colorDefaultParams, repr.defaultColorTheme.props);
  const colorParams = Object.assign(colorDefaultParams, props.colorParams);
  const size = props.size || themeCtx.sizeThemeRegistry.get(repr.defaultSizeTheme.name);
  const sizeDefaultParams = ParamDefinition.getDefaultValues(size.getParams(themeDataCtx));
  if (size.name === repr.defaultSizeTheme.name)
    Object.assign(sizeDefaultParams, repr.defaultSizeTheme.props);
  const sizeParams = Object.assign(sizeDefaultParams, props.sizeParams);
  return {
    type: { name: repr.name, params: reprParams },
    colorTheme: { name: color2.name, params: colorParams },
    sizeTheme: { name: size.name, params: sizeParams }
  };
}

// node_modules/molstar/lib/mol-plugin-state/manager/volume/hierarchy-state.js
function buildVolumeHierarchy(state, previous2) {
  const build = BuildState2(state, previous2 || VolumeHierarchy());
  doPreOrder2(state.tree, build);
  if (previous2)
    previous2.refs.forEach(isRemoved2, build);
  return { hierarchy: build.hierarchy, added: build.added, changed: build.changed };
}
function VolumeHierarchy() {
  return { volumes: [], lazyVolumes: [], refs: /* @__PURE__ */ new Map() };
}
function VolumeRef(cell) {
  return { kind: "volume", cell, version: cell.transform.version, representations: [] };
}
function LazyVolumeRef(cell) {
  return { kind: "lazy-volume", cell, version: cell.transform.version };
}
function VolumeRepresentationRef(cell, volume) {
  return { kind: "volume-representation", cell, version: cell.transform.version, volume };
}
function BuildState2(state, oldHierarchy) {
  return { state, oldHierarchy, hierarchy: VolumeHierarchy(), changed: false, added: /* @__PURE__ */ new Set() };
}
function createOrUpdateRefList2(state, cell, list3, ctor, ...args) {
  const ref = ctor(...args);
  list3.push(ref);
  state.hierarchy.refs.set(cell.transform.ref, ref);
  const old = state.oldHierarchy.refs.get(cell.transform.ref);
  if (old) {
    if (old.version !== cell.transform.version)
      state.changed = true;
  } else {
    state.added.add(ref.cell.transform.ref);
    state.changed = true;
  }
  return ref;
}
function isTypeRoot2(t4, target) {
  return (cell, state) => !target(state) && t4.is(cell.obj);
}
function noop2() {
}
var Mapping2 = [
  [isTypeRoot2(PluginStateObject.Volume.Data, (t4) => t4.currentVolume), (state, cell) => {
    state.currentVolume = createOrUpdateRefList2(state, cell, state.hierarchy.volumes, VolumeRef, cell);
  }, (state) => state.currentVolume = void 0],
  [(cell) => PluginStateObject.Volume.Lazy.is(cell.obj), (state, cell) => {
    createOrUpdateRefList2(state, cell, state.hierarchy.lazyVolumes, LazyVolumeRef, cell);
  }, noop2],
  [(cell, state) => {
    return !cell.state.isGhost && !!state.currentVolume && PluginStateObject.Volume.Representation3D.is(cell.obj);
  }, (state, cell) => {
    if (state.currentVolume) {
      createOrUpdateRefList2(state, cell, state.currentVolume.representations, VolumeRepresentationRef, cell, state.currentVolume);
    }
    return false;
  }, noop2]
];
function isValidCell2(cell) {
  if (!cell || !(cell === null || cell === void 0 ? void 0 : cell.parent) || !cell.parent.cells.has(cell.transform.ref))
    return false;
  const { obj } = cell;
  if (!obj || obj === StateObject.Null || cell.status !== "ok" && cell.status !== "error")
    return false;
  return true;
}
function isRemoved2(ref) {
  const { cell } = ref;
  if (isValidCell2(cell))
    return;
  this.changed = true;
}
function _preOrderFunc2(c4) {
  _doPreOrder2(this, this.tree.transforms.get(c4));
}
function _doPreOrder2(ctx, root3) {
  const { state } = ctx;
  const cell = state.state.cells.get(root3.ref);
  if (!isValidCell2(cell))
    return;
  let onLeave = void 0;
  let end = false;
  for (const [test, f, l] of Mapping2) {
    if (test(cell, state)) {
      const cont2 = f(state, cell);
      if (cont2 === false) {
        end = true;
        break;
      }
      onLeave = l;
      break;
    }
  }
  if (end)
    return;
  const children = ctx.tree.children.get(root3.ref);
  if (children && children.size) {
    children.forEach(_preOrderFunc2, ctx);
  }
  if (onLeave)
    onLeave(state);
}
function doPreOrder2(tree, state) {
  const ctx = { tree, state };
  _doPreOrder2(ctx, tree.root);
  return ctx.state;
}

// node_modules/molstar/lib/mol-plugin-state/manager/volume/hierarchy.js
var VolumeHierarchyManager = class extends PluginComponent {
  get dataState() {
    return this.plugin.state.data;
  }
  get current() {
    this.sync(false);
    return this.state.hierarchy;
  }
  get selection() {
    this.sync(false);
    return this.state.selection;
  }
  sync(notify) {
    if (!notify && this.dataState.inUpdate)
      return;
    if (this.state.syncedTree === this.dataState.tree) {
      if (notify && !this.state.notified) {
        this.state.notified = true;
        this.behaviors.selection.next({ hierarchy: this.state.hierarchy, volume: this.state.selection });
      }
      return;
    }
    this.state.syncedTree = this.dataState.tree;
    const update = buildVolumeHierarchy(this.plugin.state.data, this.current);
    if (!update.changed) {
      return;
    }
    const { hierarchy } = update;
    this.state.hierarchy = hierarchy;
    if (!this.state.selection) {
      this.state.selection = hierarchy.volumes[0];
    } else {
      this.state.selection = hierarchy.refs.has(this.state.selection.cell.transform.ref) ? hierarchy.refs.get(this.state.selection.cell.transform.ref) : hierarchy.volumes[0];
    }
    if (notify) {
      this.state.notified = true;
      this.behaviors.selection.next({ hierarchy, volume: this.state.selection });
    } else {
      this.state.notified = false;
    }
  }
  setCurrent(volume) {
    this.state.selection = volume || this.state.hierarchy.volumes[0];
    this.behaviors.selection.next({ hierarchy: this.state.hierarchy, volume: volume || this.state.hierarchy.volumes[0] });
  }
  // TODO: have common util
  remove(refs, canUndo) {
    if (refs.length === 0)
      return;
    const deletes = this.plugin.state.data.build();
    for (const r of refs)
      deletes.delete(typeof r === "string" ? r : r.cell.transform.ref);
    return deletes.commit({ canUndo: canUndo ? "Remove" : false });
  }
  // TODO: have common util
  toggleVisibility(refs, action) {
    if (refs.length === 0)
      return;
    const isHidden = action !== void 0 ? action === "show" ? false : true : !refs[0].cell.state.isHidden;
    for (const c4 of refs) {
      setSubtreeVisibility(this.dataState, c4.cell.transform.ref, isHidden);
    }
  }
  addRepresentation(ref, type) {
    var _a;
    const update = this.dataState.build().to(ref.cell).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(this.plugin, (_a = ref.cell.obj) === null || _a === void 0 ? void 0 : _a.data, {
      type
    }));
    return update.commit({ canUndo: "Add Representation" });
  }
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.state = {
      syncedTree: this.dataState.tree,
      notified: false,
      hierarchy: VolumeHierarchy(),
      selection: void 0
    };
    this.behaviors = {
      selection: this.ev.behavior({
        hierarchy: this.current,
        volume: this.selection
      })
    };
    this.subscribe(plugin.state.data.events.changed, (e) => {
      if (e.inTransaction || plugin.behaviors.state.isAnimating.value)
        return;
      this.sync(true);
    });
    this.subscribe(plugin.behaviors.state.isAnimating, (isAnimating) => {
      if (!isAnimating && !plugin.behaviors.state.isUpdating.value)
        this.sync(true);
    });
  }
};
(function(VolumeHierarchyManager2) {
  function getRepresentationTypes(plugin, pivot) {
    var _a, _b;
    return ((_a = pivot === null || pivot === void 0 ? void 0 : pivot.cell.obj) === null || _a === void 0 ? void 0 : _a.data) ? plugin.representation.volume.registry.getApplicableTypes((_b = pivot.cell.obj) === null || _b === void 0 ? void 0 : _b.data) : plugin.representation.volume.registry.types;
  }
  VolumeHierarchyManager2.getRepresentationTypes = getRepresentationTypes;
})(VolumeHierarchyManager || (VolumeHierarchyManager = {}));

// node_modules/molstar/lib/mol-plugin-ui/state/apply-action.js
var ApplyActionControl = class extends TransformControlBase {
  constructor() {
    super(...arguments);
    this._getInfo = memoizeLatest((t4, v2, collapsed) => StateTransformParameters.infoFromAction(this.plugin, this.props.state, this.props.action, this.props.nodeRef));
    this.state = { plugin: this.plugin, ref: this.props.nodeRef, version: this.props.state.transforms.get(this.props.nodeRef).version, error: void 0, isInitial: true, params: this.getInfo().initialValues, busy: false, isCollapsed: this.props.initiallyCollapsed };
  }
  applyAction() {
    return PluginCommands.State.ApplyAction(this.plugin, {
      state: this.props.state,
      action: this.props.action.create(this.state.params),
      ref: this.props.nodeRef
    });
  }
  getInfo() {
    var _a;
    return this._getInfo(this.props.nodeRef, this.props.state.transforms.get(this.props.nodeRef).version, (_a = this.state) === null || _a === void 0 ? void 0 : _a.isCollapsed);
  }
  getTransformerId() {
    return this.props.state.transforms.get(this.props.nodeRef).transformer.id;
  }
  getHeader() {
    return this.props.hideHeader ? "none" : this.props.action.definition.display;
  }
  canApply() {
    return !this.state.error && !this.state.busy;
  }
  canAutoApply() {
    return false;
  }
  applyText() {
    return "Apply";
  }
  isUpdate() {
    return false;
  }
  getSourceAndTarget() {
    return { a: this.props.state.cells.get(this.props.nodeRef).obj };
  }
  static getDerivedStateFromProps(props, state) {
    const version = props.state.transforms.get(props.nodeRef).version;
    if (props.nodeRef === state.ref && version === state.version) {
      return null;
    }
    const source = props.state.cells.get(props.nodeRef).obj;
    const params = props.action.definition.params ? ParamDefinition.getDefaultValues(props.action.definition.params(source, state.plugin)) : {};
    const newState = {
      plugin: state.plugin,
      ref: props.nodeRef,
      version,
      params,
      isInitial: true,
      error: void 0
    };
    return newState;
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/volume.js
var VolumeStreamingControls = class extends CollapsableControls {
  defaultState() {
    return {
      header: "Volume Streaming",
      isCollapsed: false,
      isBusy: false,
      isHidden: true,
      brand: { accent: "cyan", svg: BlurOnSvg }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, () => {
      this.setState({
        isHidden: !this.canEnable(),
        description: StructureHierarchyManager.getSelectedStructuresDescription(this.plugin)
      });
    });
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      if (Transform.hasTag(e.cell.transform, VolumeStreaming.RootTag))
        this.forceUpdate();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
  }
  get pivot() {
    return this.plugin.managers.structure.hierarchy.selection.structures[0];
  }
  canEnable() {
    var _a, _b;
    const { selection } = this.plugin.managers.structure.hierarchy;
    if (selection.structures.length !== 1)
      return false;
    const pivot = this.pivot.cell;
    if (!pivot.obj)
      return false;
    return !!((_b = (_a = InitVolumeStreaming.definition).isApplicable) === null || _b === void 0 ? void 0 : _b.call(_a, pivot.obj, pivot.transform, this.plugin));
  }
  renderEnable() {
    var _a, _b;
    const pivot = this.pivot;
    if (!pivot.cell.parent)
      return null;
    const root3 = StateSelection.findTagInSubtree(pivot.cell.parent.tree, this.pivot.cell.transform.ref, VolumeStreaming.RootTag);
    const rootCell = root3 && pivot.cell.parent.cells.get(root3);
    const simpleApply = rootCell && rootCell.status === "error" ? { header: !!rootCell.errorText && ((_a = rootCell.errorText) === null || _a === void 0 ? void 0 : _a.includes("404")) ? "No Density Data Available" : "Error Enabling", icon: ErrorSvg, title: rootCell.errorText } : rootCell && ((_b = rootCell.obj) === null || _b === void 0 ? void 0 : _b.data.entries.length) === 0 ? { header: "Error Enabling", icon: ErrorSvg, title: "No Entry for Streaming Found" } : { header: "Enable", icon: CheckSvg, title: "Enable" };
    return (0, import_jsx_runtime12.jsx)(ApplyActionControl, { state: pivot.cell.parent, action: InitVolumeStreaming, initiallyCollapsed: true, nodeRef: pivot.cell.transform.ref, simpleApply });
  }
  renderParams() {
    var _a, _b, _c, _d, _e;
    const pivot = this.pivot;
    if (!pivot.cell.parent)
      return null;
    const bindings = ((_b = (_a = pivot.volumeStreaming) === null || _a === void 0 ? void 0 : _a.cell.transform.params) === null || _b === void 0 ? void 0 : _b.entry.params.view.name) === "selection-box" && ((_e = (_d = (_c = this.plugin.state.behaviors.cells.get(FocusLoci.id)) === null || _c === void 0 ? void 0 : _c.params) === null || _d === void 0 ? void 0 : _d.values) === null || _e === void 0 ? void 0 : _e.bindings);
    return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsx)(UpdateTransformControl, { state: pivot.cell.parent, transform: pivot.volumeStreaming.cell.transform, customHeader: "none", noMargin: true }), bindings && (0, import_jsx_runtime12.jsx)(ExpandGroup, { header: "Controls Help", children: (0, import_jsx_runtime12.jsx)(BindingsHelp, { bindings }) })] });
  }
  renderControls() {
    const pivot = this.pivot;
    if (!pivot)
      return null;
    if (!pivot.volumeStreaming)
      return this.renderEnable();
    return this.renderParams();
  }
};
var VolumeSourceControls = class extends CollapsableControls {
  constructor() {
    super(...arguments);
    this.item = (ref) => {
      var _a;
      const selected = this.plugin.managers.volume.hierarchy.selection;
      const label = ((_a = ref.cell.obj) === null || _a === void 0 ? void 0 : _a.label) || "Volume";
      const item = {
        kind: "item",
        label: (ref.kind === "lazy-volume" ? "Load " : "") + (label || ref.kind),
        selected: selected === ref,
        value: ref
      };
      return item;
    };
    this.selectCurrent = (item) => {
      this.toggleHierarchy();
      if (!item)
        return;
      const current = item.value;
      if (current.kind === "volume") {
        this.plugin.managers.volume.hierarchy.setCurrent(current);
      } else {
        this.lazyLoad(current.cell);
      }
    };
    this.selectAdd = (item) => {
      if (!item)
        return;
      this.setState({ show: void 0 });
      item.value();
    };
    this.toggleHierarchy = () => this.setState({ show: this.state.show !== "hierarchy" ? "hierarchy" : void 0 });
    this.toggleAddRepr = () => this.setState({ show: this.state.show !== "add-repr" ? "add-repr" : void 0 });
    this.toggleVisibility = () => {
      var _a, _b;
      const mng = this.plugin.managers.volume.hierarchy;
      const { current } = mng;
      const globalVisibility = !((_b = (_a = current.volumes[0]) === null || _a === void 0 ? void 0 : _a.representations[0]) === null || _b === void 0 ? void 0 : _b.cell.state.isHidden);
      this.plugin.managers.volume.hierarchy.toggleVisibility(current.volumes.flatMap((v2) => v2.representations), globalVisibility ? "hide" : "show");
    };
  }
  defaultState() {
    return {
      header: "Volume",
      isCollapsed: false,
      isBusy: false,
      isHidden: true,
      brand: { accent: "purple", svg: BlurOnSvg }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.volume.hierarchy.behaviors.selection, (sel) => {
      this.setState({ isHidden: sel.hierarchy.volumes.length === 0 && sel.hierarchy.lazyVolumes.length === 0 });
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
  }
  get hierarchyItems() {
    const mng = this.plugin.managers.volume.hierarchy;
    const { current } = mng;
    const ret = [];
    for (const ref of current.volumes) {
      ret.push(this.item(ref));
    }
    for (const ref of current.lazyVolumes) {
      ret.push(this.item(ref));
    }
    return ret;
  }
  get addActions() {
    const mng = this.plugin.managers.volume.hierarchy;
    const current = mng.selection;
    const ret = [
      ...VolumeHierarchyManager.getRepresentationTypes(this.plugin, current).map((t4) => ActionMenu.Item(t4[1], () => mng.addRepresentation(current, t4[0])))
    ];
    return ret;
  }
  get isEmpty() {
    const { volumes, lazyVolumes } = this.plugin.managers.volume.hierarchy.current;
    return volumes.length === 0 && lazyVolumes.length === 0;
  }
  get label() {
    var _a;
    if (this.state.loadingLabel)
      return `Loading ${this.state.loadingLabel}...`;
    const selected = this.plugin.managers.volume.hierarchy.selection;
    if (!selected)
      return "Nothing Selected";
    return ((_a = selected === null || selected === void 0 ? void 0 : selected.cell.obj) === null || _a === void 0 ? void 0 : _a.label) || "Volume";
  }
  async lazyLoad(cell) {
    const { url, isBinary, format, entryId, isovalues } = cell.obj.data;
    this.setState({ isBusy: true, loadingLabel: cell.obj.label });
    try {
      const plugin = this.plugin;
      await plugin.dataTransaction(async () => {
        var _a, _b, _c, _d;
        const data = await plugin.builders.data.download({ url, isBinary }, { state: { isGhost: true } });
        const parsed = await plugin.dataFormats.get(format).parse(plugin, data, { entryId });
        const firstVolume = parsed.volume || parsed.volumes[0];
        if (!(firstVolume === null || firstVolume === void 0 ? void 0 : firstVolume.isOk))
          throw new Error("Failed to parse any volume.");
        const repr = plugin.build();
        for (const iso of isovalues) {
          repr.to((_c = (_a = parsed.volumes) === null || _a === void 0 ? void 0 : _a[(_b = iso.volumeIndex) !== null && _b !== void 0 ? _b : 0]) !== null && _c !== void 0 ? _c : parsed.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(this.plugin, firstVolume.data, {
            type: "isosurface",
            typeParams: { alpha: (_d = iso.alpha) !== null && _d !== void 0 ? _d : 1, isoValue: iso.type === "absolute" ? { kind: "absolute", absoluteValue: iso.value } : { kind: "relative", relativeValue: iso.value } },
            color: "uniform",
            colorParams: { value: iso.color }
          }));
        }
        await repr.commit();
        await plugin.build().delete(cell).commit();
      });
    } finally {
      this.setState({ isBusy: false, loadingLabel: void 0 });
    }
  }
  renderControls() {
    const disabled = this.state.isBusy || this.isEmpty;
    const label = this.label;
    const selected = this.plugin.managers.volume.hierarchy.selection;
    const mng = this.plugin.managers.volume.hierarchy;
    const { current } = mng;
    return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsxs)("div", { className: "msp-flex-row", style: { marginTop: "1px" }, children: [(0, import_jsx_runtime12.jsx)(Button, { noOverflow: true, flex: true, onClick: this.toggleHierarchy, disabled, title: label, children: label }), !this.isEmpty && selected && (0, import_jsx_runtime12.jsx)(IconButton, { svg: AddSvg, onClick: this.toggleAddRepr, title: "Apply a structure presets to the current hierarchy.", toggleState: this.state.show === "add-repr", disabled }), !this.isEmpty && (0, import_jsx_runtime12.jsx)(IconButton, { svg: VisibilityOutlinedSvg, onClick: this.toggleVisibility, toggleState: false, title: "Toggle visibility of all volumes.", disabled })] }), this.state.show === "hierarchy" && (0, import_jsx_runtime12.jsx)(ActionMenu, { items: this.hierarchyItems, onSelect: this.selectCurrent }), this.state.show === "add-repr" && (0, import_jsx_runtime12.jsx)(ActionMenu, { items: this.addActions, onSelect: this.selectAdd }), current.volumes.length > 0 && (0, import_jsx_runtime12.jsx)("div", { style: { marginTop: "6px" }, children: current.volumes.map((volume) => (0, import_jsx_runtime12.jsx)(VolumeEntryControls, { volume }, volume.cell.transform.ref)) })] });
  }
};
function VolumeEntryControls({ volume }) {
  var _a, _b;
  return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsx)("div", { className: "msp-control-group-header", style: { marginTop: "1px" }, children: (0, import_jsx_runtime12.jsx)("div", { children: (0, import_jsx_runtime12.jsx)("b", { children: (_b = (_a = volume.cell.obj) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "n/a" }) }) }), volume.representations.map((r) => (0, import_jsx_runtime12.jsx)(VolumeRepresentationControls, { volume, representation: r }, r.cell.transform.ref))] });
}
var VolumeRepresentationControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { action: void 0 };
    this.updateIsoValueEvent = new Subject();
    this.remove = () => this.plugin.managers.volume.hierarchy.remove([this.props.representation], true);
    this.toggleVisible = (e) => {
      e.preventDefault();
      e.currentTarget.blur();
      this.plugin.managers.volume.hierarchy.toggleVisibility([this.props.representation]);
    };
    this.toggleColor = () => {
      this.setState({ action: this.state.action === "select-color" ? void 0 : "select-color" });
    };
    this.toggleUpdate = () => this.setState({ action: this.state.action === "update" ? void 0 : "update" });
    this.highlight = (e) => {
      e.preventDefault();
      if (!this.props.representation.cell.parent)
        return;
      PluginCommands.Interactivity.Object.Highlight(this.plugin, { state: this.props.representation.cell.parent, ref: this.props.representation.cell.transform.ref });
    };
    this.clearHighlight = (e) => {
      e.preventDefault();
      PluginCommands.Interactivity.ClearHighlights(this.plugin);
    };
    this.focus = () => {
      var _a;
      const repr = this.props.representation;
      const lociList = (_a = repr.cell.obj) === null || _a === void 0 ? void 0 : _a.data.repr.getAllLoci();
      if (repr.cell.state.isHidden)
        this.plugin.managers.volume.hierarchy.toggleVisibility([this.props.representation], "show");
      if (lociList)
        this.plugin.managers.camera.focusLoci(lociList, { extraRadius: 1 });
    };
    this.updateColor = ({ value }) => {
      const t4 = this.props.representation.cell.transform;
      return this.plugin.build().to(t4.ref).update({
        ...t4.params,
        colorTheme: {
          name: "uniform",
          params: { value }
        }
      }).commit();
    };
    this.requestIsoValueUpdate = (values2) => {
      this.updateIsoValueEvent.next(values2);
    };
    this.updateIsoValue = (values2) => {
      var _a, _b;
      const t4 = this.props.representation.cell.transform;
      return this.plugin.build().to(t4.ref).update({
        ...t4.params,
        type: {
          ...(_a = t4.params) === null || _a === void 0 ? void 0 : _a.type,
          params: {
            ...(_b = t4.params) === null || _b === void 0 ? void 0 : _b.type.params,
            isoValue: values2.isoValue
          }
        }
      }).commit();
    };
    this.isoValueParams = memoizeLatest((ref, type) => {
      var _a, _b;
      const repr = this.props.representation.cell;
      const params = repr.transform.params;
      if ((params === null || params === void 0 ? void 0 : params.type.name) !== "isosurface")
        return void 0;
      return { isoValue: Volume.createIsoValueParam(params.type.params.isoValue, (_b = (_a = this.props.volume.cell.obj) === null || _a === void 0 ? void 0 : _a.data.grid) === null || _b === void 0 ? void 0 : _b.stats) };
    });
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      if (State.ObjectEvent.isCell(e, this.props.representation.cell))
        this.forceUpdate();
    });
    this.subscribe(this.updateIsoValueEvent.pipe(throttleTime(100, void 0, { leading: false, trailing: true })), this.updateIsoValue);
  }
  get color() {
    var _a, _b;
    const repr = this.props.representation.cell;
    const isUniform = ((_a = repr.transform.params) === null || _a === void 0 ? void 0 : _a.colorTheme.name) === "uniform";
    if (!isUniform)
      return void 0;
    return (_b = repr.transform.params) === null || _b === void 0 ? void 0 : _b.colorTheme.params.value;
  }
  get isIsoSurface() {
    var _a;
    const repr = this.props.representation.cell;
    return ((_a = repr.transform.params) === null || _a === void 0 ? void 0 : _a.type.name) === "isosurface";
  }
  render() {
    var _a, _b, _c;
    const repr = this.props.representation.cell;
    const params = repr.transform.params;
    const color2 = this.color;
    const isoParams = this.isoValueParams(repr.transform.ref, params === null || params === void 0 ? void 0 : params.type.name);
    return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsxs)("div", { className: "msp-flex-row", children: [color2 !== void 0 && (0, import_jsx_runtime12.jsx)(Button, { style: { backgroundColor: Color.toStyle(color2), minWidth: 32, width: 32 }, onClick: this.toggleColor }), (0, import_jsx_runtime12.jsxs)(Button, { noOverflow: true, className: "msp-control-button-label", title: `${(_a = repr.obj) === null || _a === void 0 ? void 0 : _a.label}. Click to focus.`, onClick: this.focus, onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, style: { textAlign: "left" }, children: [(_b = repr.obj) === null || _b === void 0 ? void 0 : _b.label, (0, import_jsx_runtime12.jsx)("small", { className: "msp-25-lower-contrast-text", style: { float: "right" }, children: (_c = repr.obj) === null || _c === void 0 ? void 0 : _c.description })] }), (0, import_jsx_runtime12.jsx)(IconButton, { svg: repr.state.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, onClick: this.toggleVisible, title: `${repr.state.isHidden ? "Show" : "Hide"} component`, small: true, className: "msp-form-control", flex: true }), (0, import_jsx_runtime12.jsx)(IconButton, { svg: DeleteOutlinedSvg, onClick: this.remove, title: "Remove", small: true }), (0, import_jsx_runtime12.jsx)(IconButton, { svg: MoreHorizSvg, onClick: this.toggleUpdate, title: "Actions", toggleState: this.state.action === "update" })] }), this.state.action === "update" && !!repr.parent && (0, import_jsx_runtime12.jsx)("div", { style: { marginBottom: "6px" }, className: "msp-accent-offset", children: (0, import_jsx_runtime12.jsxs)("div", { children: [!!isoParams && (0, import_jsx_runtime12.jsx)("div", { style: { marginBottom: "1px" }, children: (0, import_jsx_runtime12.jsx)(ParameterControls, { params: isoParams, values: { isoValue: params === null || params === void 0 ? void 0 : params.type.params.isoValue }, onChangeValues: this.requestIsoValueUpdate }) }), (0, import_jsx_runtime12.jsx)(UpdateTransformControl, { state: repr.parent, transform: repr.transform, customHeader: "none", noMargin: true })] }) }), this.state.action === "select-color" && color2 !== void 0 && (0, import_jsx_runtime12.jsx)("div", { style: { marginBottom: "6px", marginTop: 1 }, className: "msp-accent-offset", children: (0, import_jsx_runtime12.jsx)(ControlGroup, { header: "Select Color", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleColor, topRightIcon: CloseSvg, noTopMargin: true, childrenClassName: "msp-viewport-controls-panel-controls", children: (0, import_jsx_runtime12.jsx)(CombinedColorControl, { param: VolumeColorParam, value: this.color, onChange: this.updateColor, name: "color", hideNameRow: true }) }) })] });
  }
};
var VolumeColorParam = ParamDefinition.Color(Color(1184274));

// node_modules/molstar/lib/mol-plugin-ui/structure/superposition.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-math/linear-algebra/matrix/evd.js
var EVD;
(function(EVD2) {
  function createCache(size) {
    return {
      size,
      matrix: Matrix.create(size, size),
      eigenValues: new Float64Array(size),
      D: new Float64Array(size),
      E: new Float64Array(size)
    };
  }
  EVD2.createCache = createCache;
  function compute(cache) {
    symmetricEigenDecomp(cache.size, cache.matrix.data, cache.eigenValues, cache.D, cache.E);
  }
  EVD2.compute = compute;
})(EVD || (EVD = {}));
function symmetricEigenDecomp(order2, matrixEv, vectorEv, d3, e) {
  for (let i = 0; i < order2; i++) {
    e[i] = 0;
  }
  const om1 = order2 - 1;
  for (let i = 0; i < order2; i++) {
    d3[i] = matrixEv[i * order2 + om1];
  }
  symmetricTridiagonalize(matrixEv, d3, e, order2);
  symmetricDiagonalize(matrixEv, d3, e, order2);
  for (let i = 0; i < order2; i++) {
    vectorEv[i] = d3[i];
  }
}
function symmetricTridiagonalize(a4, d3, e, order2) {
  for (let i = order2 - 1; i > 0; i--) {
    let scale = 0;
    let h = 0;
    for (let k = 0; k < i; k++) {
      scale = scale + Math.abs(d3[k]);
    }
    if (scale === 0) {
      e[i] = d3[i - 1];
      for (let j = 0; j < i; j++) {
        d3[j] = a4[j * order2 + i - 1];
        a4[j * order2 + i] = 0;
        a4[i * order2 + j] = 0;
      }
    } else {
      for (let k = 0; k < i; k++) {
        d3[k] /= scale;
        h += d3[k] * d3[k];
      }
      let f = d3[i - 1];
      let g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }
      e[i] = scale * g;
      h = h - f * g;
      d3[i - 1] = f - g;
      for (let j = 0; j < i; j++) {
        e[j] = 0;
      }
      for (let j = 0; j < i; j++) {
        f = d3[j];
        a4[i * order2 + j] = f;
        g = e[j] + a4[j * order2 + j] * f;
        for (let k = j + 1; k <= i - 1; k++) {
          g += a4[j * order2 + k] * d3[k];
          e[k] += a4[j * order2 + k] * f;
        }
        e[j] = g;
      }
      f = 0;
      for (let j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d3[j];
      }
      const hh = f / (h + h);
      for (let j = 0; j < i; j++) {
        e[j] -= hh * d3[j];
      }
      for (let j = 0; j < i; j++) {
        f = d3[j];
        g = e[j];
        for (let k = j; k <= i - 1; k++) {
          a4[j * order2 + k] -= f * e[k] + g * d3[k];
        }
        d3[j] = a4[j * order2 + i - 1];
        a4[j * order2 + i] = 0;
      }
    }
    d3[i] = h;
  }
  for (let i = 0; i < order2 - 1; i++) {
    a4[i * order2 + order2 - 1] = a4[i * order2 + i];
    a4[i * order2 + i] = 1;
    const h = d3[i + 1];
    if (h !== 0) {
      for (let k = 0; k <= i; k++) {
        d3[k] = a4[(i + 1) * order2 + k] / h;
      }
      for (let j = 0; j <= i; j++) {
        let g = 0;
        for (let k = 0; k <= i; k++) {
          g += a4[(i + 1) * order2 + k] * a4[j * order2 + k];
        }
        for (let k = 0; k <= i; k++) {
          a4[j * order2 + k] -= g * d3[k];
        }
      }
    }
    for (let k = 0; k <= i; k++) {
      a4[(i + 1) * order2 + k] = 0;
    }
  }
  for (let j = 0; j < order2; j++) {
    d3[j] = a4[j * order2 + order2 - 1];
    a4[j * order2 + order2 - 1] = 0;
  }
  a4[order2 * order2 - 1] = 1;
  e[0] = 0;
}
function symmetricDiagonalize(a4, d3, e, order2) {
  const maxiter = 1e3;
  for (let i = 1; i < order2; i++) {
    e[i - 1] = e[i];
  }
  e[order2 - 1] = 0;
  let f = 0;
  let tst1 = 0;
  const eps = Math.pow(2, -53);
  for (let l = 0; l < order2; l++) {
    tst1 = Math.max(tst1, Math.abs(d3[l]) + Math.abs(e[l]));
    let m = l;
    while (m < order2) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }
    if (m > l) {
      let iter = 0;
      do {
        iter = iter + 1;
        let g = d3[l];
        let p = (d3[l + 1] - g) / (2 * e[l]);
        let r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }
        d3[l] = e[l] / (p + r);
        d3[l + 1] = e[l] * (p + r);
        const dl1 = d3[l + 1];
        let h = g - d3[l];
        for (let i = l + 2; i < order2; i++) {
          d3[i] -= h;
        }
        f = f + h;
        p = d3[m];
        let c4 = 1;
        let c22 = c4;
        let c32 = c4;
        const el1 = e[l + 1];
        let s = 0;
        let s2 = 0;
        for (let i = m - 1; i >= l; i--) {
          c32 = c22;
          c22 = c4;
          s2 = s;
          g = c4 * e[i];
          h = c4 * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c4 = p / r;
          p = c4 * d3[i] - s * g;
          d3[i + 1] = h + s * (c4 * g + s * d3[i]);
          for (let k = 0; k < order2; k++) {
            h = a4[(i + 1) * order2 + k];
            a4[(i + 1) * order2 + k] = s * a4[i * order2 + k] + c4 * h;
            a4[i * order2 + k] = c4 * a4[i * order2 + k] - s * h;
          }
        }
        p = -s * s2 * c32 * el1 * e[l] / dl1;
        e[l] = s * p;
        d3[l] = c4 * p;
        if (iter >= maxiter) {
          throw new Error("SVD: Not converging.");
        }
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d3[l] = d3[l] + f;
    e[l] = 0;
  }
  for (let i = 0; i < order2 - 1; i++) {
    let k = i;
    let p = d3[i];
    for (let j = i + 1; j < order2; j++) {
      if (d3[j] < p) {
        k = j;
        p = d3[j];
      }
    }
    if (k !== i) {
      d3[k] = d3[i];
      d3[i] = p;
      for (let j = 0; j < order2; j++) {
        p = a4[i * order2 + j];
        a4[i * order2 + j] = a4[k * order2 + j];
        a4[k * order2 + j] = p;
      }
    }
  }
}
function hypotenuse(a4, b4) {
  if (Math.abs(a4) > Math.abs(b4)) {
    const r = b4 / a4;
    return Math.abs(a4) * Math.sqrt(1 + r * r);
  }
  if (b4 !== 0) {
    const r = a4 / b4;
    return Math.abs(b4) * Math.sqrt(1 + r * r);
  }
  return 0;
}

// node_modules/molstar/lib/mol-math/linear-algebra/3d/minimize-rmsd.js
var MinimizeRmsd;
(function(MinimizeRmsd2) {
  let Positions;
  (function(Positions2) {
    function empty3(n) {
      return { x: new Float64Array(n), y: new Float64Array(n), z: new Float64Array(n) };
    }
    Positions2.empty = empty3;
  })(Positions = MinimizeRmsd2.Positions || (MinimizeRmsd2.Positions = {}));
  function compute(data, result) {
    if (typeof result === "undefined")
      result = { bTransform: Mat4.zero(), rmsd: 0 };
    findMinimalRmsdTransformImpl(new RmsdTransformState(data, result));
    return result;
  }
  MinimizeRmsd2.compute = compute;
})(MinimizeRmsd || (MinimizeRmsd = {}));
var RmsdTransformState = class {
  constructor(data, into) {
    this.evdCache = EVD.createCache(4);
    this.translateB = Mat4.identity();
    this.rotateB = Mat4.identity();
    this.tempMatrix = Mat4.identity();
    this.a = data.a;
    this.b = data.b;
    if (data.centerA)
      this.centerA = data.centerA;
    else
      this.centerA = data.centerA = CentroidHelper.fromArrays(data.a, Sphere3D()).center;
    if (data.centerB)
      this.centerB = data.centerB;
    else
      this.centerB = data.centerB = CentroidHelper.fromArrays(data.b, Sphere3D()).center;
    this.result = into;
  }
};
function computeN(state) {
  const N = state.evdCache.matrix;
  Matrix.makeZero(N);
  const xsA = state.a.x, ysA = state.a.y, zsA = state.a.z;
  const xsB = state.b.x, ysB = state.b.y, zsB = state.b.z;
  const cA = state.centerA;
  const cB = state.centerB;
  let sizeSq = 0;
  const L = Math.min(state.a.x.length, state.b.x.length);
  for (let i = 0; i < L; i++) {
    const aX = xsA[i] - cA[0], aY = ysA[i] - cA[1], aZ = zsA[i] - cA[2];
    const bX = xsB[i] - cB[0], bY = ysB[i] - cB[1], bZ = zsB[i] - cB[2];
    sizeSq += aX * aX + aY * aY + aZ * aZ + bX * bX + bY * bY + bZ * bZ;
    Matrix.add(N, 0, 0, aX * bX + aY * bY + aZ * bZ);
    Matrix.add(N, 0, 1, -(aZ * bY) + aY * bZ);
    Matrix.add(N, 0, 2, aZ * bX - aX * bZ);
    Matrix.add(N, 0, 3, -(aY * bX) + aX * bY);
    Matrix.add(N, 1, 0, -(aZ * bY) + aY * bZ);
    Matrix.add(N, 1, 1, aX * bX - aY * bY - aZ * bZ);
    Matrix.add(N, 1, 2, aY * bX + aX * bY);
    Matrix.add(N, 1, 3, aZ * bX + aX * bZ);
    Matrix.add(N, 2, 0, aZ * bX - aX * bZ);
    Matrix.add(N, 2, 1, aY * bX + aX * bY);
    Matrix.add(N, 2, 2, -(aX * bX) + aY * bY - aZ * bZ);
    Matrix.add(N, 2, 3, aZ * bY + aY * bZ);
    Matrix.add(N, 3, 0, -(aY * bX) + aX * bY);
    Matrix.add(N, 3, 1, aZ * bX + aX * bZ);
    Matrix.add(N, 3, 2, aZ * bY + aY * bZ);
    Matrix.add(N, 3, 3, -(aX * bX) - aY * bY + aZ * bZ);
  }
  return sizeSq;
}
function makeTransformMatrix(state) {
  const ev = state.evdCache.matrix;
  const qX = Matrix.get(ev, 1, 3);
  const qY = Matrix.get(ev, 2, 3);
  const qZ = Matrix.get(ev, 3, 3);
  const qW = Matrix.get(ev, 0, 3);
  const n12 = 2 * qY * qY;
  const n2 = 2 * qZ * qZ;
  const n3 = 2 * qX * qX;
  const n4 = 2 * qX * qY;
  const n5 = 2 * qW * qZ;
  const n6 = 2 * qX * qZ;
  const n7 = 2 * qW * qY;
  const n8 = 2 * qY * qZ;
  const n9 = 2 * qW * qX;
  let m = state.translateB;
  Mat4.setValue(m, 0, 3, -state.centerB[0]);
  Mat4.setValue(m, 1, 3, -state.centerB[1]);
  Mat4.setValue(m, 2, 3, -state.centerB[2]);
  m = state.rotateB;
  Mat4.setValue(m, 0, 0, 1 - n12 - n2);
  Mat4.setValue(m, 0, 1, n4 + n5);
  Mat4.setValue(m, 0, 2, n6 - n7);
  Mat4.setValue(m, 1, 0, n4 - n5);
  Mat4.setValue(m, 1, 1, 1 - n3 - n2);
  Mat4.setValue(m, 1, 2, n8 + n9);
  Mat4.setValue(m, 2, 0, n6 + n7);
  Mat4.setValue(m, 2, 1, n8 - n9);
  Mat4.setValue(m, 2, 2, 1 - n3 - n12);
  Mat4.setValue(m, 3, 3, 1);
  Mat4.mul(state.tempMatrix, state.rotateB, state.translateB);
  m = state.translateB;
  Mat4.setValue(m, 0, 3, state.centerA[0]);
  Mat4.setValue(m, 1, 3, state.centerA[1]);
  Mat4.setValue(m, 2, 3, state.centerA[2]);
  Mat4.mul(state.result.bTransform, state.translateB, state.tempMatrix);
}
function findMinimalRmsdTransformImpl(state) {
  const sizeSq = computeN(state);
  EVD.compute(state.evdCache);
  let rmsd = sizeSq - 2 * state.evdCache.eigenValues[3];
  rmsd = rmsd < 0 ? 0 : Math.sqrt(rmsd / state.a.x.length);
  makeTransformMatrix(state);
  state.result.rmsd = rmsd;
}

// node_modules/molstar/lib/mol-model/sequence/alignment/substitution-matrix.js
var aminoacidsX = "ACDEFGHIKLMNPQRSTVWY";
var aminoacids = "ARNDCQEGHILKMFPSTWYVBZX";
var blosum62x = [
  [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2],
  // A
  [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2],
  // C
  [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3],
  // D
  [-1, -4, 2, 5, -3, -2, 0, -3, 1, -3, -2, 0, -1, 2, 0, 0, -1, -2, -3, -2],
  // E
  [-2, -2, -3, -3, 6, -3, -1, 0, -3, 0, 0, -3, -4, -3, -3, -2, -2, -1, 1, 3],
  // F
  [0, -3, -1, -2, -3, 6, -2, -4, -2, -4, -3, 0, -2, -2, -2, 0, -2, -3, -2, -3],
  // G
  [-2, -3, -1, 0, -1, -2, 8, -3, -1, -3, -2, 1, -2, 0, 0, -1, -2, -3, -2, 2],
  // H
  [-1, -1, -3, -3, 0, -4, -3, 4, -3, 2, 1, -3, -3, -3, -3, -2, -1, 3, -3, -1],
  // I
  [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2],
  // K
  [-1, -1, -4, -3, 0, -4, -3, 2, -2, 4, 2, -3, -3, -2, -2, -2, -1, 1, -2, -1],
  // L
  [-1, -1, -3, -2, 0, -3, -2, 1, -1, 2, 5, -2, -2, 0, -1, -1, -1, 1, -1, -1],
  // M
  [-2, -3, 1, 0, -3, 0, 1, -3, 0, -3, -2, 6, -2, 0, 0, 1, 0, -3, -4, -2],
  // N
  [-1, -3, -1, -1, -4, -2, -2, -3, -1, -3, -2, -2, 7, -1, -2, -1, -1, -2, -4, -3],
  // P
  [-1, -3, 0, 2, -3, -2, 0, -3, 1, -2, 0, 0, -1, 5, 1, 0, -1, -2, -2, -1],
  // Q
  [-1, -3, -2, 0, -3, -2, 0, -3, 2, -2, -1, 0, -2, 1, 5, -1, -1, -3, -3, -2],
  // R
  [1, -1, 0, 0, -2, 0, -1, -2, 0, -2, -1, 1, -1, 0, -1, 4, 1, -2, -3, -2],
  // S
  [0, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, 0, -1, -1, -1, 1, 5, 0, -2, -2],
  // T
  [0, -1, -3, -2, -1, -3, -3, 3, -2, 1, 1, -3, -2, -2, -3, -2, 0, 4, -3, -1],
  // V
  [-3, -2, -4, -3, 1, -2, -2, -3, -3, -2, -1, -4, -4, -2, -3, -3, -2, -3, 11, 2],
  // W
  [-2, -2, -3, -2, 3, -3, 2, -1, -2, -1, -1, -2, -3, -1, -2, -2, -2, -1, 2, 7]
  // Y
];
var blosum62 = [
  // A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X
  [4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0, -2, -1, 0],
  // A
  [-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3, -1, 0, -1],
  // R
  [-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3, 3, 0, -1],
  // N
  [-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3, 4, 1, -1],
  // D
  [0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2],
  // C
  [-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2, 0, 3, -1],
  // Q
  [-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1],
  // E
  [0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3, -1, -2, -1],
  // G
  [-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3, 0, 0, -1],
  // H
  [-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3, -3, -3, -1],
  // I
  [-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1, -4, -3, -1],
  // L
  [-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2, 0, 1, -1],
  // K
  [-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1, -3, -1, -1],
  // M
  [-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1, -3, -3, -1],
  // F
  [-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2, -2, -1, -2],
  // P
  [1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2, 0, 0, 0],
  // S
  [0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0, -1, -1, 0],
  // T
  [-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3, -4, -3, -2],
  // W
  [-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1, -3, -2, -1],
  // Y
  [0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4, -3, -2, -1],
  // V
  [-2, -1, 3, 4, -3, 0, 1, -1, 0, -3, -4, 0, -3, -3, -2, 0, -1, -4, -3, -3, 4, 1, -1],
  // B
  [-1, 0, 0, 1, -3, 3, 4, -2, 0, -3, -3, 1, -1, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1],
  // Z
  [0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, 0, 0, -2, -1, -1, -1, -1, -1]
  // X
];
function prepareMatrix(cellNames, mat) {
  let j;
  let i = 0;
  const matDict = {};
  mat.forEach((row) => {
    j = 0;
    const rowDict = {};
    row.forEach((elm) => rowDict[cellNames[j++]] = elm);
    matDict[cellNames[i++]] = rowDict;
  });
  return matDict;
}
var SubstitutionMatrices = (() => ({
  blosum62: prepareMatrix(aminoacids, blosum62),
  blosum62x: prepareMatrix(aminoacidsX, blosum62x)
}))();

// node_modules/molstar/lib/mol-model/sequence/alignment/alignment.js
var DefaultAlignmentOptions = {
  gapPenalty: -11,
  gapExtensionPenalty: -1,
  substMatrix: "default"
};
function align(seqA, seqB, options = {}) {
  const o = { ...DefaultAlignmentOptions, ...options };
  const alignment = new Alignment(seqA, seqB, o);
  alignment.calculate();
  return alignment.trace();
}
var Alignment = class {
  constructor(seqA, seqB, options) {
    this.seqA = seqA;
    this.seqB = seqB;
    this.S = [];
    this.V = [];
    this.H = [];
    this.gapPenalty = options.gapPenalty;
    this.gapExtensionPenalty = options.gapExtensionPenalty;
    this.substMatrix = options.substMatrix === "default" ? void 0 : SubstitutionMatrices[options.substMatrix];
    this.n = this.seqA.length;
    this.m = this.seqB.length;
  }
  initMatrices() {
    const { n, m, gapPenalty, S, V, H } = this;
    for (let i = 0; i <= n; ++i) {
      S[i] = [], V[i] = [], H[i] = [];
      for (let j = 0; j <= m; ++j) {
        S[i][j] = 0, V[i][j] = 0, H[i][j] = 0;
      }
    }
    for (let i = 0; i <= n; ++i) {
      S[i][0] = gapPenalty;
      H[i][0] = -Infinity;
    }
    for (let j = 0; j <= m; ++j) {
      S[0][j] = gapPenalty;
      V[0][j] = -Infinity;
    }
    S[0][0] = 0;
  }
  makeScoreFn() {
    const { seqA, seqB, substMatrix } = this;
    if (substMatrix) {
      return function score(i, j) {
        var _a, _b;
        const cA = seqA[i];
        const cB = seqB[j];
        return (_b = (_a = substMatrix[cA]) === null || _a === void 0 ? void 0 : _a[cB]) !== null && _b !== void 0 ? _b : -4;
      };
    } else {
      return function scoreNoSubstMat(i, j) {
        const cA = seqA[i];
        const cB = seqB[j];
        return cA === cB ? 5 : -3;
      };
    }
  }
  calculate() {
    this.initMatrices();
    const scoreFn = this.makeScoreFn();
    const { V, H, S, n, m, gapExtensionPenalty, gapPenalty } = this;
    let Vi1, Si1, Vi, Hi, Si;
    for (let i = 1; i <= n; ++i) {
      Si1 = S[i - 1], Vi1 = V[i - 1];
      Vi = V[i], Hi = H[i], Si = S[i];
      for (let j = 1; j <= m; ++j) {
        Vi[j] = Math.max(Si1[j] + gapPenalty, Vi1[j] + gapExtensionPenalty);
        Hi[j] = Math.max(Si[j - 1] + gapPenalty, Hi[j - 1] + gapExtensionPenalty);
        Si[j] = Math.max(
          Si1[j - 1] + scoreFn(i - 1, j - 1),
          // match
          Vi[j],
          // del
          Hi[j]
          // ins
        );
      }
    }
  }
  trace() {
    const scoreFn = this.makeScoreFn();
    const { V, H, S, seqA, seqB, gapExtensionPenalty, gapPenalty } = this;
    let i = this.n;
    let j = this.m;
    let mat;
    let score;
    let aliA = "";
    let aliB = "";
    if (S[i][j] >= V[i][j]) {
      mat = "S";
      score = S[i][j];
    } else if (V[i][j] >= H[i][j]) {
      mat = "V";
      score = V[i][j];
    } else {
      mat = "H";
      score = H[i][j];
    }
    while (i > 0 && j > 0) {
      if (mat === "S") {
        if (S[i][j] === S[i - 1][j - 1] + scoreFn(i - 1, j - 1)) {
          aliA = seqA[i - 1] + aliA;
          aliB = seqB[j - 1] + aliB;
          --i;
          --j;
          mat = "S";
        } else if (S[i][j] === V[i][j]) {
          mat = "V";
        } else if (S[i][j] === H[i][j]) {
          mat = "H";
        } else {
          --i;
          --j;
        }
      } else if (mat === "V") {
        if (V[i][j] === V[i - 1][j] + gapExtensionPenalty) {
          aliA = seqA[i - 1] + aliA;
          aliB = "-" + aliB;
          --i;
          mat = "V";
        } else if (V[i][j] === S[i - 1][j] + gapPenalty) {
          aliA = seqA[i - 1] + aliA;
          aliB = "-" + aliB;
          --i;
          mat = "S";
        } else {
          --i;
        }
      } else if (mat === "H") {
        if (H[i][j] === H[i][j - 1] + gapExtensionPenalty) {
          aliA = "-" + aliA;
          aliB = seqB[j - 1] + aliB;
          --j;
          mat = "H";
        } else if (H[i][j] === S[i][j - 1] + gapPenalty) {
          aliA = "-" + aliA;
          aliB = seqB[j - 1] + aliB;
          --j;
          mat = "S";
        } else {
          --j;
        }
      }
    }
    while (i > 0) {
      aliA = seqA[i - 1] + aliA;
      aliB = "-" + aliB;
      --i;
    }
    while (j > 0) {
      aliA = "-" + aliA;
      aliB = seqB[j - 1] + aliB;
      --j;
    }
    return { aliA, aliB, score };
  }
};

// node_modules/molstar/lib/mol-model/sequence/alignment/sequence.js
var AlignSequences;
(function(AlignSequences2) {
  function createSeqIdIndicesMap(element3) {
    const seqIds = /* @__PURE__ */ new Map();
    if (Unit.isAtomic(element3.unit)) {
      const { label_seq_id } = element3.unit.model.atomicHierarchy.residues;
      const { residueIndex } = element3.unit;
      for (let i = 0, il = OrderedSet.size(element3.indices); i < il; ++i) {
        const uI = OrderedSet.getAt(element3.indices, i);
        const eI = element3.unit.elements[uI];
        const seqId = label_seq_id.value(residueIndex[eI]);
        if (seqIds.has(seqId))
          seqIds.get(seqId).push(uI);
        else
          seqIds.set(seqId, [uI]);
      }
    } else if (Unit.isCoarse(element3.unit)) {
      const { seq_id_begin } = Unit.isSpheres(element3.unit) ? element3.unit.model.coarseHierarchy.spheres : element3.unit.model.coarseHierarchy.gaussians;
      for (let i = 0, il = OrderedSet.size(element3.indices); i < il; ++i) {
        const uI = OrderedSet.getAt(element3.indices, i);
        const eI = element3.unit.elements[uI];
        const seqId = seq_id_begin.value(eI);
        seqIds.set(seqId, [uI]);
      }
    }
    return seqIds;
  }
  AlignSequences2.createSeqIdIndicesMap = createSeqIdIndicesMap;
  function compute(input, options = {}) {
    const seqA = getSequence(input.a.unit);
    const seqB = getSequence(input.b.unit);
    const seqIdIndicesA = createSeqIdIndicesMap(input.a);
    const seqIdIndicesB = createSeqIdIndicesMap(input.b);
    const indicesA = [];
    const indicesB = [];
    const { aliA, aliB, score } = align(seqA.code.toArray(), seqB.code.toArray(), options);
    let seqIdxA = 0, seqIdxB = 0;
    for (let i = 0, il = aliA.length; i < il; ++i) {
      if (aliA[i] === "-" || aliB[i] === "-") {
        if (aliA[i] !== "-")
          seqIdxA += 1;
        if (aliB[i] !== "-")
          seqIdxB += 1;
        continue;
      }
      const seqIdA = seqA.seqId.value(seqIdxA);
      const seqIdB = seqB.seqId.value(seqIdxB);
      if (seqIdIndicesA.has(seqIdA) && seqIdIndicesB.has(seqIdB)) {
        const iA = seqIdIndicesA.get(seqIdA);
        const iB = seqIdIndicesB.get(seqIdB);
        for (let j = 0, jl = Math.min(iA.length, iB.length); j < jl; ++j) {
          indicesA.push(iA[j]);
          indicesB.push(iB[j]);
        }
      }
      seqIdxA += 1, seqIdxB += 1;
    }
    const outA = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesA), input.a.indices);
    const outB = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesB), input.b.indices);
    return {
      a: { unit: input.a.unit, indices: outA },
      b: { unit: input.b.unit, indices: outB },
      score
    };
  }
  AlignSequences2.compute = compute;
})(AlignSequences || (AlignSequences = {}));
function entityKey(unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return unit.model.atomicHierarchy.index.getEntityFromChain(unit.chainIndex[unit.elements[0]]);
    case Unit.Kind.Spheres:
      return unit.model.coarseHierarchy.spheres.entityKey[unit.elements[0]];
    case Unit.Kind.Gaussians:
      return unit.model.coarseHierarchy.gaussians.entityKey[unit.elements[0]];
  }
}
function getSequence(unit) {
  return unit.model.sequence.byEntityKey[entityKey(unit)].sequence;
}

// node_modules/molstar/lib/mol-model/structure/structure/util/superposition.js
function superpose(xs) {
  const ret = [];
  if (xs.length <= 0)
    return ret;
  const n = getMinSize(xs);
  const input = {
    a: getPositionTable(xs[0], n),
    b: getPositionTable(xs[1], n)
  };
  ret[0] = MinimizeRmsd.compute(input);
  for (let i = 2; i < xs.length; i++) {
    input.b = getPositionTable(xs[i], n);
    input.centerB = void 0;
    ret.push(MinimizeRmsd.compute(input));
  }
  return ret;
}
var reProtein = /(polypeptide|cyclic-pseudo-peptide)/i;
function alignAndSuperpose(xs) {
  const ret = [];
  if (xs.length <= 0)
    return ret;
  const l = element_exports.Loci.getFirstLocation(xs[0]);
  const subtype = StructureProperties.entity.subtype(l);
  const substMatrix = subtype.match(reProtein) ? "blosum62" : "default";
  for (let i = 1; i < xs.length; i++) {
    const { a: a4, b: b4, score } = AlignSequences.compute({
      a: xs[0].elements[0],
      b: xs[i].elements[0]
    }, { substMatrix });
    const lociA = element_exports.Loci(xs[0].structure, [a4]);
    const lociB = element_exports.Loci(xs[i].structure, [b4]);
    const n = OrderedSet.size(a4.indices);
    ret.push({
      ...MinimizeRmsd.compute({
        a: getPositionTable(lociA, n),
        b: getPositionTable(lociB, n)
      }),
      alignmentScore: score
    });
  }
  return ret;
}
function getPositionTable(xs, n) {
  const ret = MinimizeRmsd.Positions.empty(n);
  let o = 0;
  for (const u2 of xs.elements) {
    const { unit, indices } = u2;
    const { elements, conformation: c4 } = unit;
    for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
      const e = elements[OrderedSet.getAt(indices, i)];
      ret.x[o] = c4.x(e);
      ret.y[o] = c4.y(e);
      ret.z[o] = c4.z(e);
      o++;
      if (o >= n)
        break;
    }
    if (o >= n)
      break;
  }
  return ret;
}
function getMinSize(xs) {
  if (xs.length === 0)
    return 0;
  let s = element_exports.Loci.size(xs[0]);
  for (let i = 1; i < xs.length; i++) {
    const t4 = element_exports.Loci.size(xs[i]);
    if (t4 < s)
      s = t4;
  }
  return s;
}

// node_modules/molstar/lib/mol-model/structure/structure/util/superposition-sifts-mapping.js
function alignAndSuperposeWithSIFTSMapping(structures, options) {
  var _a, _b;
  const indexMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < structures.length; i++) {
    buildIndex(structures[i], indexMap, i, (_a = options === null || options === void 0 ? void 0 : options.traceOnly) !== null && _a !== void 0 ? _a : true, (_b = options === null || options === void 0 ? void 0 : options.includeResidueTest) !== null && _b !== void 0 ? _b : _includeAllResidues);
  }
  const index2 = Array.from(indexMap.values());
  const pairs = findPairs(structures.length, index2);
  const zeroOverlapPairs = [];
  const failedPairs = [];
  const entries = [];
  for (const p of pairs) {
    if (p.count === 0) {
      zeroOverlapPairs.push([p.i, p.j]);
    } else {
      const [a4, b4] = getPositionTables(index2, p.i, p.j, p.count);
      const transform = MinimizeRmsd.compute({ a: a4, b: b4 });
      if (Number.isNaN(transform.rmsd)) {
        failedPairs.push([p.i, p.j]);
      } else {
        entries.push({ transform, pivot: p.i, other: p.j });
      }
    }
  }
  return { entries, zeroOverlapPairs, failedPairs };
}
function getPositionTables(index2, pivot, other, N) {
  const xs = MinimizeRmsd.Positions.empty(N);
  const ys = MinimizeRmsd.Positions.empty(N);
  let o = 0;
  for (const { pivots } of index2) {
    const a4 = pivots[pivot];
    const b4 = pivots[other];
    if (!a4 || !b4)
      continue;
    const l = Math.min(a4[2] - a4[1], b4[2] - b4[1]);
    for (let i = 0; i < l; i++) {
      let eI = a4[1] + i;
      xs.x[o] = a4[0].conformation.x(eI);
      xs.y[o] = a4[0].conformation.y(eI);
      xs.z[o] = a4[0].conformation.z(eI);
      eI = b4[1] + i;
      ys.x[o] = b4[0].conformation.x(eI);
      ys.y[o] = b4[0].conformation.y(eI);
      ys.z[o] = b4[0].conformation.z(eI);
      o++;
    }
  }
  return [xs, ys];
}
function findPairs(N, index2) {
  const pairwiseCounts = [];
  for (let i = 0; i < N; i++) {
    pairwiseCounts[i] = [];
    for (let j = 0; j < N; j++)
      pairwiseCounts[i][j] = 0;
  }
  for (const { pivots } of index2) {
    for (let i = 0; i < N; i++) {
      if (!pivots[i])
        continue;
      const lI = pivots[i][2] - pivots[i][1];
      for (let j = i + 1; j < N; j++) {
        if (!pivots[j])
          continue;
        const lJ = pivots[j][2] - pivots[j][1];
        pairwiseCounts[i][j] = pairwiseCounts[i][j] + Math.min(lI, lJ);
      }
    }
  }
  const ret = [];
  for (let j = 1; j < N; j++) {
    ret[j - 1] = { i: 0, j, count: pairwiseCounts[0][j] };
  }
  return ret;
}
function _includeAllResidues() {
  return true;
}
function buildIndex(structure, index2, sI, traceOnly, includeTest) {
  const loc = element_exports.Location.create(structure);
  for (const unit of structure.units) {
    if (unit.kind !== Unit.Kind.Atomic)
      continue;
    const { elements, model } = unit;
    loc.unit = unit;
    const map2 = SIFTSMapping.Provider.get(model).value;
    if (!map2)
      return;
    const { dbName, accession, num } = map2;
    const chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);
    const residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);
    const traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
    while (chainsIt.hasNext) {
      const chainSegment = chainsIt.move();
      residuesIt.setSegment(chainSegment);
      while (residuesIt.hasNext) {
        const residueSegment = residuesIt.move();
        const rI = residueSegment.index;
        if (!dbName[rI])
          continue;
        const traceElement = traceElementIndex[rI];
        let start2, end;
        if (traceOnly) {
          start2 = traceElement;
          if (start2 === -1)
            continue;
          end = start2 + 1;
        } else {
          start2 = elements[residueSegment.start];
          end = elements[residueSegment.end - 1] + 1;
        }
        loc.element = traceElement >= 0 ? traceElement : start2;
        if (!includeTest(loc, rI, start2, end))
          continue;
        const key = `${dbName[rI]}-${accession[rI]}-${num[rI]}`;
        if (!index2.has(key)) {
          index2.set(key, { key, pivots: { [sI]: [unit, start2, end] } });
        } else {
          const entry = index2.get(key);
          if (!entry.pivots[sI]) {
            entry.pivots[sI] = [unit, start2, end];
          }
        }
      }
    }
  }
}

// node_modules/molstar/lib/mol-plugin-ui/structure/superposition.js
var StructureSuperpositionControls = class extends CollapsableControls {
  defaultState() {
    return {
      isCollapsed: false,
      header: "Superposition",
      brand: { accent: "gray", svg: SuperpositionSvg },
      isHidden: true
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (sel) => {
      this.setState({ isHidden: sel.structures.length < 2 });
    });
  }
  renderControls() {
    return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children: (0, import_jsx_runtime13.jsx)(SuperpositionControls, {}) });
  }
};
var StructureSuperpositionParams = {
  alignSequences: ParamDefinition.Boolean(true, { isEssential: true, description: "For Chain-based 3D superposition, perform a sequence alignment and use the aligned residue pairs to guide the 3D superposition." }),
  traceOnly: ParamDefinition.Boolean(true, { description: "For Chain- and Uniprot-based 3D superposition, base superposition only on CA (and equivalent) atoms." })
};
var DefaultStructureSuperpositionOptions = ParamDefinition.getDefaultValues(StructureSuperpositionParams);
var SuperpositionTag = "SuperpositionTransform";
var SuperpositionControls = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isBusy: false,
      canUseDb: false,
      action: void 0,
      options: DefaultStructureSuperpositionOptions
    };
    this.superposeChains = async () => {
      var _a, _b, _c;
      const { query } = this.state.options.traceOnly ? StructureSelectionQueries.trace : StructureSelectionQueries.polymer;
      const entries = this.chainEntries;
      const locis = entries.map((e) => {
        const s = element_exports.Loci.toStructure(e.loci);
        const loci = StructureSelection.toLociWithSourceUnits(query(new QueryContext(s)));
        return element_exports.Loci.remap(loci, this.getRootStructure(e.loci.structure));
      });
      const pivot = this.plugin.managers.structure.hierarchy.findStructure((_a = locis[0]) === null || _a === void 0 ? void 0 : _a.structure);
      const coordinateSystem = (_c = (_b = pivot === null || pivot === void 0 ? void 0 : pivot.transform) === null || _b === void 0 ? void 0 : _b.cell.obj) === null || _c === void 0 ? void 0 : _c.data.coordinateSystem;
      const transforms = this.state.options.alignSequences ? alignAndSuperpose(locis) : superpose(locis);
      const eA = entries[0];
      for (let i = 1, il = locis.length; i < il; ++i) {
        const eB = entries[i];
        const { bTransform, rmsd } = transforms[i - 1];
        await this.transform(eB.cell, bTransform, coordinateSystem);
        const labelA = stripTags(eA.label);
        const labelB = stripTags(eB.label);
        this.plugin.log.info(`Superposed [${labelA}] and [${labelB}] with RMSD ${rmsd.toFixed(2)}.`);
      }
      await this.cameraReset();
    };
    this.superposeAtoms = async () => {
      var _a, _b, _c;
      const entries = this.atomEntries;
      const atomLocis = entries.map((e) => {
        return element_exports.Loci.remap(e.loci, this.getRootStructure(e.loci.structure));
      });
      const transforms = superpose(atomLocis);
      const pivot = this.plugin.managers.structure.hierarchy.findStructure((_a = atomLocis[0]) === null || _a === void 0 ? void 0 : _a.structure);
      const coordinateSystem = (_c = (_b = pivot === null || pivot === void 0 ? void 0 : pivot.transform) === null || _b === void 0 ? void 0 : _b.cell.obj) === null || _c === void 0 ? void 0 : _c.data.coordinateSystem;
      const eA = entries[0];
      for (let i = 1, il = atomLocis.length; i < il; ++i) {
        const eB = entries[i];
        const { bTransform, rmsd } = transforms[i - 1];
        await this.transform(eB.cell, bTransform, coordinateSystem);
        const labelA = stripTags(eA.label);
        const labelB = stripTags(eB.label);
        const count2 = entries[i].atoms.length;
        this.plugin.log.info(`Superposed ${count2} ${count2 === 1 ? "atom" : "atoms"} of [${labelA}] and [${labelB}] with RMSD ${rmsd.toFixed(2)}.`);
      }
      await this.cameraReset();
    };
    this.superposeDb = async () => {
      var _a, _b, _c;
      const input = this.plugin.managers.structure.hierarchy.behaviors.selection.value.structures;
      const traceOnly = this.state.options.traceOnly;
      const structures = input.map((s) => {
        var _a2;
        return (_a2 = s.cell.obj) === null || _a2 === void 0 ? void 0 : _a2.data;
      });
      const { entries, failedPairs, zeroOverlapPairs } = alignAndSuperposeWithSIFTSMapping(structures, { traceOnly });
      const coordinateSystem = (_c = (_b = (_a = input[0]) === null || _a === void 0 ? void 0 : _a.transform) === null || _b === void 0 ? void 0 : _b.cell.obj) === null || _c === void 0 ? void 0 : _c.data.coordinateSystem;
      let rmsd = 0;
      for (const xform of entries) {
        await this.transform(input[xform.other].cell, xform.transform.bTransform, coordinateSystem);
        rmsd += xform.transform.rmsd;
      }
      rmsd /= Math.max(entries.length - 1, 1);
      const formatPairs = (pairs) => {
        return `[${pairs.map(([i, j]) => `(${structures[i].models[0].entryId}, ${structures[j].models[0].entryId})`).join(", ")}]`;
      };
      if (zeroOverlapPairs.length) {
        this.plugin.log.warn(`Superposition: No UNIPROT mapping overlap between structures ${formatPairs(zeroOverlapPairs)}.`);
      }
      if (failedPairs.length) {
        this.plugin.log.error(`Superposition: Failed to superpose structures ${formatPairs(failedPairs)}.`);
      }
      if (entries.length) {
        this.plugin.log.info(`Superposed ${entries.length + 1} structures with avg. RMSD ${rmsd.toFixed(2)} .`);
        await this.cameraReset();
      }
    };
    this.toggleByChains = () => this.setState({ action: this.state.action === "byChains" ? void 0 : "byChains" });
    this.toggleByAtoms = () => this.setState({ action: this.state.action === "byAtoms" ? void 0 : "byAtoms" });
    this.toggleOptions = () => this.setState({ action: this.state.action === "options" ? void 0 : "options" });
    this.setOptions = (values2) => {
      this.setState({ options: values2 });
    };
  }
  componentDidMount() {
    this.subscribe(this.selection.events.changed, () => {
      this.forceUpdate();
    });
    this.subscribe(this.selection.events.additionsHistoryUpdated, () => {
      this.forceUpdate();
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (v2) => {
      this.setState({ isBusy: v2 });
    });
    this.subscribe(this.plugin.managers.structure.hierarchy.behaviors.selection, (sel) => {
      this.setState({ canUseDb: sel.structures.every((s) => {
        var _a;
        return !!((_a = s.cell.obj) === null || _a === void 0 ? void 0 : _a.data) && s.cell.obj.data.models.some((m) => SIFTSMapping.Provider.isApplicable(m));
      }) });
    });
  }
  get selection() {
    return this.plugin.managers.structure.selection;
  }
  async transform(s, matrix, coordinateSystem) {
    const r = StateObjectRef.resolveAndCheck(this.plugin.state.data, s);
    if (!r)
      return;
    const o = this.plugin.state.data.selectQ((q) => q.byRef(r.transform.ref).subtree().withTransformer(StateTransforms.Model.TransformStructureConformation))[0];
    const transform = coordinateSystem && !Mat4.isIdentity(coordinateSystem.matrix) ? Mat4.mul(Mat4(), coordinateSystem.matrix, matrix) : matrix;
    const params = {
      transform: {
        name: "matrix",
        params: { data: transform, transpose: false }
      }
    };
    const b4 = o ? this.plugin.state.data.build().to(o).update(params) : this.plugin.state.data.build().to(s).insert(StateTransforms.Model.TransformStructureConformation, params, { tags: SuperpositionTag });
    await this.plugin.runTask(this.plugin.state.data.updateTree(b4));
  }
  getRootStructure(s) {
    var _a;
    const parent = this.plugin.helpers.substructureParent.get(s);
    return (_a = this.plugin.state.data.selectQ((q) => q.byValue(parent).rootOfType(PluginStateObject.Molecule.Structure))[0].obj) === null || _a === void 0 ? void 0 : _a.data;
  }
  async cameraReset() {
    await new Promise((res) => requestAnimationFrame(res));
    PluginCommands.Camera.Reset(this.plugin);
  }
  highlight(loci) {
    this.plugin.managers.interactivity.lociHighlights.highlightOnly({ loci }, false);
  }
  moveHistory(e, direction) {
    this.plugin.managers.structure.selection.modifyHistory(e, direction, void 0, true);
  }
  focusLoci(loci) {
    this.plugin.managers.camera.focusLoci(loci);
  }
  lociEntry(e, idx) {
    return (0, import_jsx_runtime13.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime13.jsx)(Button, { noOverflow: true, title: "Click to focus. Hover to highlight.", onClick: () => this.focusLoci(e.loci), style: { width: "auto", textAlign: "left" }, onMouseEnter: () => this.highlight(e.loci), onMouseLeave: () => this.plugin.managers.interactivity.lociHighlights.clearHighlights(), children: (0, import_jsx_runtime13.jsx)("span", { dangerouslySetInnerHTML: { __html: e.label } }) }) }, idx);
  }
  historyEntry(e, idx) {
    const history = this.plugin.managers.structure.selection.additionsHistory;
    return (0, import_jsx_runtime13.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime13.jsxs)(Button, { noOverflow: true, title: "Click to focus. Hover to highlight.", onClick: () => this.focusLoci(e.loci), style: { width: "auto", textAlign: "left" }, onMouseEnter: () => this.highlight(e.loci), onMouseLeave: () => this.plugin.managers.interactivity.lociHighlights.clearHighlights(), children: [idx, ". ", (0, import_jsx_runtime13.jsx)("span", { dangerouslySetInnerHTML: { __html: e.label } })] }), history.length > 1 && (0, import_jsx_runtime13.jsx)(IconButton, { svg: ArrowUpwardSvg, small: true, className: "msp-form-control", onClick: () => this.moveHistory(e, "up"), flex: "20px", title: "Move up" }), history.length > 1 && (0, import_jsx_runtime13.jsx)(IconButton, { svg: ArrowDownwardSvg, small: true, className: "msp-form-control", onClick: () => this.moveHistory(e, "down"), flex: "20px", title: "Move down" }), (0, import_jsx_runtime13.jsx)(IconButton, { svg: DeleteOutlinedSvg, small: true, className: "msp-form-control", onClick: () => this.plugin.managers.structure.selection.modifyHistory(e, "remove"), flex: true, title: "Remove" })] }, e.id);
  }
  atomsLociEntry(e, idx) {
    return (0, import_jsx_runtime13.jsxs)("div", { children: [(0, import_jsx_runtime13.jsx)("div", { className: "msp-control-group-header", children: (0, import_jsx_runtime13.jsx)("div", { className: "msp-no-overflow", title: e.label, children: e.label }) }), (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset", children: e.atoms.map((h, i) => this.historyEntry(h, i)) })] }, idx);
  }
  get chainEntries() {
    const location = element_exports.Location.create();
    const entries = [];
    this.plugin.managers.structure.selection.entries.forEach(({ selection }, ref) => {
      const cell = StateObjectRef.resolveAndCheck(this.plugin.state.data, ref);
      if (!cell || element_exports.Loci.isEmpty(selection))
        return;
      const l = element_exports.Loci.getFirstLocation(selection, location);
      if (selection.elements.length > 1 || StructureProperties.entity.type(l) !== "polymer")
        return;
      const stats = element_exports.Stats.ofLoci(selection);
      const counts = structureElementStatsLabel(stats, { countsOnly: true });
      const chain = elementLabel(l, { reverse: true, granularity: "chain" }).split("|");
      const label = `${counts} | ${chain[0]} | ${chain[chain.length - 1]}`;
      entries.push({ loci: selection, label, cell });
    });
    return entries;
  }
  get atomEntries() {
    const structureEntries = /* @__PURE__ */ new Map();
    const history = this.plugin.managers.structure.selection.additionsHistory;
    for (let i = 0, il = history.length; i < il; ++i) {
      const e = history[i];
      if (element_exports.Loci.size(e.loci) !== 1)
        continue;
      const k = e.loci.structure;
      if (structureEntries.has(k))
        structureEntries.get(k).push(e);
      else
        structureEntries.set(k, [e]);
    }
    const entries = [];
    structureEntries.forEach((atoms, structure) => {
      const cell = this.plugin.helpers.substructureParent.get(structure);
      const elements = [];
      for (let i = 0, il = atoms.length; i < il; ++i) {
        elements.push(atoms[i].loci.elements[0]);
      }
      const loci = element_exports.Loci(atoms[0].loci.structure, elements);
      const label = loci.structure.label.split(" | ")[0];
      entries.push({ loci, label, cell, atoms });
    });
    return entries;
  }
  toggleHint() {
    const shouldShowToggleHint = this.plugin.config.get(PluginConfig.Viewport.ShowSelectionMode);
    return shouldShowToggleHint ? (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [" ", "(toggle ", (0, import_jsx_runtime13.jsx)(ToggleSelectionModeButton, { inline: true }), " mode)"] }) : null;
  }
  addByChains() {
    const entries = this.chainEntries;
    return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [entries.length > 0 && (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset", children: entries.map((e, i) => this.lociEntry(e, i)) }), entries.length < 2 && (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset msp-help-text", children: (0, import_jsx_runtime13.jsxs)("div", { className: "msp-help-description", children: [(0, import_jsx_runtime13.jsx)(Icon, { svg: HelpOutlineSvg, inline: true }), "Add 2 or more selections", this.toggleHint(), " from separate structures. Selections must be limited to single polymer chains or residues therein."] }) }), entries.length > 1 && (0, import_jsx_runtime13.jsx)(Button, { title: "Superpose structures by selected chains.", className: "msp-btn-commit msp-btn-commit-on", onClick: this.superposeChains, style: { marginTop: "1px" }, children: "Superpose" })] });
  }
  addByAtoms() {
    const entries = this.atomEntries;
    return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [entries.length > 0 && (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset", children: entries.map((e, i) => this.atomsLociEntry(e, i)) }), entries.length < 2 && (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset msp-help-text", children: (0, import_jsx_runtime13.jsxs)("div", { className: "msp-help-description", children: [(0, import_jsx_runtime13.jsx)(Icon, { svg: HelpOutlineSvg, inline: true }), "Add 1 or more selections", this.toggleHint(), " from separate structures. Selections must be limited to single atoms."] }) }), entries.length > 1 && (0, import_jsx_runtime13.jsx)(Button, { title: "Superpose structures by selected atoms.", className: "msp-btn-commit msp-btn-commit-on", onClick: this.superposeAtoms, style: { marginTop: "1px" }, children: "Superpose" })] });
  }
  superposeByDbMapping() {
    return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children: (0, import_jsx_runtime13.jsx)(Button, { icon: SuperposeChainsSvg, title: "Superpose structures using intersection of residues from SIFTS UNIPROT mapping.", className: "msp-btn msp-btn-block", onClick: this.superposeDb, style: { marginTop: "1px" }, disabled: this.state.isBusy, children: "Uniprot" }) });
  }
  render() {
    return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [(0, import_jsx_runtime13.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime13.jsx)(ToggleButton, { icon: SuperposeChainsSvg, label: "Chains", toggle: this.toggleByChains, isSelected: this.state.action === "byChains", disabled: this.state.isBusy }), (0, import_jsx_runtime13.jsx)(ToggleButton, { icon: SuperposeAtomsSvg, label: "Atoms", toggle: this.toggleByAtoms, isSelected: this.state.action === "byAtoms", disabled: this.state.isBusy }), this.state.canUseDb && this.superposeByDbMapping(), (0, import_jsx_runtime13.jsx)(ToggleButton, { icon: TuneSvg, label: "", title: "Options", toggle: this.toggleOptions, isSelected: this.state.action === "options", disabled: this.state.isBusy, style: { flex: "0 0 40px", padding: 0 } })] }), this.state.action === "byChains" && this.addByChains(), this.state.action === "byAtoms" && this.addByAtoms(), this.state.action === "options" && (0, import_jsx_runtime13.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime13.jsx)(ParameterControls, { params: StructureSuperpositionParams, values: this.state.options, onChangeValues: this.setOptions, isDisabled: this.state.isBusy }) })] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/structure/quick-styles.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var StructureQuickStylesControls = class extends CollapsableControls {
  defaultState() {
    return {
      isCollapsed: false,
      header: "Quick Styles",
      brand: { accent: "gray", svg: MagicWandSvg }
    };
  }
  renderControls() {
    return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: (0, import_jsx_runtime14.jsx)(QuickStyles, {}) });
  }
};
var QuickStyles = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { busy: false, style: "default" };
  }
  async applyRepresentation(preset) {
    this.setState({ busy: true });
    await applyRepresentationPreset(this.plugin, preset);
    await applyStyle(this.plugin, this.state.style);
    this.setState({ busy: false });
  }
  async applyStyle(style) {
    this.setState({ busy: true });
    await applyStyle(this.plugin, style);
    this.setState({ busy: false, style });
  }
  render() {
    return (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [(0, import_jsx_runtime14.jsx)(NoncollapsableGroup, { title: "Apply Representation", children: (0, import_jsx_runtime14.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime14.jsx)(Button, { title: "Applies default representation preset (depends on structure size)", onClick: () => this.applyRepresentation("default"), disabled: this.state.busy, children: "Default" }), (0, import_jsx_runtime14.jsx)(Button, { title: "Applies cartoon polymer and ball-and-stick ligand representation preset", onClick: () => this.applyRepresentation("cartoon"), disabled: this.state.busy, children: "Cartoon" }), (0, import_jsx_runtime14.jsx)(Button, { title: "Applies spacefill representation preset", onClick: () => this.applyRepresentation("spacefill"), disabled: this.state.busy, children: "Spacefill" }), (0, import_jsx_runtime14.jsx)(Button, { title: "Applies molecular surface representation preset", onClick: () => this.applyRepresentation("surface"), disabled: this.state.busy, children: "Surface" })] }) }), (0, import_jsx_runtime14.jsx)(NoncollapsableGroup, { title: "Apply Style", children: (0, import_jsx_runtime14.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime14.jsx)(Button, { title: "Applies default appearance (no outline, no ignore-light)", onClick: () => this.applyStyle("default"), disabled: this.state.busy, children: "Default" }), (0, import_jsx_runtime14.jsx)(Button, { title: "Applies illustrative appearance (outline, ignore-light)", onClick: () => this.applyStyle("illustrative"), disabled: this.state.busy, children: "Illustrative" })] }) })] });
  }
};
function NoncollapsableGroup(props) {
  return (0, import_jsx_runtime14.jsxs)("div", { className: "msp-control-group-wrapper", children: [(0, import_jsx_runtime14.jsx)("div", { className: "msp-control-group-header", children: (0, import_jsx_runtime14.jsx)("div", { children: (0, import_jsx_runtime14.jsx)("b", { children: props.title }) }) }), props.children] });
}
async function applyRepresentationPreset(plugin, preset) {
  const { structures } = plugin.managers.structure.hierarchy.selection;
  switch (preset) {
    case "default":
      const defaultPreset2 = plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
      const provider = plugin.builders.structure.representation.resolveProvider(defaultPreset2);
      await plugin.managers.structure.component.applyPreset(structures, provider);
      break;
    case "spacefill":
      await plugin.managers.structure.component.applyPreset(structures, PresetStructureRepresentations.illustrative);
      break;
    case "cartoon":
      await plugin.managers.structure.component.applyPreset(structures, PresetStructureRepresentations["polymer-and-ligand"]);
      break;
    case "surface":
      await plugin.managers.structure.component.applyPreset(structures, PresetStructureRepresentations["molecular-surface"]);
      break;
  }
}
async function applyStyle(plugin, style) {
  if (style === "default") {
    await plugin.managers.structure.component.setOptions({ ...plugin.managers.structure.component.state.options, ignoreLight: false });
    if (plugin.canvas3d) {
      const p = ParamDefinition.getDefaultValues(PostprocessingParams);
      plugin.canvas3d.setProps({
        postprocessing: { outline: p.outline, occlusion: p.occlusion, shadow: p.shadow }
      });
    }
  }
  if (style === "illustrative") {
    await plugin.managers.structure.component.setOptions({ ...plugin.managers.structure.component.state.options, ignoreLight: true });
    if (plugin.canvas3d) {
      const pp = plugin.canvas3d.props.postprocessing;
      plugin.canvas3d.setProps({
        postprocessing: {
          outline: {
            name: "on",
            params: pp.outline.name === "on" ? pp.outline.params : {
              scale: 1,
              color: Color(0),
              threshold: 0.33,
              includeTransparent: true
            }
          },
          occlusion: {
            name: "on",
            params: pp.occlusion.name === "on" ? pp.occlusion.params : {
              multiScale: { name: "off", params: {} },
              radius: 5,
              bias: 0.8,
              blurKernelSize: 15,
              blurDepthBias: 0.5,
              samples: 32,
              resolutionScale: 1,
              color: Color(0),
              transparentThreshold: 0.4
            }
          },
          shadow: { name: "off", params: {} }
        }
      });
    }
  }
}

// node_modules/molstar/lib/mol-plugin-ui/controls.js
var TrajectoryViewportControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { show: false, label: "" };
    this.update = () => {
      const state = this.plugin.state.data;
      const models = state.selectQ((q) => q.ofTransformer(StateTransforms.Model.ModelFromTrajectory));
      if (models.length === 0) {
        this.setState({ show: false });
        return;
      }
      let label = "", count2 = 0;
      const parents = /* @__PURE__ */ new Set();
      for (const m of models) {
        if (!m.sourceRef)
          continue;
        const parent = state.cells.get(m.sourceRef).obj;
        if (!parent)
          continue;
        if (parent.data.frameCount > 1) {
          if (parents.has(m.sourceRef)) {
            this.setState({ show: false });
            return;
          }
          parents.add(m.sourceRef);
          count2++;
          if (!label) {
            const idx = m.transform.params.modelIndex;
            label = `Model ${idx + 1} / ${parent.data.frameCount}`;
          }
        }
      }
      if (count2 > 1)
        label = "";
      this.setState({ show: count2 > 0, label });
    };
    this.reset = () => PluginCommands.State.ApplyAction(this.plugin, {
      state: this.plugin.state.data,
      action: UpdateTrajectory.create({ action: "reset" })
    });
    this.prev = () => PluginCommands.State.ApplyAction(this.plugin, {
      state: this.plugin.state.data,
      action: UpdateTrajectory.create({ action: "advance", by: -1 })
    });
    this.next = () => PluginCommands.State.ApplyAction(this.plugin, {
      state: this.plugin.state.data,
      action: UpdateTrajectory.create({ action: "advance", by: 1 })
    });
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.data.events.changed, this.update);
    this.subscribe(this.plugin.behaviors.state.isAnimating, this.update);
  }
  render() {
    const isAnimating = this.plugin.behaviors.state.isAnimating.value;
    if (!this.state.show || isAnimating && !this.state.label || !this.plugin.config.get(PluginConfig.Viewport.ShowTrajectoryControls))
      return null;
    return (0, import_jsx_runtime15.jsxs)("div", { className: "msp-traj-controls", children: [!isAnimating && (0, import_jsx_runtime15.jsx)(IconButton, { svg: SkipPreviousSvg, title: "First Model", onClick: this.reset, disabled: isAnimating }), !isAnimating && (0, import_jsx_runtime15.jsx)(IconButton, { svg: NavigateBeforeSvg, title: "Previous Model", onClick: this.prev, disabled: isAnimating }), !isAnimating && (0, import_jsx_runtime15.jsx)(IconButton, { svg: NavigateNextSvg, title: "Next Model", onClick: this.next, disabled: isAnimating }), !!this.state.label && (0, import_jsx_runtime15.jsx)("span", { children: this.state.label })] });
  }
};
var StateSnapshotViewportControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { isBusy: false, show: true };
    this.keyUp = (e) => {
      if (!e.ctrlKey || this.state.isBusy || e.target !== document.body)
        return;
      const snapshots = this.plugin.managers.snapshot;
      if (e.keyCode === 37 || e.key === "ArrowLeft") {
        if (snapshots.state.isPlaying)
          snapshots.stop();
        this.prev();
      } else if (e.keyCode === 38 || e.key === "ArrowUp") {
        if (snapshots.state.isPlaying)
          snapshots.stop();
        if (snapshots.state.entries.size === 0)
          return;
        const e2 = snapshots.state.entries.get(0);
        this.update(e2.snapshot.id);
      } else if (e.keyCode === 39 || e.key === "ArrowRight") {
        if (snapshots.state.isPlaying)
          snapshots.stop();
        this.next();
      } else if (e.keyCode === 40 || e.key === "ArrowDown") {
        if (snapshots.state.isPlaying)
          snapshots.stop();
        if (snapshots.state.entries.size === 0)
          return;
        const e2 = snapshots.state.entries.get(snapshots.state.entries.size - 1);
        this.update(e2.snapshot.id);
      }
    };
    this.change = (e) => {
      if (e.target.value === "none")
        return;
      this.update(e.target.value);
    };
    this.prev = () => {
      const s = this.plugin.managers.snapshot;
      const id = s.getNextId(s.state.current, -1);
      if (id)
        this.update(id);
    };
    this.next = () => {
      const s = this.plugin.managers.snapshot;
      const id = s.getNextId(s.state.current, 1);
      if (id)
        this.update(id);
    };
    this.togglePlay = () => {
      this.plugin.managers.snapshot.togglePlay();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.snapshot.events.changed, () => this.forceUpdate());
    this.subscribe(this.plugin.behaviors.state.isBusy, (isBusy) => this.setState({ isBusy }));
    this.subscribe(this.plugin.behaviors.state.isAnimating, (isBusy) => this.setState({ isBusy }));
    window.addEventListener("keyup", this.keyUp, false);
  }
  componentWillUnmount() {
    super.componentWillUnmount();
    window.removeEventListener("keyup", this.keyUp, false);
  }
  async update(id) {
    this.setState({ isBusy: true });
    await PluginCommands.State.Snapshots.Apply(this.plugin, { id });
    this.setState({ isBusy: false });
  }
  render() {
    const snapshots = this.plugin.managers.snapshot;
    const count2 = snapshots.state.entries.size;
    if (count2 < 2 || !this.state.show) {
      return null;
    }
    const current = snapshots.state.current;
    const isPlaying = snapshots.state.isPlaying;
    return (0, import_jsx_runtime15.jsxs)("div", { className: "msp-state-snapshot-viewport-controls", children: [(0, import_jsx_runtime15.jsxs)("select", { className: "msp-form-control", value: current || "none", onChange: this.change, disabled: this.state.isBusy || isPlaying, children: [!current && (0, import_jsx_runtime15.jsx)("option", { value: "none" }, "none"), snapshots.state.entries.valueSeq().map((e, i) => (0, import_jsx_runtime15.jsxs)("option", { value: e.snapshot.id, children: [`[${i + 1}/${count2}]`, " ", e.name || new Date(e.timestamp).toLocaleString()] }, e.snapshot.id))] }), (0, import_jsx_runtime15.jsx)(IconButton, { svg: isPlaying ? StopSvg : PlayArrowSvg, title: isPlaying ? "Pause" : "Cycle States", onClick: this.togglePlay, disabled: isPlaying ? false : this.state.isBusy }), !isPlaying && (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [(0, import_jsx_runtime15.jsx)(IconButton, { svg: NavigateBeforeSvg, title: "Previous State", onClick: this.prev, disabled: this.state.isBusy || isPlaying }), (0, import_jsx_runtime15.jsx)(IconButton, { svg: NavigateNextSvg, title: "Next State", onClick: this.next, disabled: this.state.isBusy || isPlaying })] })] });
  }
};
function ViewportSnapshotDescription() {
  var _a;
  const plugin = React3.useContext(PluginReactContext);
  const [_, setV] = React3.useState(0);
  React3.useEffect(() => {
    const sub = plugin.managers.snapshot.events.changed.subscribe(() => setV((v2) => v2 + 1));
    return () => sub.unsubscribe();
  }, [plugin]);
  const current = plugin.managers.snapshot.state.current;
  if (!current)
    return null;
  const e = plugin.managers.snapshot.getEntry(current);
  if (!((_a = e === null || e === void 0 ? void 0 : e.description) === null || _a === void 0 ? void 0 : _a.trim()))
    return null;
  return (0, import_jsx_runtime15.jsx)("div", { id: "snapinfo", className: "msp-snapshot-description-wrapper", children: e.descriptionFormat === "plaintext" && e.description || (0, import_jsx_runtime15.jsx)(Markdown, { skipHtml: true, components: { a: MarkdownAnchor }, children: e.description }) });
}
function MarkdownAnchor({ href, children, element: element3 }) {
  const plugin = React3.useContext(PluginReactContext);
  if (!href)
    return element3;
  if (href[0] === "#") {
    return (0, import_jsx_runtime15.jsx)("a", { href: "#", onClick: (e) => {
      e.preventDefault();
      plugin.managers.snapshot.applyKey(href.substring(1));
    }, children });
  } else if (href) {
    return (0, import_jsx_runtime15.jsx)("a", { href, target: "_blank", rel: "noopener noreferrer", children });
  }
  return children;
}
var AnimationViewportControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { isEmpty: true, isExpanded: false, isBusy: false, isAnimating: false, isPlaying: false };
    this.toggleExpanded = () => this.setState({ isExpanded: !this.state.isExpanded });
    this.stop = () => {
      this.plugin.managers.animation.stop();
      this.plugin.managers.snapshot.stop();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.snapshot.events.changed, () => {
      if (this.plugin.managers.snapshot.state.isPlaying)
        this.setState({ isPlaying: true, isExpanded: false });
      else
        this.setState({ isPlaying: false });
    });
    this.subscribe(this.plugin.behaviors.state.isBusy, (isBusy) => {
      if (isBusy)
        this.setState({ isBusy: true, isExpanded: false, isEmpty: this.plugin.state.data.tree.transforms.size < 2 });
      else
        this.setState({ isBusy: false, isEmpty: this.plugin.state.data.tree.transforms.size < 2 });
    });
    this.subscribe(this.plugin.behaviors.state.isAnimating, (isAnimating) => {
      if (isAnimating)
        this.setState({ isAnimating: true, isExpanded: false });
      else
        this.setState({ isAnimating: false });
    });
  }
  render() {
    const isPlaying = this.plugin.managers.snapshot.state.isPlaying;
    if (isPlaying || this.state.isEmpty || this.plugin.managers.animation.isEmpty || !this.plugin.config.get(PluginConfig.Viewport.ShowAnimation))
      return null;
    const isAnimating = this.state.isAnimating;
    return (0, import_jsx_runtime15.jsxs)("div", { className: "msp-animation-viewport-controls", children: [(0, import_jsx_runtime15.jsxs)("div", { children: [(0, import_jsx_runtime15.jsx)("div", { className: "msp-semi-transparent-background" }), (0, import_jsx_runtime15.jsx)(IconButton, { svg: isAnimating || isPlaying ? StopSvg : SubscriptionsOutlinedSvg, transparent: true, title: isAnimating ? "Stop" : "Select Animation", onClick: isAnimating || isPlaying ? this.stop : this.toggleExpanded, toggleState: this.state.isExpanded, disabled: isAnimating || isPlaying ? false : this.state.isBusy || this.state.isPlaying || this.state.isEmpty })] }), this.state.isExpanded && !this.state.isBusy && (0, import_jsx_runtime15.jsx)("div", { className: "msp-animation-viewport-controls-select", children: (0, import_jsx_runtime15.jsx)(AnimationControls, { onStart: this.toggleExpanded }) })] });
  }
};
var SelectionViewportControls = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.behaviors.interaction.selectionMode, () => this.forceUpdate());
  }
  render() {
    if (!this.plugin.selectionMode)
      return null;
    return (0, import_jsx_runtime15.jsx)("div", { className: "msp-selection-viewport-controls", children: (0, import_jsx_runtime15.jsx)(StructureSelectionActionsControls, {}) });
  }
};
var LociLabels = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { labels: [] };
  }
  componentDidMount() {
    this.subscribe(this.plugin.behaviors.labels.highlight, (e) => this.setState({ labels: e.labels }));
  }
  render() {
    if (this.state.labels.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime15.jsx)("div", { className: "msp-highlight-info", children: this.state.labels.map((e, i) => {
      if (e.indexOf("\n") >= 0) {
        return (0, import_jsx_runtime15.jsx)("div", { className: "msp-highlight-markdown-row", children: (0, import_jsx_runtime15.jsx)(Markdown, { skipHtml: true, children: e }) }, "" + i);
      }
      return (0, import_jsx_runtime15.jsx)("div", { className: "msp-highlight-simple-row", dangerouslySetInnerHTML: { __html: e } }, "" + i);
    }) });
  }
};
var CustomStructureControls = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.state.behaviors.events.changed, () => this.forceUpdate());
  }
  render() {
    const controls = [];
    this.plugin.customStructureControls.forEach((Controls, key) => {
      controls.push((0, import_jsx_runtime15.jsx)(Controls, { initiallyCollapsed: this.props.initiallyCollapsed }, key));
    });
    return controls.length > 0 ? (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: controls }) : null;
  }
};
var DefaultStructureTools = class extends PluginUIComponent {
  render() {
    return (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [(0, import_jsx_runtime15.jsxs)("div", { className: "msp-section-header", children: [(0, import_jsx_runtime15.jsx)(Icon, { svg: BuildSvg }), "Structure Tools"] }), (0, import_jsx_runtime15.jsx)(StructureSourceControls, {}), (0, import_jsx_runtime15.jsx)(StructureMeasurementsControls, {}), (0, import_jsx_runtime15.jsx)(StructureSuperpositionControls, {}), (0, import_jsx_runtime15.jsx)(StructureQuickStylesControls, {}), (0, import_jsx_runtime15.jsx)(StructureComponentControls, {}), this.plugin.config.get(PluginConfig.VolumeStreaming.Enabled) && (0, import_jsx_runtime15.jsx)(VolumeStreamingControls, {}), (0, import_jsx_runtime15.jsx)(VolumeSourceControls, {}), (0, import_jsx_runtime15.jsx)(CustomStructureControls, {})] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/left-panel.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-ui/state/actions.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var StateObjectActions = class extends PluginUIComponent {
  get current() {
    return this.props.state.behaviors.currentObject.value;
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.object.updated, ({ ref, state }) => {
      const current = this.current;
      if (current.ref !== ref || current.state !== state)
        return;
      this.forceUpdate();
    });
    this.subscribe(this.plugin.state.data.actions.events.added, () => this.forceUpdate());
    this.subscribe(this.plugin.state.data.actions.events.removed, () => this.forceUpdate());
  }
  render() {
    const { state, nodeRef: ref } = this.props;
    const cell = state.cells.get(ref);
    const actions = state.actions.fromCell(cell, this.plugin);
    if (actions.length === 0)
      return null;
    const def = cell.transform.transformer.definition;
    const display = cell.obj ? cell.obj.label : def.display && def.display.name || def.name;
    return (0, import_jsx_runtime16.jsxs)("div", { className: "msp-state-actions", children: [!this.props.hideHeader && (0, import_jsx_runtime16.jsxs)("div", { className: "msp-section-header", children: [(0, import_jsx_runtime16.jsx)(Icon, { svg: CodeSvg }), " ", `Actions (${display})`] }), actions.map((act, i) => (0, import_jsx_runtime16.jsx)(ApplyActionControl, { state, action: act, nodeRef: ref, initiallyCollapsed: i === 0 ? !this.props.alwaysExpandFirst && this.props.initiallyCollapsed : this.props.initiallyCollapsed }, `${act.id}`))] });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/state/snapshots.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var React4 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin/state.js
var PluginState = class _PluginState extends PluginComponent {
  get animation() {
    return this.plugin.managers.animation;
  }
  getSnapshot(params) {
    var _a, _b, _c;
    const p = { ...this.snapshotParams.value, ...params };
    return {
      id: UUID.create22(),
      data: p.data ? this.data.getSnapshot() : void 0,
      behaviour: p.behavior ? this.behaviors.getSnapshot() : void 0,
      animation: p.animation ? this.animation.getSnapshot() : void 0,
      startAnimation: p.startAnimation ? !!p.startAnimation : void 0,
      camera: p.camera ? {
        current: this.plugin.canvas3d.camera.getSnapshot(),
        transitionStyle: p.cameraTransition.name,
        transitionDurationInMs: ((_a = p === null || p === void 0 ? void 0 : p.cameraTransition) === null || _a === void 0 ? void 0 : _a.name) === "animate" ? p.cameraTransition.params.durationInMs : void 0
      } : void 0,
      canvas3dContext: p.canvas3dContext ? { props: (_b = this.plugin.canvas3dContext) === null || _b === void 0 ? void 0 : _b.props } : void 0,
      canvas3d: p.canvas3d ? { props: (_c = this.plugin.canvas3d) === null || _c === void 0 ? void 0 : _c.props } : void 0,
      interactivity: p.interactivity ? { props: this.plugin.managers.interactivity.props } : void 0,
      structureFocus: this.plugin.managers.structure.focus.getSnapshot(),
      structureSelection: p.structureSelection ? this.plugin.managers.structure.selection.getSnapshot() : void 0,
      structureComponentManager: p.componentManager ? {
        options: this.plugin.managers.structure.component.state.options
      } : void 0,
      durationInMs: p === null || p === void 0 ? void 0 : p.durationInMs
    };
  }
  async setSnapshot(snapshot) {
    var _a, _b, _c, _d, _e, _f, _g;
    await this.animation.stop();
    if ((_a = snapshot.structureComponentManager) === null || _a === void 0 ? void 0 : _a.options)
      this.plugin.managers.structure.component._setSnapshotState((_b = snapshot.structureComponentManager) === null || _b === void 0 ? void 0 : _b.options);
    if (snapshot.behaviour)
      await this.plugin.runTask(this.behaviors.setSnapshot(snapshot.behaviour));
    if (snapshot.data)
      await this.plugin.runTask(this.data.setSnapshot(snapshot.data));
    if ((_c = snapshot.canvas3d) === null || _c === void 0 ? void 0 : _c.props) {
      const settings = ParamDefinition.normalizeParams(Canvas3DParams, snapshot.canvas3d.props, "children");
      await PluginCommands.Canvas3D.SetSettings(this.plugin, { settings });
    }
    if ((_d = snapshot.canvas3dContext) === null || _d === void 0 ? void 0 : _d.props) {
      const props = ParamDefinition.normalizeParams(Canvas3DContext.Params, snapshot.canvas3dContext.props, "children");
      (_e = this.plugin.canvas3dContext) === null || _e === void 0 ? void 0 : _e.setProps(props);
    }
    if (snapshot.interactivity) {
      if (snapshot.interactivity.props)
        this.plugin.managers.interactivity.setProps(snapshot.interactivity.props);
    }
    if (snapshot.structureFocus) {
      this.plugin.managers.structure.focus.setSnapshot(snapshot.structureFocus);
    }
    if (snapshot.structureSelection) {
      this.plugin.managers.structure.selection.setSnapshot(snapshot.structureSelection);
    }
    if (snapshot.animation) {
      this.animation.setSnapshot(snapshot.animation);
    }
    if ((_f = snapshot.camera) === null || _f === void 0 ? void 0 : _f.current) {
      PluginCommands.Camera.Reset(this.plugin, {
        snapshot: snapshot.camera.current,
        durationMs: snapshot.camera.transitionStyle === "animate" ? snapshot.camera.transitionDurationInMs : void 0
      });
    } else if ((_g = snapshot.camera) === null || _g === void 0 ? void 0 : _g.focus) {
      PluginCommands.Camera.FocusObject(this.plugin, {
        ...snapshot.camera.focus,
        durationMs: snapshot.camera.transitionStyle === "animate" ? snapshot.camera.transitionDurationInMs : void 0
      });
    }
    if (snapshot.startAnimation) {
      this.animation.start();
    }
  }
  updateTransform(state, a4, params, canUndo) {
    const tree = state.build().to(a4).update(params);
    return PluginCommands.State.Update(this.plugin, { state, tree, options: { canUndo } });
  }
  hasBehavior(behavior) {
    return this.behaviors.tree.transforms.has(behavior.id);
  }
  updateBehavior(behavior, params) {
    const tree = this.behaviors.build();
    if (!this.behaviors.tree.transforms.has(behavior.id)) {
      const defaultParams = behavior.createDefaultParams(void 0, this.plugin);
      tree.to(PluginBehavior.getCategoryId(behavior)).apply(behavior, produce(defaultParams, params), { ref: behavior.id });
    } else {
      tree.to(behavior.id).update(params);
    }
    return this.plugin.runTask(this.behaviors.updateTree(tree));
  }
  dispose() {
    this.behaviors.cells.forEach((cell) => {
      var _a, _b, _c, _d;
      if (PluginBehavior.Behavior.is(cell.obj)) {
        (_b = (_a = cell.obj.data).unregister) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = cell.obj.data).dispose) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
    });
    super.dispose();
    this.data.dispose();
    this.behaviors.dispose();
    this.animation.dispose();
  }
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.data = State.create(new PluginStateObject.Root({}), { runTask: this.plugin.runTask, globalContext: this.plugin, historyCapacity: this.plugin.config.get(PluginConfig.State.HistoryCapacity) });
    this.behaviors = State.create(new PluginBehavior.Root({}), { runTask: this.plugin.runTask, globalContext: this.plugin, rootState: { isLocked: true } });
    this.events = {
      cell: {
        stateUpdated: merge(this.data.events.cell.stateUpdated, this.behaviors.events.cell.stateUpdated),
        created: merge(this.data.events.cell.created, this.behaviors.events.cell.created),
        removed: merge(this.data.events.cell.removed, this.behaviors.events.cell.removed)
      },
      object: {
        created: merge(this.data.events.object.created, this.behaviors.events.object.created),
        removed: merge(this.data.events.object.removed, this.behaviors.events.object.removed),
        updated: merge(this.data.events.object.updated, this.behaviors.events.object.updated)
      }
    };
    this.snapshotParams = this.ev.behavior(_PluginState.DefaultSnapshotParams);
    this.setSnapshotParams = (params) => {
      this.snapshotParams.next({ ..._PluginState.DefaultSnapshotParams, ...params });
    };
  }
};
(function(PluginState2) {
  PluginState2.SnapshotParams = {
    durationInMs: ParamDefinition.Numeric(1500, { min: 100, max: 15e3, step: 100 }, { label: "Duration in ms" }),
    data: ParamDefinition.Boolean(true),
    behavior: ParamDefinition.Boolean(false),
    structureSelection: ParamDefinition.Boolean(false),
    componentManager: ParamDefinition.Boolean(true),
    animation: ParamDefinition.Boolean(true),
    startAnimation: ParamDefinition.Boolean(false),
    canvas3d: ParamDefinition.Boolean(true),
    canvas3dContext: ParamDefinition.Boolean(true),
    interactivity: ParamDefinition.Boolean(true),
    camera: ParamDefinition.Boolean(true),
    cameraTransition: ParamDefinition.MappedStatic("animate", {
      animate: ParamDefinition.Group({
        durationInMs: ParamDefinition.Numeric(250, { min: 100, max: 5e3, step: 500 }, { label: "Duration in ms" })
      }),
      instant: ParamDefinition.Group({})
    }, { options: [["animate", "Animate"], ["instant", "Instant"]] }),
    image: ParamDefinition.Boolean(false)
  };
  PluginState2.DefaultSnapshotParams = ParamDefinition.getDefaultValues(PluginState2.SnapshotParams);
})(PluginState || (PluginState = {}));

// node_modules/molstar/lib/mol-plugin-ui/state/snapshots.js
var StateSnapshots = class extends PluginUIComponent {
  render() {
    var _a;
    return (0, import_jsx_runtime17.jsxs)("div", { children: [(0, import_jsx_runtime17.jsx)(SectionHeader, { icon: SaveOutlinedSvg, title: "Plugin State" }), (0, import_jsx_runtime17.jsx)("div", { style: { marginBottom: "10px" }, children: (0, import_jsx_runtime17.jsx)(ExpandGroup, { header: "Save Options", initiallyExpanded: false, children: (0, import_jsx_runtime17.jsx)(LocalStateSnapshotParams, {}) }) }), (0, import_jsx_runtime17.jsx)(LocalStateSnapshots, {}), (0, import_jsx_runtime17.jsx)(LocalStateSnapshotList, {}), (0, import_jsx_runtime17.jsx)(SectionHeader, { title: "Save as File", accent: "blue" }), (0, import_jsx_runtime17.jsx)(StateExportImportControls, {}), ((_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.remoteState) !== "none" && (0, import_jsx_runtime17.jsx)(RemoteStateSnapshots, {})] });
  }
};
var StateExportImportControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.downloadToFileJson = () => {
      var _a, _b;
      (_b = (_a = this.props).onAction) === null || _b === void 0 ? void 0 : _b.call(_a);
      PluginCommands.State.Snapshots.DownloadToFile(this.plugin, { type: "json" });
    };
    this.downloadToFileZip = () => {
      var _a, _b;
      (_b = (_a = this.props).onAction) === null || _b === void 0 ? void 0 : _b.call(_a);
      PluginCommands.State.Snapshots.DownloadToFile(this.plugin, { type: "zip" });
    };
    this.open = (e) => {
      var _a, _b;
      if (!e.target.files || !e.target.files[0]) {
        this.plugin.log.error("No state file selected");
        return;
      }
      (_b = (_a = this.props).onAction) === null || _b === void 0 ? void 0 : _b.call(_a);
      PluginCommands.State.Snapshots.OpenFile(this.plugin, { file: e.target.files[0] });
    };
  }
  render() {
    return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime17.jsx)(Button, { icon: GetAppSvg, onClick: this.downloadToFileJson, title: "Save the state description. Input data are loaded using the provided sources. Does not work if local files are used as input.", children: "State" }), (0, import_jsx_runtime17.jsx)(Button, { icon: GetAppSvg, onClick: this.downloadToFileZip, title: "Save the state including the input data.", children: "Session" }), (0, import_jsx_runtime17.jsxs)("div", { className: "msp-btn msp-btn-block msp-btn-action msp-loader-msp-btn-file", children: [(0, import_jsx_runtime17.jsx)(Icon, { svg: OpenInBrowserSvg, inline: true }), " Open ", (0, import_jsx_runtime17.jsx)("input", { onChange: this.open, type: "file", multiple: false, accept: ".molx,.molj" })] })] }), (0, import_jsx_runtime17.jsxs)("div", { className: "msp-help-text", style: { padding: "10px" }, children: [(0, import_jsx_runtime17.jsx)(Icon, { svg: WarningSvg }), " This is an experimental feature and stored states/sessions might not be openable in a future version."] })] });
  }
};
var LocalStateSnapshotParams = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.state.snapshotParams, () => this.forceUpdate());
  }
  render() {
    return (0, import_jsx_runtime17.jsx)(ParameterControls, { params: PluginState.SnapshotParams, values: this.plugin.state.snapshotParams.value, onChangeValues: this.plugin.state.setSnapshotParams });
  }
};
var LocalStateSnapshots = class _LocalStateSnapshots extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { params: ParamDefinition.getDefaultValues(_LocalStateSnapshots.Params) };
    this.add = () => {
      PluginCommands.State.Snapshots.Add(this.plugin, {
        name: this.state.params.name,
        description: this.state.params.description
      });
    };
    this.updateParams = (params) => this.setState({ params });
    this.clear = () => {
      PluginCommands.State.Snapshots.Clear(this.plugin, {});
    };
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !shallowEqualObjects(this.props, nextProps) || !shallowEqualObjects(this.state, nextState);
  }
  render() {
    return (0, import_jsx_runtime17.jsx)("div", { children: (0, import_jsx_runtime17.jsx)(AddSnapshot, { parent: this }) });
  }
};
LocalStateSnapshots.Params = {
  name: ParamDefinition.Text(),
  description: ParamDefinition.Text()
};
function invalidateSnapshotKey(plugin, key, currentId) {
  if (!key)
    return false;
  return plugin.managers.snapshot.state.entries.some((e) => (!currentId || e.snapshot.id !== currentId) && e.key === key);
}
function AddSnapshot({ parent }) {
  const [state, setState] = React4.useState({ key: "", name: "", description: "" });
  const add = () => {
    PluginCommands.State.Snapshots.Add(parent.plugin, {
      key: state.key,
      name: state.name,
      description: state.description
    });
    setState({ key: "", name: "", description: "" });
  };
  const keyExists = invalidateSnapshotKey(parent.plugin, state.key);
  return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)(EditSnapshotParams, { state, setState, apply: add }), (0, import_jsx_runtime17.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime17.jsx)(IconButton, { onClick: parent.clear, svg: DeleteOutlinedSvg, title: "Remove All" }), (0, import_jsx_runtime17.jsx)(Button, { onClick: add, icon: keyExists ? void 0 : AddSvg, style: { textAlign: "right" }, commit: keyExists ? "off" : "on", disabled: keyExists, children: keyExists ? "Key must be unique" : "Add" })] })] });
}
var LocalStateSnapshotList = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { editingId: void 0 };
    this.edit = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      const current = this.state.editingId;
      this.setState({ editingId: id === current ? void 0 : id });
    };
    this.doneEdit = () => this.setState({ editingId: void 0 });
    this.apply = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      PluginCommands.State.Snapshots.Apply(this.plugin, { id });
    };
    this.remove = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      PluginCommands.State.Snapshots.Remove(this.plugin, { id });
    };
    this.moveUp = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      PluginCommands.State.Snapshots.Move(this.plugin, { id, dir: -1 });
    };
    this.moveDown = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      PluginCommands.State.Snapshots.Move(this.plugin, { id, dir: 1 });
    };
    this.replace = (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      PluginCommands.State.Snapshots.Replace(this.plugin, { id });
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.managers.snapshot.events.changed, () => this.forceUpdate());
  }
  render() {
    const current = this.plugin.managers.snapshot.state.current;
    const items = [];
    this.plugin.managers.snapshot.state.entries.forEach((e) => {
      var _a;
      items.push((0, import_jsx_runtime17.jsxs)("li", { className: "msp-flex-row", children: [(0, import_jsx_runtime17.jsxs)(Button, { "data-id": e.snapshot.id, onClick: this.apply, className: "msp-no-overflow", children: [(0, import_jsx_runtime17.jsxs)("span", { style: { fontWeight: e.snapshot.id === current ? "bold" : void 0 }, children: [!!e.key && `[${e.key}] `, e.name || new Date(e.timestamp).toLocaleString()] }), " ", (0, import_jsx_runtime17.jsx)("small", { children: `${e.snapshot.durationInMs ? formatTimespan(e.snapshot.durationInMs, false) : ""}` })] }), (0, import_jsx_runtime17.jsx)(IconButton, { svg: TuneSvg, "data-id": e.snapshot.id, title: "Edit", onClick: this.edit, flex: "28px" }), (0, import_jsx_runtime17.jsx)(IconButton, { svg: ArrowUpwardSvg, "data-id": e.snapshot.id, title: "Move Up", onClick: this.moveUp, flex: "20px" }), (0, import_jsx_runtime17.jsx)(IconButton, { svg: ArrowDownwardSvg, "data-id": e.snapshot.id, title: "Move Down", onClick: this.moveDown, flex: "20px" }), (0, import_jsx_runtime17.jsx)(IconButton, { svg: SwapHorizSvg, "data-id": e.snapshot.id, title: "Replace", onClick: this.replace, flex: "20px" }), (0, import_jsx_runtime17.jsx)(IconButton, { svg: DeleteOutlinedSvg, "data-id": e.snapshot.id, title: "Remove", onClick: this.remove, flex: "20px" })] }, e.snapshot.id));
      if (this.state.editingId === e.snapshot.id) {
        items.push((0, import_jsx_runtime17.jsx)(EditSnapshot, { entry: e, plugin: this.plugin, done: this.doneEdit }, `${e.snapshot.id}-edit`));
      }
      const image2 = e.image && ((_a = this.plugin.managers.asset.get(e.image)) === null || _a === void 0 ? void 0 : _a.file);
      if (image2) {
        items.push((0, import_jsx_runtime17.jsx)("li", { className: "msp-state-image-row", children: (0, import_jsx_runtime17.jsx)(Button, { "data-id": e.snapshot.id, onClick: this.apply, children: (0, import_jsx_runtime17.jsx)("img", { draggable: false, src: URL.createObjectURL(image2) }) }) }, `${e.snapshot.id}-image`));
      }
    });
    return (0, import_jsx_runtime17.jsx)(import_jsx_runtime17.Fragment, { children: (0, import_jsx_runtime17.jsx)("ul", { style: { listStyle: "none", marginTop: "10px" }, className: "msp-state-list", children: items }) });
  }
};
function EditSnapshotParams({ state, setState, apply }) {
  const keyRef = React4.useRef();
  const descRef = React4.useRef();
  const [showKeyHelp, setShowKeyHelp] = React4.useState(false);
  return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)(ControlRow, { label: "Name", control: (0, import_jsx_runtime17.jsx)("input", { type: "text", value: state.name, placeholder: "Name", onChange: (e) => setState({ ...state, name: e.target.value }), onKeyUp: (e) => {
    var _a;
    if (e.key === "Enter")
      (_a = keyRef.current) === null || _a === void 0 ? void 0 : _a.focus();
  } }) }), (0, import_jsx_runtime17.jsx)(ControlRow, { label: (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: ["Key", (0, import_jsx_runtime17.jsx)(ToggleParamHelpButton, { show: showKeyHelp, toggle: () => setShowKeyHelp((prev) => !prev) })] }), control: (0, import_jsx_runtime17.jsx)("input", { type: "text", ref: keyRef, value: state.key, placeholder: "Key (optional)", onChange: (e) => setState({ ...state, key: e.target.value }), onKeyUp: (e) => {
    var _a;
    if (e.key === "Enter")
      (_a = descRef.current) === null || _a === void 0 ? void 0 : _a.focus();
  } }) }), showKeyHelp && (0, import_jsx_runtime17.jsx)("div", { className: "msp-control-offset", children: (0, import_jsx_runtime17.jsx)(ParamHelp, { description: "Optional snapshot key used to activate snapshots from descriptions, labels, etc." }) }), (0, import_jsx_runtime17.jsx)("div", { className: "msp-flex-row msp-text-area-wrapper", style: { marginBottom: 1 }, children: (0, import_jsx_runtime17.jsx)("textarea", {
    ref: descRef,
    // NOTE: curly brackets are required to support \n in the placeholder, do not remove
    placeholder: "Markdown Description\n\n- Use [title](#key) to link to a snapshot",
    className: "msp-form-control",
    value: state.description,
    onChange: (e) => setState({ ...state, description: e.target.value }),
    onKeyUp: (e) => {
      if (e.key === "Enter" && e.ctrlKey)
        apply(state);
    }
  }) })] });
}
function EditSnapshot({ entry, plugin, done }) {
  var _a, _b, _c;
  const [state, setState] = React4.useState({ key: (_a = entry.key) !== null && _a !== void 0 ? _a : "", name: (_b = entry.name) !== null && _b !== void 0 ? _b : "", description: (_c = entry.description) !== null && _c !== void 0 ? _c : "", descriptionFormat: entry.descriptionFormat });
  const apply = () => {
    plugin.managers.snapshot.update(entry, state);
    done();
  };
  const keyExists = invalidateSnapshotKey(plugin, state.key, entry.snapshot.id);
  return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)(EditSnapshotParams, { state, setState, apply }), (0, import_jsx_runtime17.jsx)("div", { className: "msp-flex-row", style: { marginBottom: 1 }, children: (0, import_jsx_runtime17.jsx)(Button, { onClick: apply, icon: keyExists ? void 0 : CheckSvg, style: { textAlign: "right" }, commit: keyExists ? "off" : "on", disabled: keyExists, children: keyExists ? "Key must be unique" : "Apply" }) })] });
}
var RemoteStateSnapshots = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.Params = {
      name: ParamDefinition.Text(),
      options: ParamDefinition.Group({
        description: ParamDefinition.Text(),
        playOnLoad: ParamDefinition.Boolean(false),
        serverUrl: ParamDefinition.Text(this.plugin.config.get(PluginConfig.State.CurrentServer))
      })
    };
    this.state = { params: ParamDefinition.getDefaultValues(this.Params), entries: OrderedMap(), isBusy: false };
    this.ListOnlyParams = {
      options: ParamDefinition.Group({
        serverUrl: ParamDefinition.Text(this.plugin.config.get(PluginConfig.State.CurrentServer))
      }, { isFlat: true })
    };
    this._mounted = false;
    this.refresh = async () => {
      try {
        this.setState({ isBusy: true });
        this.plugin.config.set(PluginConfig.State.CurrentServer, this.state.params.options.serverUrl);
        const json = await this.plugin.runTask(this.plugin.fetch({ url: this.serverUrl("list"), type: "json" })) || [];
        json.sort((a4, b4) => {
          if (a4.isSticky === b4.isSticky)
            return a4.timestamp - b4.timestamp;
          return a4.isSticky ? -1 : 1;
        });
        const entries = OrderedMap().asMutable();
        for (const e of json) {
          entries.set(e.id, {
            ...e,
            url: this.serverUrl(`get/${e.id}`),
            removeUrl: this.serverUrl(`remove/${e.id}`)
          });
        }
        if (this._mounted)
          this.setState({ entries: entries.asImmutable(), isBusy: false });
      } catch (e) {
        console.error(e);
        this.plugin.log.error("Error fetching remote snapshots");
        if (this._mounted)
          this.setState({ entries: OrderedMap(), isBusy: false });
      }
    };
    this.upload = async () => {
      this.setState({ isBusy: true });
      this.plugin.config.set(PluginConfig.State.CurrentServer, this.state.params.options.serverUrl);
      await PluginCommands.State.Snapshots.Upload(this.plugin, {
        name: this.state.params.name,
        description: this.state.params.options.description,
        playOnLoad: this.state.params.options.playOnLoad,
        serverUrl: this.state.params.options.serverUrl
      });
      this.plugin.log.message("Snapshot uploaded.");
      if (this._mounted) {
        this.setState({ isBusy: false });
        this.refresh();
      }
    };
    this.fetch = async (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      const entry = this.state.entries.get(id);
      if (!entry)
        return;
      this.setState({ isBusy: true });
      try {
        await PluginCommands.State.Snapshots.Fetch(this.plugin, { url: entry.url });
      } finally {
        if (this._mounted)
          this.setState({ isBusy: false });
      }
    };
    this.remove = async (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      const entry = this.state.entries.get(id);
      if (!entry)
        return;
      this.setState({ entries: this.state.entries.remove(id) });
      try {
        await fetch(entry.removeUrl);
      } catch (e2) {
        console.error(e2);
      }
    };
  }
  componentDidMount() {
    this.refresh();
    this._mounted = true;
  }
  componentWillUnmount() {
    super.componentWillUnmount();
    this._mounted = false;
  }
  serverUrl(q) {
    if (!q)
      return this.state.params.options.serverUrl;
    return urlCombine(this.state.params.options.serverUrl, q);
  }
  render() {
    return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)(SectionHeader, { title: "Remote States", accent: "blue" }), !this.props.listOnly && (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)(ParameterControls, { params: this.Params, values: this.state.params, onEnter: this.upload, onChange: (p) => {
      this.setState({ params: { ...this.state.params, [p.name]: p.value } });
    }, isDisabled: this.state.isBusy }), (0, import_jsx_runtime17.jsxs)("div", { className: "msp-flex-row", children: [(0, import_jsx_runtime17.jsx)(IconButton, { onClick: this.refresh, disabled: this.state.isBusy, svg: RefreshSvg }), (0, import_jsx_runtime17.jsx)(Button, { icon: CloudUploadSvg, onClick: this.upload, disabled: this.state.isBusy, commit: true, children: "Upload" })] })] }), (0, import_jsx_runtime17.jsx)(RemoteStateSnapshotList, { entries: this.state.entries, isBusy: this.state.isBusy, serverUrl: this.state.params.options.serverUrl, fetch: this.fetch, remove: this.props.listOnly ? void 0 : this.remove }), this.props.listOnly && (0, import_jsx_runtime17.jsxs)("div", { style: { marginTop: "10px" }, children: [(0, import_jsx_runtime17.jsx)(ParameterControls, { params: this.ListOnlyParams, values: this.state.params, onEnter: this.upload, onChange: (p) => {
      this.setState({ params: { ...this.state.params, [p.name]: p.value } });
    }, isDisabled: this.state.isBusy }), (0, import_jsx_runtime17.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime17.jsx)(Button, { onClick: this.refresh, disabled: this.state.isBusy, icon: RefreshSvg, children: "Refresh" }) })] })] });
  }
};
var RemoteStateSnapshotList = class extends PurePluginUIComponent {
  constructor() {
    super(...arguments);
    this.open = async (e) => {
      const id = e.currentTarget.getAttribute("data-id");
      if (!id)
        return;
      const entry = this.props.entries.get(id);
      if (!entry)
        return;
      e.preventDefault();
      let url = `${window.location}`;
      const qi = url.indexOf("?");
      if (qi > 0)
        url = url.substr(0, qi);
      window.open(`${url}?snapshot-url=${encodeURIComponent(entry.url)}`, "_blank");
    };
  }
  render() {
    return (0, import_jsx_runtime17.jsx)("ul", { style: { listStyle: "none", marginTop: "10px" }, className: "msp-state-list", children: this.props.entries.valueSeq().map((e) => (0, import_jsx_runtime17.jsxs)("li", { className: "msp-flex-row", children: [(0, import_jsx_runtime17.jsxs)(Button, { "data-id": e.id, onClick: this.props.fetch, disabled: this.props.isBusy, onContextMenu: this.open, title: "Click to download, right-click to open in a new tab.", children: [e.name || new Date(e.timestamp).toLocaleString(), " ", (0, import_jsx_runtime17.jsx)("small", { children: e.description })] }), !e.isSticky && this.props.remove && (0, import_jsx_runtime17.jsx)(IconButton, { svg: DeleteOutlinedSvg, "data-id": e.id, title: "Remove", onClick: this.props.remove, disabled: this.props.isBusy, small: true })] }, e.id)) });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/state/tree.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var StateTree2 = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { showActions: true };
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.created, (e) => {
      if (e.cell.transform.parent === Transform.RootRef)
        this.forceUpdate();
    });
    this.subscribe(this.plugin.state.events.cell.removed, (e) => {
      if (e.parent === Transform.RootRef)
        this.forceUpdate();
    });
  }
  static getDerivedStateFromProps(props, state) {
    const n = props.state.tree.root.ref;
    const children = props.state.tree.children.get(n);
    const showActions = children.size === 0;
    if (state.showActions === showActions)
      return null;
    return { showActions };
  }
  render() {
    const ref = this.props.state.tree.root.ref;
    if (this.state.showActions) {
      return (0, import_jsx_runtime18.jsxs)("div", { style: { margin: "10px", cursor: "default" }, children: [(0, import_jsx_runtime18.jsx)("p", { children: "Nothing to see here yet." }), (0, import_jsx_runtime18.jsxs)("p", { children: ["Structures and Volumes can be loaded from the ", (0, import_jsx_runtime18.jsx)(Icon, { svg: HomeOutlinedSvg }), " tab."] })] });
    }
    return (0, import_jsx_runtime18.jsx)(StateTreeNode, { cell: this.props.state.cells.get(ref), depth: 0 });
  }
};
var StateTreeNode = class _StateTreeNode extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isCollapsed: !!this.props.cell.state.isCollapsed,
      isNull: _StateTreeNode.isNull(this.props.cell),
      showLabel: _StateTreeNode.showLabel(this.props.cell)
    };
  }
  is(e) {
    return e.ref === this.ref && e.state === this.props.cell.parent;
  }
  get ref() {
    return this.props.cell.transform.ref;
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated, (e) => {
      if (this.props.cell === e.cell && this.is(e) && e.state.cells.has(this.ref)) {
        if (this.state.isCollapsed !== !!e.cell.state.isCollapsed || this.state.isNull !== _StateTreeNode.isNull(e.cell) || this.state.showLabel !== _StateTreeNode.showLabel(e.cell)) {
          this.forceUpdate();
        }
      }
    });
    this.subscribe(this.plugin.state.events.cell.created, (e) => {
      if (this.props.cell.parent === e.state && this.ref === e.cell.transform.parent) {
        this.forceUpdate();
      }
    });
    this.subscribe(this.plugin.state.events.cell.removed, (e) => {
      if (this.props.cell.parent === e.state && this.ref === e.parent) {
        this.forceUpdate();
      }
    });
  }
  static getDerivedStateFromProps(props, state) {
    const isNull = _StateTreeNode.isNull(props.cell);
    const showLabel = _StateTreeNode.showLabel(props.cell);
    if (!!props.cell.state.isCollapsed === state.isCollapsed && state.isNull === isNull && state.showLabel === showLabel)
      return null;
    return { isCollapsed: !!props.cell.state.isCollapsed, isNull, showLabel };
  }
  static hasDecorator(cell) {
    var _a;
    const children = cell.parent.tree.children.get(cell.transform.ref);
    if (children.size !== 1)
      return false;
    const child = children.first();
    return !!child && !!((_a = cell.parent) === null || _a === void 0 ? void 0 : _a.tree.transforms.get(child).transformer.definition.isDecorator);
  }
  static isNull(cell) {
    return !cell || !cell.parent || cell.obj === StateObject.Null || !cell.parent.tree.transforms.has(cell.transform.ref);
  }
  static showLabel(cell) {
    return cell.transform.ref !== Transform.RootRef && (cell.status !== "ok" || !cell.state.isGhost && !_StateTreeNode.hasDecorator(cell));
  }
  render() {
    if (this.state.isNull) {
      return null;
    }
    const cell = this.props.cell;
    const children = cell.parent.tree.children.get(this.ref);
    if (!this.state.showLabel) {
      if (children.size === 0)
        return null;
      return (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, { children: children.map((c4) => (0, import_jsx_runtime18.jsx)(_StateTreeNode, { cell: cell.parent.cells.get(c4), depth: this.props.depth }, c4)) });
    }
    const newDepth = this.props.depth + 1;
    return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [(0, import_jsx_runtime18.jsx)(StateTreeNodeLabel, { cell, depth: this.props.depth }), children.size === 0 ? void 0 : (0, import_jsx_runtime18.jsx)("div", { style: { display: this.state.isCollapsed ? "none" : "block" }, children: children.map((c4) => (0, import_jsx_runtime18.jsx)(_StateTreeNode, { cell: cell.parent.cells.get(c4), depth: newDepth }, c4)) })] });
  }
};
var StateTreeNodeLabel = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isCurrent: this.props.cell.parent.current === this.ref,
      isCollapsed: !!this.props.cell.state.isCollapsed,
      action: void 0,
      currentAction: void 0
    };
    this.setCurrent = (e) => {
      e === null || e === void 0 ? void 0 : e.preventDefault();
      e === null || e === void 0 ? void 0 : e.currentTarget.blur();
      PluginCommands.State.SetCurrentObject(this.plugin, { state: this.props.cell.parent, ref: this.ref });
    };
    this.setCurrentRoot = (e) => {
      e === null || e === void 0 ? void 0 : e.preventDefault();
      e === null || e === void 0 ? void 0 : e.currentTarget.blur();
      if (!this.props.cell.parent)
        return;
      PluginCommands.State.SetCurrentObject(this.plugin, { state: this.props.cell.parent, ref: Transform.RootRef });
    };
    this.remove = (e) => {
      e === null || e === void 0 ? void 0 : e.preventDefault();
      PluginCommands.State.RemoveObject(this.plugin, { state: this.props.cell.parent, ref: this.ref, removeParentGhosts: true });
    };
    this.toggleVisible = (e) => {
      e.preventDefault();
      PluginCommands.State.ToggleVisibility(this.plugin, { state: this.props.cell.parent, ref: this.ref });
      e.currentTarget.blur();
    };
    this.toggleExpanded = (e) => {
      e.preventDefault();
      PluginCommands.State.ToggleExpanded(this.plugin, { state: this.props.cell.parent, ref: this.ref });
      e.currentTarget.blur();
    };
    this.highlight = (e) => {
      e.preventDefault();
      PluginCommands.Interactivity.Object.Highlight(this.plugin, { state: this.props.cell.parent, ref: this.ref });
      e.currentTarget.blur();
    };
    this.clearHighlight = (e) => {
      e.preventDefault();
      PluginCommands.Interactivity.ClearHighlights(this.plugin);
      e.currentTarget.blur();
    };
    this.hideApply = () => {
      this.setCurrentRoot();
    };
    this.selectAction = (item) => {
      if (!item)
        return;
      (item === null || item === void 0 ? void 0 : item.value)();
    };
  }
  is(e) {
    return e.ref === this.ref && e.state === this.props.cell.parent;
  }
  get ref() {
    return this.props.cell.transform.ref;
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.stateUpdated.pipe(filter((e) => this.is(e)), debounceTime(33)), (e) => {
      this.forceUpdate();
    });
    this.subscribe(this.props.cell.parent.behaviors.currentObject, (e) => {
      if (!this.is(e)) {
        if (this.state.isCurrent && e.state.transforms.has(this.ref)) {
          this._setCurrent(this.props.cell.parent.current === this.ref, this.state.isCollapsed);
        }
        return;
      }
      if (e.state.transforms.has(this.ref)) {
        this._setCurrent(this.props.cell.parent.current === this.ref, !!this.props.cell.state.isCollapsed);
      }
    });
  }
  _setCurrent(isCurrent, isCollapsed) {
    if (isCurrent) {
      this.setState({ isCurrent, action: "options", currentAction: void 0, isCollapsed });
    } else {
      this.setState({ isCurrent, action: void 0, currentAction: void 0, isCollapsed });
    }
  }
  static getDerivedStateFromProps(props, state) {
    const isCurrent = props.cell.parent.current === props.cell.transform.ref;
    const isCollapsed = !!props.cell.state.isCollapsed;
    if (state.isCollapsed === isCollapsed && state.isCurrent === isCurrent)
      return null;
    return { isCurrent, isCollapsed, action: void 0, currentAction: void 0 };
  }
  get actions() {
    const cell = this.props.cell;
    const actions = [...cell.parent.actions.fromCell(cell, this.plugin)];
    if (actions.length === 0)
      return;
    actions.sort((a4, b4) => a4.definition.display.name < b4.definition.display.name ? -1 : a4.definition.display.name === b4.definition.display.name ? 0 : 1);
    return [
      ActionMenu.Header("Apply Action"),
      ...actions.map((a4) => ActionMenu.Item(a4.definition.display.name, () => this.setState({ action: "apply", currentAction: a4 })))
    ];
  }
  updates(margin) {
    const cell = this.props.cell;
    const decoratorChain = StateTreeSpine.getDecoratorChain(cell.parent, cell.transform.ref);
    const decorators = [];
    for (let i = decoratorChain.length - 1; i >= 0; i--) {
      const d3 = decoratorChain[i];
      decorators.push((0, import_jsx_runtime18.jsx)(UpdateTransformControl, { state: cell.parent, transform: d3.transform, noMargin: true, wrapInExpander: true, expanderHeaderLeftMargin: margin }, `${d3.transform.transformer.id}-${i}`));
    }
    return (0, import_jsx_runtime18.jsx)("div", { className: "msp-tree-updates-wrapper", children: decorators });
  }
  render() {
    const cell = this.props.cell;
    const n = cell.transform;
    if (!cell)
      return null;
    const isCurrent = this.is(cell.parent.behaviors.currentObject.value);
    const disabled = cell.status !== "error" && cell.status !== "ok";
    let label;
    if (cell.status === "error" || !cell.obj) {
      const name2 = cell.status === "error" ? cell.errorText : n.transformer.definition.display.name;
      label = (0, import_jsx_runtime18.jsxs)(Button, { className: "msp-btn-tree-label msp-no-hover-outline", noOverflow: true, title: name2, onClick: this.state.isCurrent ? this.setCurrentRoot : this.setCurrent, disabled, children: [cell.status === "error" && (0, import_jsx_runtime18.jsxs)("b", { children: ["[", cell.status, "]"] }), " ", (0, import_jsx_runtime18.jsx)("span", { children: name2 })] });
    } else {
      const obj = cell.obj;
      const title = `${obj.label} ${obj.description ? obj.description : ""}`;
      label = (0, import_jsx_runtime18.jsxs)(Button, { className: `msp-btn-tree-label msp-type-class-${obj.type.typeClass}`, noOverflow: true, disabled, title, onClick: this.state.isCurrent ? this.setCurrentRoot : this.setCurrent, children: [(0, import_jsx_runtime18.jsx)("span", { children: obj.label }), " ", obj.description ? (0, import_jsx_runtime18.jsx)("small", { children: obj.description }) : void 0] });
    }
    const children = cell.parent.tree.children.get(this.ref);
    const cellState = cell.state;
    const expand2 = (0, import_jsx_runtime18.jsx)(IconButton, { svg: cellState.isCollapsed ? ArrowRightSvg : ArrowDropDownSvg, flex: "20px", disabled, onClick: this.toggleExpanded, transparent: true, className: "msp-no-hover-outline", style: { visibility: children.size > 0 ? "visible" : "hidden" } });
    const remove = !cell.state.isLocked ? (0, import_jsx_runtime18.jsx)(IconButton, { svg: DeleteOutlinedSvg, onClick: this.remove, disabled, small: true, toggleState: false }) : void 0;
    const visibility = (0, import_jsx_runtime18.jsx)(IconButton, { svg: cellState.isHidden ? VisibilityOffOutlinedSvg : VisibilityOutlinedSvg, toggleState: false, disabled, small: true, onClick: this.toggleVisible });
    const marginStyle = {
      marginLeft: `${this.props.depth * 8}px`
    };
    const row = (0, import_jsx_runtime18.jsxs)("div", { className: `msp-flex-row msp-tree-row${isCurrent ? " msp-tree-row-current" : ""}`, onMouseEnter: this.highlight, onMouseLeave: this.clearHighlight, style: marginStyle, children: [expand2, label, remove, visibility] });
    if (!isCurrent)
      return row;
    if (this.state.action === "apply" && this.state.currentAction) {
      return (0, import_jsx_runtime18.jsxs)("div", { style: { marginBottom: "1px" }, children: [row, (0, import_jsx_runtime18.jsx)(ControlGroup, { header: `Apply ${this.state.currentAction.definition.display.name}`, initialExpanded: true, hideExpander: true, hideOffset: false, onHeaderClick: this.hideApply, topRightIcon: CloseSvg, headerLeftMargin: `${this.props.depth * 8 + 21}px`, children: (0, import_jsx_runtime18.jsx)(ApplyActionControl, { onApply: this.hideApply, state: this.props.cell.parent, action: this.state.currentAction, nodeRef: this.props.cell.transform.ref, hideHeader: true, noMargin: true }) })] });
    }
    if (this.state.action === "options") {
      const actions = this.actions;
      const updates = this.updates(`${this.props.depth * 8 + 21}px`);
      return (0, import_jsx_runtime18.jsxs)("div", { style: { marginBottom: "1px" }, children: [row, updates, actions && (0, import_jsx_runtime18.jsx)("div", { style: { marginLeft: `${this.props.depth * 8 + 21}px`, marginTop: "-1px" }, children: (0, import_jsx_runtime18.jsx)(ActionMenu, { items: actions, onSelect: this.selectAction }) })] });
    }
    return row;
  }
};

// node_modules/molstar/lib/mol-plugin-ui/left-panel.js
var CustomImportControls = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.state.behaviors.events.changed, () => this.forceUpdate());
  }
  render() {
    const controls = [];
    this.plugin.customImportControls.forEach((Controls, key) => {
      controls.push((0, import_jsx_runtime19.jsx)(Controls, { initiallyCollapsed: this.props.initiallyCollapsed }, key));
    });
    return controls.length > 0 ? (0, import_jsx_runtime19.jsx)(import_jsx_runtime19.Fragment, { children: controls }) : null;
  }
};
var LeftPanelControls = class extends PluginUIComponent {
  constructor() {
    var _a;
    super(...arguments);
    this.state = { tab: this.plugin.behaviors.layout.leftPanelTabName.value };
    this.set = (tab2) => {
      if (this.state.tab === tab2) {
        this.setState({ tab: "none" }, () => this.plugin.behaviors.layout.leftPanelTabName.next("none"));
        PluginCommands.Layout.Update(this.plugin, { state: { regionState: { ...this.plugin.layout.state.regionState, left: "collapsed" } } });
        return;
      }
      this.setState({ tab: tab2 }, () => this.plugin.behaviors.layout.leftPanelTabName.next(tab2));
      if (this.plugin.layout.state.regionState.left !== "full") {
        PluginCommands.Layout.Update(this.plugin, { state: { regionState: { ...this.plugin.layout.state.regionState, left: "full" } } });
      }
    };
    this.tabs = {
      "none": (0, import_jsx_runtime19.jsx)(import_jsx_runtime19.Fragment, {}),
      "root": (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(SectionHeader, { icon: HomeOutlinedSvg, title: "Home" }), (0, import_jsx_runtime19.jsx)(StateObjectActions, { state: this.plugin.state.data, nodeRef: Transform.RootRef, hideHeader: true, initiallyCollapsed: true, alwaysExpandFirst: true }), (0, import_jsx_runtime19.jsx)(CustomImportControls, {}), ((_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.remoteState) !== "none" && (0, import_jsx_runtime19.jsx)(RemoteStateSnapshots, { listOnly: true })] }),
      "data": (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(SectionHeader, { icon: AccountTreeOutlinedSvg, title: (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(RemoveAllButton, {}), " State Tree"] }) }), (0, import_jsx_runtime19.jsx)(StateTree2, { state: this.plugin.state.data })] }),
      "states": (0, import_jsx_runtime19.jsx)(StateSnapshots, {}),
      "settings": (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(SectionHeader, { icon: TuneSvg, title: "Plugin Settings" }), (0, import_jsx_runtime19.jsx)(FullSettings, {})] }),
      "help": (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(SectionHeader, { icon: HelpOutlineSvg, title: "Help" }), (0, import_jsx_runtime19.jsx)(HelpContent, {})] })
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.behaviors.layout.leftPanelTabName, (tab2) => {
      if (this.state.tab !== tab2)
        this.setState({ tab: tab2 });
      if (tab2 === "none" && this.plugin.layout.state.regionState.left !== "collapsed") {
        PluginCommands.Layout.Update(this.plugin, { state: { regionState: { ...this.plugin.layout.state.regionState, left: "collapsed" } } });
      }
    });
    this.subscribe(this.plugin.state.data.events.changed, ({ state }) => {
      if (this.state.tab !== "data")
        return;
      if (state.cells.size === 1)
        this.set("root");
    });
  }
  render() {
    const tab2 = this.state.tab;
    return (0, import_jsx_runtime19.jsxs)("div", { className: "msp-left-panel-controls", children: [(0, import_jsx_runtime19.jsxs)("div", { className: "msp-left-panel-controls-buttons", children: [(0, import_jsx_runtime19.jsx)(IconButton, { svg: HomeOutlinedSvg, toggleState: tab2 === "root", transparent: true, onClick: () => this.set("root"), title: "Home" }), (0, import_jsx_runtime19.jsx)(DataIcon, { set: this.set }), (0, import_jsx_runtime19.jsx)(IconButton, { svg: SaveOutlinedSvg, toggleState: tab2 === "states", transparent: true, onClick: () => this.set("states"), title: "Plugin State" }), (0, import_jsx_runtime19.jsx)(IconButton, { svg: HelpOutlineSvg, toggleState: tab2 === "help", transparent: true, onClick: () => this.set("help"), title: "Help" }), (0, import_jsx_runtime19.jsx)("div", { className: "msp-left-panel-controls-buttons-bottom", children: (0, import_jsx_runtime19.jsx)(IconButton, { svg: TuneSvg, toggleState: tab2 === "settings", transparent: true, onClick: () => this.set("settings"), title: "Settings" }) })] }), (0, import_jsx_runtime19.jsx)("div", { className: "msp-scrollable-container", children: this.tabs[tab2] })] });
  }
};
var DataIcon = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { changed: false };
  }
  get tab() {
    return this.plugin.behaviors.layout.leftPanelTabName.value;
  }
  componentDidMount() {
    this.subscribe(this.plugin.behaviors.layout.leftPanelTabName, (tab2) => {
      if (this.tab === "data")
        this.setState({ changed: false });
      else
        this.forceUpdate();
    });
    this.subscribe(this.plugin.state.data.events.changed, (state) => {
      if (this.tab !== "data")
        this.setState({ changed: true });
    });
  }
  render() {
    return (0, import_jsx_runtime19.jsx)(IconButton, { svg: AccountTreeOutlinedSvg, toggleState: this.tab === "data", transparent: true, onClick: () => this.props.set("data"), title: "State Tree", style: { position: "relative" }, extraContent: this.state.changed ? (0, import_jsx_runtime19.jsx)("div", { className: "msp-left-panel-controls-button-data-dirty" }) : void 0 });
  }
};
var FullSettings = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.setSettings = (p) => {
      PluginCommands.Canvas3D.SetSettings(this.plugin, { settings: { [p.name]: p.value } });
    };
    this.setCanvas3DContextProps = (p) => {
      var _a;
      (_a = this.plugin.canvas3dContext) === null || _a === void 0 ? void 0 : _a.setProps({ [p.name]: p.value });
      this.plugin.events.canvas3d.settingsUpdated.next(void 0);
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
    this.subscribe(this.plugin.layout.events.updated, () => this.forceUpdate());
    if (this.plugin.canvas3d) {
      this.subscribe(this.plugin.canvas3d.camera.stateChanged.pipe(throttleTime(500, void 0, { leading: true, trailing: true })), (state) => {
        if (state.radiusMax !== void 0 || state.radius !== void 0) {
          this.forceUpdate();
        }
      });
    }
  }
  render() {
    return (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [this.plugin.canvas3d && this.plugin.canvas3dContext && (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(SectionHeader, { title: "Viewport" }), (0, import_jsx_runtime19.jsx)(ParameterControls, { params: Canvas3DParams, values: this.plugin.canvas3d.props, onChange: this.setSettings }), (0, import_jsx_runtime19.jsx)(ParameterControls, { params: Canvas3DContext.Params, values: this.plugin.canvas3dContext.props, onChange: this.setCanvas3DContextProps })] }), (0, import_jsx_runtime19.jsx)(SectionHeader, { title: "Behavior" }), (0, import_jsx_runtime19.jsx)(StateTree2, { state: this.plugin.state.behaviors })] });
  }
};
var RemoveAllButton = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.remove = (e) => {
      e.preventDefault();
      PluginCommands.State.RemoveObject(this.plugin, { state: this.plugin.state.data, ref: Transform.RootRef });
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.events.cell.created, (e) => {
      if (e.cell.transform.parent === Transform.RootRef)
        this.forceUpdate();
    });
    this.subscribe(this.plugin.state.events.cell.removed, (e) => {
      if (e.parent === Transform.RootRef)
        this.forceUpdate();
    });
  }
  render() {
    const count2 = this.plugin.state.data.tree.children.get(Transform.RootRef).size;
    if (count2 === 0)
      return null;
    return (0, import_jsx_runtime19.jsx)(IconButton, { svg: DeleteOutlinedSvg, onClick: this.remove, title: "Remove All", style: { display: "inline-block" }, small: true, className: "msp-no-hover-outline", transparent: true });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var React6 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin-ui/sequence/sequence.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var React5 = __toESM(require_react());
var MaxSequenceNumberSize = 5;
var DefaultMarkerColors = {
  selected: "rgb(51, 255, 25)",
  highlighted: "rgb(255, 102, 153)",
  focused: ""
};
var Sequence = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.parentDiv = React5.createRef();
    this.lastMouseOverSeqIdx = -1;
    this.highlightQueue = new Subject();
    this.markerColors = { ...DefaultMarkerColors };
    this.lociHighlightProvider = (loci, action) => {
      const changed = this.props.sequenceWrapper.markResidue(loci.loci, action);
      if (changed)
        this.updateMarker();
    };
    this.lociSelectionProvider = (loci, action) => {
      const changed = this.props.sequenceWrapper.markResidue(loci.loci, action);
      if (changed)
        this.updateMarker();
    };
    this.contextMenu = (e) => {
      e.preventDefault();
    };
    this.mouseDownLoci = void 0;
    this.mouseDown = (e) => {
      e.stopPropagation();
      const seqIdx = this.getSeqIdx(e);
      const loci = this.getLoci(seqIdx);
      this.mouseDownLoci = loci;
    };
    this.mouseUp = (e) => {
      e.stopPropagation();
      if (this.mouseDownLoci === void 0)
        return;
      const seqIdx = this.getSeqIdx(e);
      const loci = this.getLoci(seqIdx);
      if (loci) {
        const buttons = getButtons(e.nativeEvent);
        const button = getButton(e.nativeEvent);
        const modifiers = getModifiers(e.nativeEvent);
        let range = loci;
        if (!element_exports.Loci.areEqual(this.mouseDownLoci, loci)) {
          const ref = this.mouseDownLoci.elements[0];
          const ext = loci.elements[0];
          const min2 = Math.min(OrderedSet.min(ref.indices), OrderedSet.min(ext.indices));
          const max2 = Math.max(OrderedSet.max(ref.indices), OrderedSet.max(ext.indices));
          range = element_exports.Loci(loci.structure, [{
            unit: ref.unit,
            indices: OrderedSet.ofRange(min2, max2)
          }]);
        }
        this.click(range, buttons, button, modifiers);
      }
      this.mouseDownLoci = void 0;
    };
    this.location = element_exports.Location.create(void 0);
    this.mouseMove = (e) => {
      e.stopPropagation();
      const buttons = getButtons(e.nativeEvent);
      const button = getButton(e.nativeEvent);
      const modifiers = getModifiers(e.nativeEvent);
      const el = e.target;
      if (!el || !el.getAttribute) {
        if (this.lastMouseOverSeqIdx === -1)
          return;
        this.lastMouseOverSeqIdx = -1;
        this.highlightQueue.next({ seqIdx: -1, buttons, button, modifiers });
        return;
      }
      const seqIdx = el.hasAttribute("data-seqid") ? +el.getAttribute("data-seqid") : -1;
      if (this.lastMouseOverSeqIdx === seqIdx) {
        return;
      } else {
        this.lastMouseOverSeqIdx = seqIdx;
        if (this.mouseDownLoci !== void 0) {
          const loci = this.getLoci(seqIdx);
          this.hover(loci, ButtonsType.Flag.None, ButtonsType.Flag.None, modifiers);
        } else {
          this.highlightQueue.next({ seqIdx, buttons, button, modifiers });
        }
      }
    };
    this.mouseLeave = (e) => {
      e.stopPropagation();
      this.mouseDownLoci = void 0;
      if (this.lastMouseOverSeqIdx === -1)
        return;
      this.lastMouseOverSeqIdx = -1;
      const buttons = getButtons(e.nativeEvent);
      const button = getButton(e.nativeEvent);
      const modifiers = getModifiers(e.nativeEvent);
      this.highlightQueue.next({ seqIdx: -1, buttons, button, modifiers });
    };
  }
  get sequenceNumberPeriod() {
    if (this.props.sequenceNumberPeriod !== void 0) {
      return this.props.sequenceNumberPeriod;
    }
    if (this.props.sequenceWrapper.length > 10)
      return 10;
    const lastSeqNum = this.getSequenceNumber(this.props.sequenceWrapper.length - 1);
    if (lastSeqNum.length > 1)
      return 5;
    return 1;
  }
  componentDidMount() {
    this.plugin.managers.interactivity.lociHighlights.addProvider(this.lociHighlightProvider);
    this.plugin.managers.interactivity.lociSelects.addProvider(this.lociSelectionProvider);
    this.subscribe(this.highlightQueue.pipe(throttleTime(3 * 16.666, void 0, { leading: true, trailing: true })), (e) => {
      const loci = this.getLoci(e.seqIdx < 0 ? void 0 : e.seqIdx);
      this.hover(loci, e.buttons, e.button, e.modifiers);
    });
    this.subscribe(this.plugin.managers.structure.focus.behaviors.current, (focus) => {
      this.updateFocus(focus === null || focus === void 0 ? void 0 : focus.loci);
      this.updateMarker();
    });
    this.updateColors();
    PluginCommands.Canvas3D.SetSettings.subscribe(this.plugin, () => {
      this.updateColors();
      this.updateMarker();
    });
  }
  updateColors() {
    if (this.plugin.canvas3d) {
      this.markerColors.highlighted = Color.toHexStyle(this.plugin.canvas3d.props.renderer.highlightColor);
      this.markerColors.selected = Color.toHexStyle(this.plugin.canvas3d.props.renderer.selectColor);
    } else {
      this.markerColors.highlighted = DefaultMarkerColors.highlighted;
      this.markerColors.selected = DefaultMarkerColors.selected;
    }
  }
  updateFocus(loci) {
    this.props.sequenceWrapper.markResidue(EveryLoci, "unfocus");
    if (loci) {
      this.props.sequenceWrapper.markResidue(loci, "focus");
    }
  }
  componentWillUnmount() {
    super.componentWillUnmount();
    this.plugin.managers.interactivity.lociHighlights.removeProvider(this.lociHighlightProvider);
    this.plugin.managers.interactivity.lociSelects.removeProvider(this.lociSelectionProvider);
  }
  getLoci(seqIdx) {
    if (seqIdx !== void 0) {
      const loci = this.props.sequenceWrapper.getLoci(seqIdx);
      if (!element_exports.Loci.isEmpty(loci))
        return loci;
    }
  }
  getSeqIdx(e) {
    let seqIdx = void 0;
    const el = e.target;
    if (el && el.getAttribute) {
      seqIdx = el.hasAttribute("data-seqid") ? +el.getAttribute("data-seqid") : void 0;
    }
    return seqIdx;
  }
  hover(loci, buttons, button, modifiers) {
    const ev = { current: Representation.Loci.Empty, buttons, button, modifiers };
    if (loci !== void 0 && !element_exports.Loci.isEmpty(loci)) {
      ev.current = { loci };
      if (this.mouseDownLoci) {
        const ref = this.mouseDownLoci.elements[0];
        const ext = loci.elements[0];
        const min2 = Math.min(OrderedSet.min(ref.indices), OrderedSet.min(ext.indices));
        const max2 = Math.max(OrderedSet.max(ref.indices), OrderedSet.max(ext.indices));
        const range = element_exports.Loci(loci.structure, [{
          unit: ref.unit,
          indices: OrderedSet.ofRange(min2, max2)
        }]);
        ev.current = { loci: range };
      }
    }
    this.plugin.behaviors.interaction.hover.next(ev);
  }
  click(loci, buttons, button, modifiers) {
    const ev = { current: Representation.Loci.Empty, buttons, button, modifiers };
    if (loci !== void 0 && !element_exports.Loci.isEmpty(loci)) {
      ev.current = { loci };
    }
    this.plugin.behaviors.interaction.click.next(ev);
  }
  getBackgroundColor(seqIdx) {
    const seqWrapper = this.props.sequenceWrapper;
    if (seqWrapper.isHighlighted(seqIdx))
      return this.markerColors.highlighted;
    if (seqWrapper.isSelected(seqIdx))
      return this.markerColors.selected;
    if (seqWrapper.isFocused(seqIdx))
      return this.markerColors.focused;
    return "";
  }
  getResidueClass(seqIdx, label) {
    const seqWrapper = this.props.sequenceWrapper;
    const classes = [seqWrapper.residueClass(seqIdx)];
    if (label.length > 1) {
      classes.push(seqIdx === 0 ? "msp-sequence-residue-long-begin" : "msp-sequence-residue-long");
    }
    if (seqWrapper.isHighlighted(seqIdx))
      classes.push("msp-sequence-residue-highlighted");
    if (seqWrapper.isSelected(seqIdx))
      classes.push("msp-sequence-residue-selected");
    if (seqWrapper.isFocused(seqIdx))
      classes.push("msp-sequence-residue-focused");
    return classes.join(" ");
  }
  residue(seqIdx, label) {
    return (0, import_jsx_runtime20.jsx)("span", { "data-seqid": seqIdx, style: { backgroundColor: this.getBackgroundColor(seqIdx) }, className: this.getResidueClass(seqIdx, label), children: `${label}` }, seqIdx);
  }
  getSequenceNumberClass(seqIdx, seqNum, label) {
    const classList = ["msp-sequence-number"];
    if (seqNum.startsWith("-")) {
      if (label.length > 1 && seqIdx > 0)
        classList.push("msp-sequence-number-long-negative");
      else
        classList.push("msp-sequence-number-negative");
    } else {
      if (label.length > 1 && seqIdx > 0)
        classList.push("msp-sequence-number-long");
    }
    return classList.join(" ");
  }
  getSequenceNumber(seqIdx) {
    let seqNum = "";
    const loci = this.props.sequenceWrapper.getLoci(seqIdx);
    const l = element_exports.Loci.getFirstLocation(loci, this.location);
    if (l) {
      if (Unit.isAtomic(l.unit)) {
        const seqId = StructureProperties.residue.auth_seq_id(l);
        const insCode = StructureProperties.residue.pdbx_PDB_ins_code(l);
        seqNum = `${seqId}${insCode ? insCode : ""}`;
      } else if (Unit.isCoarse(l.unit)) {
        seqNum = `${seqIdx + 1}`;
      }
    }
    return seqNum;
  }
  padSeqNum(n) {
    if (n.length < MaxSequenceNumberSize)
      return n + new Array(MaxSequenceNumberSize - n.length + 1).join("");
    return n;
  }
  getSequenceNumberSpan(seqIdx, label) {
    const seqNum = this.getSequenceNumber(seqIdx);
    return (0, import_jsx_runtime20.jsx)("span", { className: this.getSequenceNumberClass(seqIdx, seqNum, label), children: this.padSeqNum(seqNum) }, `marker-${seqIdx}`);
  }
  updateMarker() {
    if (!this.parentDiv.current)
      return;
    const xs = this.parentDiv.current.children;
    const hasNumbers = !this.props.hideSequenceNumbers, period = this.sequenceNumberPeriod;
    const seqWrapper = this.props.sequenceWrapper;
    const seqLength = seqWrapper.length;
    let o = 0;
    for (let i = 0; i < seqLength; i++) {
      if (hasNumbers && i % period === 0 && i < seqLength)
        o++;
      const span = xs[o];
      if (!span)
        return;
      o++;
      const className = this.getResidueClass(i, seqWrapper.residueLabel(i));
      if (span.className !== className)
        span.className = className;
      const backgroundColor = this.getBackgroundColor(i);
      if (span.style.backgroundColor !== backgroundColor)
        span.style.backgroundColor = backgroundColor;
    }
  }
  render() {
    var _a;
    const sw = this.props.sequenceWrapper;
    const elems = [];
    const hasNumbers = !this.props.hideSequenceNumbers, period = this.sequenceNumberPeriod;
    for (let i = 0, il = sw.length; i < il; ++i) {
      const label = sw.residueLabel(i);
      if (hasNumbers && i % period === 0 && i < il) {
        elems[elems.length] = this.getSequenceNumberSpan(i, label);
      }
      elems[elems.length] = this.residue(i, label);
    }
    this.updateFocus((_a = this.plugin.managers.structure.focus.behaviors.current.value) === null || _a === void 0 ? void 0 : _a.loci);
    this.updateMarker();
    return (0, import_jsx_runtime20.jsx)("div", { className: "msp-sequence-wrapper", onContextMenu: this.contextMenu, onMouseDown: this.mouseDown, onMouseUp: this.mouseUp, onMouseMove: this.mouseMove, onMouseLeave: this.mouseLeave, ref: this.parentDiv, children: elems });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence/wrapper.js
var SequenceWrapper = class {
  mark(loci, action) {
    const seqIdxs = this.getSeqIndices(loci);
    if (OrderedSet.size(seqIdxs) === 0)
      return false;
    return applyMarkerAction(this.markerArray, seqIdxs, action);
  }
  markResidue(loci, action) {
    if (action === "focus")
      return this.markResidueFocus(loci, true);
    if (action === "unfocus")
      return this.markResidueFocus(loci, false);
    if (isEveryLoci(loci)) {
      return applyMarkerAction(this.markerArray, Interval.ofLength(this.length), action);
    } else {
      return this.mark(loci, action);
    }
  }
  markResidueFocus(loci, focusState) {
    const value = focusState ? 1 : 0;
    if (isEveryLoci(loci)) {
      this.focusMarkerArray.fill(value, 0, this.length);
      return true;
    } else {
      const seqIdxs = this.getSeqIndices(loci);
      OrderedSet.forEach(seqIdxs, (seqIdx) => this.focusMarkerArray[seqIdx] = value);
      return OrderedSet.size(seqIdxs) > 0;
    }
  }
  /** Return true if the position `seqIndex` in sequence view is highlighted */
  isHighlighted(seqIndex) {
    return !!(this.markerArray[seqIndex] & 1);
  }
  /** Return true if the position `seqIndex` in sequence view is selected */
  isSelected(seqIndex) {
    return !!(this.markerArray[seqIndex] & 2);
  }
  /** Return true if the position `seqIndex` in sequence view is focused */
  isFocused(seqIndex) {
    return !!this.focusMarkerArray[seqIndex];
  }
  constructor(data, length) {
    this.data = data;
    this.length = length;
    this.markerArray = new Uint8Array(length);
    this.focusMarkerArray = new Uint8Array(length);
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence/polymer.js
var PolymerSequenceWrapper = class extends SequenceWrapper {
  seqId(seqIdx) {
    return this.sequence.seqId.value(seqIdx);
  }
  residueLabel(seqIdx) {
    return this.sequence.label.value(seqIdx) || this.sequence.code.value(seqIdx);
  }
  residueColor(seqIdx) {
    return this.missing.has(this.modelNum, this.asymId, this.seqId(seqIdx)) ? ColorNames.grey : ColorNames.black;
  }
  residueClass(seqIdx) {
    return this.missing.has(this.modelNum, this.asymId, this.seqId(seqIdx)) ? "msp-sequence-missing" : "msp-sequence-present";
  }
  getSeqIndices(loci) {
    const { structure } = this.data;
    const index2 = (seqId) => this.sequence.index(seqId);
    if (element_exports.Loci.is(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      loci = element_exports.Loci.remap(loci, structure);
      const out = [];
      for (const e of loci.elements) {
        if (!this.unitMap.has(e.unit.id))
          continue;
        if (Unit.isAtomic(e.unit)) {
          collectSeqIdxAtomic(out, e, index2);
        } else {
          collectSeqIdxCoarse(out, e, index2);
        }
      }
      return SortedArray.deduplicate(SortedArray.ofSortedArray(out));
    } else if (Structure.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      return this.observed;
    }
    return Interval.Empty;
  }
  getLoci(seqIdx) {
    const query = createResidueQuery(this.data.units[0].chainGroupId, this.data.units[0].conformation.operator.name, this.seqId(seqIdx));
    return StructureSelection.toLociWithSourceUnits(StructureQuery.run(query, this.data.structure));
  }
  constructor(data) {
    const l = element_exports.Location.create(data.structure, data.units[0], data.units[0].elements[0]);
    const entitySeq = data.units[0].model.sequence.byEntityKey[StructureProperties.entity.key(l)];
    const length = entitySeq.sequence.length;
    super(data, length);
    this.unitMap = /* @__PURE__ */ new Map();
    for (const unit of data.units)
      this.unitMap.set(unit.id, unit);
    this.sequence = entitySeq.sequence;
    this.missing = data.units[0].model.properties.missingResidues;
    this.modelNum = data.units[0].model.modelNum;
    this.asymId = Unit.isAtomic(data.units[0]) ? StructureProperties.chain.label_asym_id(l) : StructureProperties.coarse.asym_id(l);
    const missing = [];
    for (let i = 0; i < length; ++i) {
      if (this.missing.has(this.modelNum, this.asymId, this.seqId(i)))
        missing.push(i);
    }
    this.observed = OrderedSet.subtract(Interval.ofBounds(0, length), SortedArray.ofSortedArray(missing));
  }
};
function createResidueQuery(chainGroupId, operatorName, label_seq_id) {
  return Queries.generators.atoms({
    unitTest: (ctx) => {
      return StructureProperties.unit.chainGroupId(ctx.element) === chainGroupId && StructureProperties.unit.operator_name(ctx.element) === operatorName;
    },
    residueTest: (ctx) => {
      if (ctx.element.unit.kind === Unit.Kind.Atomic) {
        return StructureProperties.residue.label_seq_id(ctx.element) === label_seq_id;
      } else {
        return StructureProperties.coarse.seq_id_begin(ctx.element) <= label_seq_id && StructureProperties.coarse.seq_id_end(ctx.element) >= label_seq_id;
      }
    }
  });
}
function collectSeqIdxAtomic(out, e, index2) {
  const { model, elements } = e.unit;
  const { index: residueIndex } = model.atomicHierarchy.residueAtomSegments;
  const { label_seq_id } = model.atomicHierarchy.residues;
  OrderedSet.forEachSegment(e.indices, (i) => residueIndex[elements[i]], (rI) => {
    const seqId = label_seq_id.value(rI);
    const seqIdx = index2(seqId);
    out.push(seqIdx);
  });
  return true;
}
function collectSeqIdxCoarse(out, e, index2) {
  const { model, elements } = e.unit;
  const begin = Unit.isSpheres(e.unit) ? model.coarseHierarchy.spheres.seq_id_begin : model.coarseHierarchy.gaussians.seq_id_begin;
  const end = Unit.isSpheres(e.unit) ? model.coarseHierarchy.spheres.seq_id_end : model.coarseHierarchy.gaussians.seq_id_end;
  OrderedSet.forEach(e.indices, (i) => {
    const eI = elements[i];
    for (let s = index2(begin.value(eI)), e2 = index2(end.value(eI)); s <= e2; s++) {
      out.push(s);
    }
  });
  return true;
}

// node_modules/molstar/lib/mol-plugin-ui/sequence/hetero.js
var HeteroSequenceWrapper = class extends SequenceWrapper {
  residueLabel(seqIdx) {
    return this.sequence[seqIdx];
  }
  residueColor(seqIdx) {
    return ColorNames.black;
  }
  residueClass(seqIdx) {
    return "msp-sequence-present";
  }
  getSeqIndices(loci) {
    const { structure } = this.data;
    if (element_exports.Loci.is(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      loci = element_exports.Loci.remap(loci, structure);
      const out = [];
      for (const e of loci.elements) {
        const unit = this.unitMap.get(e.unit.id);
        if (unit) {
          const { index: residueIndex } = e.unit.model.atomicHierarchy.residueAtomSegments;
          OrderedSet.forEach(e.indices, (v2) => {
            const seqIdx = this.sequenceIndices.get(residueIndex[unit.elements[v2]]);
            if (seqIdx !== void 0)
              out.push(seqIdx);
          });
        }
      }
      return SortedArray.deduplicate(SortedArray.ofSortedArray(out));
    } else if (Structure.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      return Interval.ofBounds(0, this.length);
    }
    return Interval.Empty;
  }
  getLoci(seqIdx) {
    const elements = [];
    const rI = this.residueIndices.get(seqIdx);
    if (rI !== void 0) {
      const unit = this.seqToUnit.get(seqIdx);
      const { offsets } = unit.model.atomicHierarchy.residueAtomSegments;
      const start2 = SortedArray.findPredecessorIndex(unit.elements, offsets[rI]);
      const end = SortedArray.findPredecessorIndex(unit.elements, offsets[rI + 1]);
      elements.push({ unit, indices: Interval.ofBounds(start2, end) });
    }
    return element_exports.Loci(this.data.structure, elements);
  }
  constructor(data) {
    const sequence = [];
    const sequenceIndices = /* @__PURE__ */ new Map();
    const residueIndices = /* @__PURE__ */ new Map();
    const seqToUnit = /* @__PURE__ */ new Map();
    for (let i = 0, il = data.units.length; i < il; ++i) {
      const unit = data.units[i];
      const { residueAtomSegments, atoms } = unit.model.atomicHierarchy;
      const residueIt = Segmentation.transientSegments(residueAtomSegments, unit.elements);
      while (residueIt.hasNext) {
        const { index: index2 } = residueIt.move();
        sequenceIndices.set(index2, sequence.length);
        residueIndices.set(sequence.length, index2);
        seqToUnit.set(sequence.length, unit);
        sequence.push(atoms.label_comp_id.value(residueAtomSegments.offsets[index2]));
      }
    }
    const length = sequence.length;
    super(data, length);
    this.unitMap = /* @__PURE__ */ new Map();
    for (const unit of data.units)
      this.unitMap.set(unit.id, unit);
    this.sequence = sequence;
    this.sequenceIndices = sequenceIndices;
    this.residueIndices = residueIndices;
    this.seqToUnit = seqToUnit;
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence/chain.js
var ChainSequenceWrapper = class extends SequenceWrapper {
  residueLabel(seqIdx) {
    return this.label;
  }
  residueColor(seqIdx) {
    return ColorNames.black;
  }
  residueClass(seqIdx) {
    return "msp-sequence-present";
  }
  getSeqIndices(loci) {
    const { structure } = this.data;
    if (element_exports.Loci.is(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      loci = element_exports.Loci.remap(loci, structure);
      for (const e of loci.elements) {
        const indices = this.unitIndices.get(e.unit.id);
        if (indices) {
          if (OrderedSet.isSubset(indices, e.indices)) {
            return Interval.ofSingleton(0);
          }
        }
      }
    } else if (Structure.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      return Interval.ofSingleton(0);
    }
    return Interval.Empty;
  }
  getLoci(seqIdx) {
    return this.loci;
  }
  constructor(data) {
    let residueCount = 0;
    let elementCount = 0;
    const counts = [];
    const l = element_exports.Location.create(data.structure);
    const unitIndices = /* @__PURE__ */ new Map();
    const lociElements = [];
    for (let i = 0, il = data.units.length; i < il; ++i) {
      const unit = data.units[i];
      element_exports.Location.set(l, data.structure, unit, unit.elements[0]);
      const entitySeq = unit.model.sequence.byEntityKey[StructureProperties.entity.key(l)];
      if (entitySeq)
        residueCount += entitySeq.sequence.length;
      elementCount += unit.elements.length;
      const indices = Interval.ofBounds(0, unit.elements.length);
      unitIndices.set(unit.id, indices);
      lociElements.push({ unit, indices });
    }
    if (residueCount > 0)
      counts.push(`${residueCount} residues`);
    counts.push(`${elementCount} elements`);
    const length = 1;
    super(data, length);
    this.label = `Whole Chain (${counts.join(", ")})`;
    this.unitIndices = unitIndices;
    this.loci = element_exports.Loci(this.data.structure, lociElements);
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence/element.js
var ElementSequenceWrapper = class extends SequenceWrapper {
  residueLabel(seqIdx) {
    return "X";
  }
  residueColor(seqIdx) {
    return ColorNames.black;
  }
  residueClass(seqIdx) {
    return "msp-sequence-present";
  }
  getSeqIndices(loci) {
    const { structure, units } = this.data;
    if (element_exports.Loci.is(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      loci = element_exports.Loci.remap(loci, structure);
      for (const e of loci.elements) {
        const indices = this.unitIndices.get(e.unit.id);
        if (indices) {
          if (OrderedSet.isSubset(indices, e.indices)) {
            return e.indices;
          }
        }
      }
    } else if (Structure.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, structure))
        return Interval.Empty;
      for (let i = 0, il = units.length; i < il; ++i) {
        const indices = this.unitIndices.get(units[i].id);
        return indices;
      }
    }
    return Interval.Empty;
  }
  getLoci(seqIdx) {
    const { units } = this.data;
    const lociElements = [];
    let offset = 0;
    for (let i = 0, il = units.length; i < il; ++i) {
      const unit = units[i];
      if (seqIdx < offset + unit.elements.length) {
        lociElements.push({ unit, indices: Interval.ofSingleton(seqIdx - offset) });
        break;
      }
      offset += unit.elements.length;
    }
    return element_exports.Loci(this.data.structure, lociElements);
  }
  constructor(data) {
    let length = 0;
    const unitIndices = /* @__PURE__ */ new Map();
    const lociElements = [];
    for (let i = 0, il = data.units.length; i < il; ++i) {
      const unit = data.units[i];
      length += unit.elements.length;
      const indices = Interval.ofBounds(0, unit.elements.length);
      unitIndices.set(unit.id, indices);
      lociElements.push({ unit, indices });
    }
    super(data, length);
    this.unitIndices = unitIndices;
  }
};

// node_modules/molstar/lib/mol-plugin-ui/sequence.js
var MaxDisplaySequenceLength = 5e3;
var MaxSelectOptionsCount = 1e3;
var MaxSequenceWrappersCount = 30;
function opKey(l) {
  const ids = StructureProperties.unit.pdbx_struct_oper_list_ids(l);
  const ncs = StructureProperties.unit.struct_ncs_oper_id(l);
  const hkl = StructureProperties.unit.hkl(l);
  const spgrOp = StructureProperties.unit.spgrOp(l);
  return `${ids.sort().join(",")}|${ncs}|${hkl}|${spgrOp}`;
}
function splitModelEntityId(modelEntityId) {
  const [modelIdx, entityId] = modelEntityId.split("|");
  return [parseInt(modelIdx), entityId];
}
function getSequenceWrapper(state, structureSelection) {
  const { structure, modelEntityId, chainGroupId, operatorKey } = state;
  const l = element_exports.Location.create(structure);
  const [modelIdx, entityId] = splitModelEntityId(modelEntityId);
  const units = [];
  for (const unit of structure.units) {
    element_exports.Location.set(l, structure, unit, unit.elements[0]);
    if (structure.getModelIndex(unit.model) !== modelIdx)
      continue;
    if (StructureProperties.entity.id(l) !== entityId)
      continue;
    if (unit.chainGroupId !== chainGroupId)
      continue;
    if (opKey(l) !== operatorKey)
      continue;
    units.push(unit);
  }
  if (units.length > 0) {
    const data = { structure, units };
    const unit = units[0];
    let sw;
    if (unit.polymerElements.length) {
      const l2 = element_exports.Location.create(structure, unit, unit.elements[0]);
      const entitySeq = unit.model.sequence.byEntityKey[StructureProperties.entity.key(l2)];
      if (entitySeq && entitySeq.sequence.length <= MaxDisplaySequenceLength) {
        sw = new PolymerSequenceWrapper(data);
      } else {
        const polymerElementCount = units.reduce((a4, v2) => a4 + v2.polymerElements.length, 0);
        if (Unit.isAtomic(unit) || polymerElementCount > MaxDisplaySequenceLength) {
          sw = new ChainSequenceWrapper(data);
        } else {
          sw = new ElementSequenceWrapper(data);
        }
      }
    } else if (Unit.isAtomic(unit)) {
      const residueCount = units.reduce((a4, v2) => a4 + v2.residueCount, 0);
      if (residueCount > MaxDisplaySequenceLength) {
        sw = new ChainSequenceWrapper(data);
      } else {
        sw = new HeteroSequenceWrapper(data);
      }
    } else {
      console.warn("should not happen, expecting coarse units to be polymeric");
      sw = new ChainSequenceWrapper(data);
    }
    sw.markResidue(structureSelection.getLoci(structure), MarkerAction.Select);
    return sw;
  } else {
    return "No sequence available";
  }
}
function getModelEntityOptions(structure, polymersOnly = false) {
  const options = [];
  const l = element_exports.Location.create(structure);
  const seen = /* @__PURE__ */ new Set();
  for (const unit of structure.units) {
    element_exports.Location.set(l, structure, unit, unit.elements[0]);
    const id = StructureProperties.entity.id(l);
    const modelIdx = structure.getModelIndex(unit.model);
    const key = `${modelIdx}|${id}`;
    if (seen.has(key))
      continue;
    if (polymersOnly && StructureProperties.entity.type(l) !== "polymer")
      continue;
    let description = StructureProperties.entity.pdbx_description(l).join(", ");
    if (structure.models.length) {
      if (structure.representativeModel) {
        description += ` (Model ${structure.models[modelIdx].modelNum})`;
      } else if (description.startsWith("Polymer ")) {
        description += ` (${structure.models[modelIdx].entry})`;
      }
    }
    const label = `${id}: ${description}`;
    options.push([key, label]);
    seen.add(key);
    if (options.length > MaxSelectOptionsCount) {
      return [["", "Too many entities"]];
    }
  }
  if (options.length === 0)
    options.push(["", "No entities"]);
  return options;
}
function getChainOptions(structure, modelEntityId) {
  const options = [];
  const l = element_exports.Location.create(structure);
  const seen = /* @__PURE__ */ new Set();
  const [modelIdx, entityId] = splitModelEntityId(modelEntityId);
  for (const unit of structure.units) {
    element_exports.Location.set(l, structure, unit, unit.elements[0]);
    if (structure.getModelIndex(unit.model) !== modelIdx)
      continue;
    if (StructureProperties.entity.id(l) !== entityId)
      continue;
    const id = unit.chainGroupId;
    if (seen.has(id))
      continue;
    const label = elementLabel(l, { granularity: "chain", hidePrefix: true, htmlStyling: false });
    options.push([id, label]);
    seen.add(id);
    if (options.length > MaxSelectOptionsCount) {
      return [[-1, "Too many chains"]];
    }
  }
  if (options.length === 0)
    options.push([-1, "No chains"]);
  return options;
}
function getOperatorOptions(structure, modelEntityId, chainGroupId) {
  const options = [];
  const l = element_exports.Location.create(structure);
  const seen = /* @__PURE__ */ new Set();
  const [modelIdx, entityId] = splitModelEntityId(modelEntityId);
  for (const unit of structure.units) {
    element_exports.Location.set(l, structure, unit, unit.elements[0]);
    if (structure.getModelIndex(unit.model) !== modelIdx)
      continue;
    if (StructureProperties.entity.id(l) !== entityId)
      continue;
    if (unit.chainGroupId !== chainGroupId)
      continue;
    const id = opKey(l);
    if (seen.has(id))
      continue;
    const label = unit.conformation.operator.name;
    options.push([id, label]);
    seen.add(id);
    if (options.length > MaxSelectOptionsCount) {
      return [["", "Too many operators"]];
    }
  }
  if (options.length === 0)
    options.push(["", "No operators"]);
  return options;
}
function getStructureOptions(state) {
  var _a;
  const options = [];
  const all2 = [];
  const structures = state.select(StateSelection.Generators.rootsOfType(PluginStateObject.Molecule.Structure));
  for (const s of structures) {
    if (!((_a = s.obj) === null || _a === void 0 ? void 0 : _a.data))
      continue;
    all2.push(s.obj.data);
    options.push([s.transform.ref, s.obj.data.label]);
  }
  if (options.length === 0)
    options.push(["", "No structure"]);
  return { options, all: all2 };
}
var SequenceViewModeParam = ParamDefinition.Select("single", [["single", "Chain"], ["polymers", "Polymers"], ["all", "Everything"]]);
var SequenceView = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = { structureOptions: { options: [], all: [] }, structure: Structure.Empty, structureRef: "", modelEntityId: "", chainGroupId: -1, operatorKey: "", mode: "single", sequenceViewModeParam: SequenceViewModeParam };
    this.setParamProps = (p) => {
      const state = { ...this.state };
      switch (p.name) {
        case "mode":
          state.mode = p.value;
          if (this.state.mode === state.mode)
            return;
          if (state.mode === "all" || state.mode === "polymers") {
            break;
          }
        case "structure":
          if (p.name === "structure")
            state.structureRef = p.value;
          state.structure = this.getStructure(state.structureRef);
          state.modelEntityId = getModelEntityOptions(state.structure)[0][0];
          state.chainGroupId = getChainOptions(state.structure, state.modelEntityId)[0][0];
          state.operatorKey = getOperatorOptions(state.structure, state.modelEntityId, state.chainGroupId)[0][0];
          break;
        case "entity":
          state.modelEntityId = p.value;
          state.chainGroupId = getChainOptions(state.structure, state.modelEntityId)[0][0];
          state.operatorKey = getOperatorOptions(state.structure, state.modelEntityId, state.chainGroupId)[0][0];
          break;
        case "chain":
          state.chainGroupId = p.value;
          state.operatorKey = getOperatorOptions(state.structure, state.modelEntityId, state.chainGroupId)[0][0];
          break;
        case "operator":
          state.operatorKey = p.value;
          break;
      }
      this.setState(state);
    };
  }
  componentDidMount() {
    var _a, _b;
    if (this.plugin.state.data.select(StateSelection.Generators.rootsOfType(PluginStateObject.Molecule.Structure)).length > 0)
      this.setState(this.getInitialState());
    this.subscribe(this.plugin.state.events.object.updated, ({ ref, obj }) => {
      if (ref === this.state.structureRef && obj && obj.type === PluginStateObject.Molecule.Structure.type && obj.data !== this.state.structure) {
        this.sync();
      }
    });
    this.subscribe(this.plugin.state.events.object.created, ({ obj }) => {
      if (obj && obj.type === PluginStateObject.Molecule.Structure.type) {
        this.sync();
      }
    });
    this.subscribe(this.plugin.state.events.object.removed, ({ obj }) => {
      if (obj && obj.type === PluginStateObject.Molecule.Structure.type) {
        this.sync();
      }
    });
    const modeOptions = (_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.sequenceViewer) === null || _b === void 0 ? void 0 : _b.modeOptions;
    if (modeOptions) {
      const modeSet = new Set(modeOptions);
      const sequenceViewModeParam = {
        ...SequenceViewModeParam,
        options: SequenceViewModeParam.options.filter(([firstItem]) => modeSet.has(firstItem))
      };
      this.setState({ sequenceViewModeParam });
    }
  }
  sync() {
    const structureOptions = getStructureOptions(this.plugin.state.data);
    if (arrayEqual2(structureOptions.all, this.state.structureOptions.all))
      return;
    this.setState(this.getInitialState());
  }
  getStructure(ref) {
    const state = this.plugin.state.data;
    const cell = state.select(ref)[0];
    if (!ref || !cell || !cell.obj)
      return Structure.Empty;
    return cell.obj.data;
  }
  getSequenceWrapper(params) {
    return {
      wrapper: getSequenceWrapper(this.state, this.plugin.managers.structure.selection),
      label: `${ParamDefinition.optionLabel(params.chain, this.state.chainGroupId)} | ${ParamDefinition.optionLabel(params.entity, this.state.modelEntityId)}`
    };
  }
  getSequenceWrappers(params) {
    if (this.state.mode === "single")
      return [this.getSequenceWrapper(params)];
    const structure = this.getStructure(this.state.structureRef);
    const wrappers = [];
    for (const [modelEntityId, eLabel] of getModelEntityOptions(structure, this.state.mode === "polymers")) {
      for (const [chainGroupId, cLabel] of getChainOptions(structure, modelEntityId)) {
        for (const [operatorKey] of getOperatorOptions(structure, modelEntityId, chainGroupId)) {
          wrappers.push({
            wrapper: getSequenceWrapper({
              structure,
              modelEntityId,
              chainGroupId,
              operatorKey
            }, this.plugin.managers.structure.selection),
            label: `${cLabel} | ${eLabel}`
          });
          if (wrappers.length > MaxSequenceWrappersCount)
            return [];
        }
      }
    }
    return wrappers;
  }
  getInitialState() {
    var _a, _b, _c, _d;
    const structureOptions = getStructureOptions(this.plugin.state.data);
    const structureRef = structureOptions.options[0][0];
    const structure = this.getStructure(structureRef);
    let modelEntityId = getModelEntityOptions(structure)[0][0];
    let chainGroupId = getChainOptions(structure, modelEntityId)[0][0];
    let operatorKey = getOperatorOptions(structure, modelEntityId, chainGroupId)[0][0];
    if (this.state.structure && this.state.structure === structure) {
      modelEntityId = this.state.modelEntityId;
      chainGroupId = this.state.chainGroupId;
      operatorKey = this.state.operatorKey;
    }
    const defaultMode = (_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.sequenceViewer) === null || _b === void 0 ? void 0 : _b.defaultMode;
    const initialMode = (_d = (_c = this.props.defaultMode) !== null && _c !== void 0 ? _c : defaultMode) !== null && _d !== void 0 ? _d : "single";
    return { structureOptions, structure, structureRef, modelEntityId, chainGroupId, operatorKey, mode: initialMode, sequenceViewModeParam: this.state.sequenceViewModeParam };
  }
  get params() {
    const { structureOptions, structure, modelEntityId, chainGroupId } = this.state;
    const entityOptions = getModelEntityOptions(structure);
    const chainOptions = getChainOptions(structure, modelEntityId);
    const operatorOptions = getOperatorOptions(structure, modelEntityId, chainGroupId);
    return {
      structure: ParamDefinition.Select(structureOptions.options[0][0], structureOptions.options, { shortLabel: true }),
      entity: ParamDefinition.Select(entityOptions[0][0], entityOptions, { shortLabel: true }),
      chain: ParamDefinition.Select(chainOptions[0][0], chainOptions, { shortLabel: true, twoColumns: true, label: "Chain" }),
      operator: ParamDefinition.Select(operatorOptions[0][0], operatorOptions, { shortLabel: true, twoColumns: true }),
      mode: this.state.sequenceViewModeParam
    };
  }
  get values() {
    return {
      structure: this.state.structureRef,
      entity: this.state.modelEntityId,
      chain: this.state.chainGroupId,
      operator: this.state.operatorKey,
      mode: this.state.mode
    };
  }
  render() {
    if (this.getStructure(this.state.structureRef) === Structure.Empty) {
      return (0, import_jsx_runtime21.jsx)("div", { className: "msp-sequence", children: (0, import_jsx_runtime21.jsxs)("div", { className: "msp-sequence-select", children: [(0, import_jsx_runtime21.jsx)(Icon, { svg: HelpOutlineSvg, style: { cursor: "help", position: "absolute", right: 0, top: 0 }, title: "Shows a sequence of one or more chains. Use the controls to alter selection." }), (0, import_jsx_runtime21.jsx)("span", { children: "Sequence" }), (0, import_jsx_runtime21.jsx)("span", { style: { fontWeight: "normal" }, children: "No structure available" })] }) });
    }
    const params = this.params;
    const values2 = this.values;
    const sequenceWrappers = this.getSequenceWrappers(params);
    return (0, import_jsx_runtime21.jsxs)("div", { className: "msp-sequence", children: [(0, import_jsx_runtime21.jsxs)("div", { className: "msp-sequence-select", children: [(0, import_jsx_runtime21.jsx)(Icon, { svg: HelpOutlineSvg, style: { cursor: "help", position: "absolute", right: 0, top: 0 }, title: "This shows a single sequence. Use the controls to show a different sequence. \nUse Ctrl or Cmd key to add a sequence range to focus; use Shift key to extend last focused/selected range." }), (0, import_jsx_runtime21.jsx)("span", { children: "Sequence of" }), (0, import_jsx_runtime21.jsx)(PureSelectControl, { title: `[Structure] ${ParamDefinition.optionLabel(params.structure, values2.structure)}`, param: params.structure, name: "structure", value: values2.structure, onChange: this.setParamProps }), (0, import_jsx_runtime21.jsx)(PureSelectControl, { title: `[Mode]`, param: this.state.sequenceViewModeParam, name: "mode", value: values2.mode, onChange: this.setParamProps }), values2.mode === "single" && (0, import_jsx_runtime21.jsx)(PureSelectControl, { title: `[Entity] ${ParamDefinition.optionLabel(params.entity, values2.entity)}`, param: params.entity, name: "entity", value: values2.entity, onChange: this.setParamProps }), values2.mode === "single" && (0, import_jsx_runtime21.jsx)(PureSelectControl, { title: `[Chain] ${ParamDefinition.optionLabel(params.chain, values2.chain)}`, param: params.chain, name: "chain", value: values2.chain, onChange: this.setParamProps }), params.operator.options.length > 1 && (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, { children: (0, import_jsx_runtime21.jsx)(PureSelectControl, { title: `[Instance] ${ParamDefinition.optionLabel(params.operator, values2.operator)}`, param: params.operator, name: "operator", value: values2.operator, onChange: this.setParamProps }) })] }), (0, import_jsx_runtime21.jsx)(NonEmptySequenceWrapper, { children: sequenceWrappers.map((s, i) => {
      const elem = typeof s.wrapper === "string" ? (0, import_jsx_runtime21.jsx)("div", { className: "msp-sequence-wrapper", children: s.wrapper }, i) : (0, import_jsx_runtime21.jsx)(Sequence, { sequenceWrapper: s.wrapper }, i);
      if (values2.mode === "single")
        return elem;
      return (0, import_jsx_runtime21.jsxs)(React6.Fragment, { children: [(0, import_jsx_runtime21.jsx)("div", { className: "msp-sequence-chain-label", children: s.label }), elem] }, i);
    }) })] });
  }
};
function NonEmptySequenceWrapper({ children }) {
  return (0, import_jsx_runtime21.jsx)("div", { className: "msp-sequence-wrapper-non-empty", children });
}

// node_modules/molstar/lib/mol-plugin-ui/task.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/molstar/lib/mol-plugin-ui/hooks/use-behavior.js
var import_react2 = __toESM(require_react());
function useBehaviorLegacy(s) {
  const [, next] = import_react2.default.useState({});
  const current = import_react2.default.useRef();
  current.current = s === null || s === void 0 ? void 0 : s.value;
  import_react2.default.useEffect(() => {
    if (!s) {
      return;
    }
    const sub = s.subscribe((v2) => {
      if (current.current !== v2)
        next({});
    });
    return () => sub.unsubscribe();
  }, [s]);
  return s === null || s === void 0 ? void 0 : s.value;
}
function useBehaviorReact18(s) {
  return import_react2.default.useSyncExternalStore(import_react2.default.useCallback((callback) => {
    const sub = s === null || s === void 0 ? void 0 : s.pipe(skip(1)).subscribe(callback);
    return () => sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  }, [s]), import_react2.default.useCallback(() => s === null || s === void 0 ? void 0 : s.value, [s]));
}
var _useBehavior = !!import_react2.default.useSyncExternalStore ? useBehaviorReact18 : useBehaviorLegacy;
function useBehavior(s) {
  return _useBehavior(s);
}

// node_modules/molstar/lib/mol-plugin-ui/task.js
function BackgroundTaskProgress() {
  const plugin = (0, import_react3.useContext)(PluginReactContext);
  const [tracked, setTracked] = (0, import_react3.useState)(OrderedMap());
  (0, import_react3.useEffect)(() => {
    const started = plugin.events.task.progress.subscribe((e) => {
      var _a;
      const hideOverlay = !!((_a = plugin.spec.components) === null || _a === void 0 ? void 0 : _a.hideTaskOverlay);
      if (e.level === "background" && (hideOverlay || !e.useOverlay)) {
        setTracked((tracked2) => tracked2.set(e.id, e));
      }
    });
    const finished = plugin.events.task.finished.subscribe(({ id }) => {
      setTracked((tracked2) => tracked2.delete(id));
    });
    return () => {
      started.unsubscribe();
      finished.unsubscribe();
    };
  }, [plugin]);
  return (0, import_jsx_runtime22.jsxs)("div", { className: "msp-background-tasks", children: [tracked.valueSeq().map((e) => (0, import_jsx_runtime22.jsx)(ProgressEntry, { event: e }, e.id)), (0, import_jsx_runtime22.jsx)(CanvasCommitState, {})] });
}
function CanvasCommitState() {
  var _a;
  const plugin = (0, import_react3.useContext)(PluginReactContext);
  const queueSize = useBehavior((_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.commitQueueSize);
  if (!queueSize)
    return null;
  return (0, import_jsx_runtime22.jsx)("div", { className: "msp-task-state", children: (0, import_jsx_runtime22.jsx)("div", { children: (0, import_jsx_runtime22.jsxs)("div", { children: ["Commiting renderables... ", queueSize, " remaining"] }) }) });
}
var ProgressEntry = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.abort = () => {
      this.plugin.managers.task.requestAbort(this.props.event.progress.root.progress.taskId, "User Request");
    };
  }
  render() {
    const root3 = this.props.event.progress.root;
    const subtaskCount = countSubtasks(this.props.event.progress.root) - 1;
    const pr = root3.progress.isIndeterminate ? void 0 : (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, { children: ["[", root3.progress.current, "/", root3.progress.max, "]"] });
    const subtasks = subtaskCount > 0 ? (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, { children: ["[", subtaskCount, " subtask(s)]"] }) : void 0;
    return (0, import_jsx_runtime22.jsx)("div", { className: "msp-task-state", children: (0, import_jsx_runtime22.jsxs)("div", { children: [root3.progress.canAbort && (0, import_jsx_runtime22.jsx)(IconButton, { svg: CancelSvg, onClick: this.abort, title: "Abort" }), (0, import_jsx_runtime22.jsxs)("div", { children: [root3.progress.message, " ", pr, " ", subtasks] })] }) });
  }
};
function countSubtasks(progress) {
  if (progress.children.length === 0)
    return 1;
  let sum = 0;
  for (const c4 of progress.children)
    sum += countSubtasks(c4);
  return sum;
}
function OverlayTaskProgress() {
  const plugin = (0, import_react3.useContext)(PluginReactContext);
  const [tracked, setTracked] = (0, import_react3.useState)(OrderedMap());
  (0, import_react3.useEffect)(() => {
    const started = plugin.events.task.progress.subscribe((e) => {
      if (!!e.useOverlay) {
        setTracked((tracked2) => tracked2.set(e.id, e));
      }
    });
    const finished = plugin.events.task.finished.subscribe(({ id }) => {
      setTracked((tracked2) => tracked2.delete(id));
    });
    return () => {
      started.unsubscribe();
      finished.unsubscribe();
    };
  }, [plugin]);
  if (tracked.size === 0)
    return null;
  return (0, import_jsx_runtime22.jsx)("div", { className: "msp-overlay-tasks", children: tracked.valueSeq().map((e) => (0, import_jsx_runtime22.jsx)(ProgressEntry, { event: e }, e.id)) });
}

// node_modules/molstar/lib/mol-plugin-ui/toast.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var ToastEntry = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.hide = () => {
      const entry = this.props.entry;
      (entry.hide || function() {
      }).call(null);
    };
  }
  render() {
    const entry = this.props.entry;
    const message = typeof entry.message === "string" ? (0, import_jsx_runtime23.jsx)("div", { dangerouslySetInnerHTML: { __html: entry.message } }) : (0, import_jsx_runtime23.jsx)("div", { children: (0, import_jsx_runtime23.jsx)(entry.message, {}) });
    return (0, import_jsx_runtime23.jsxs)("div", { className: "msp-toast-entry", children: [(0, import_jsx_runtime23.jsx)("div", { className: "msp-toast-title", onClick: () => this.hide(), children: entry.title }), (0, import_jsx_runtime23.jsx)("div", { className: "msp-toast-message", children: message }), (0, import_jsx_runtime23.jsx)("div", { className: "msp-toast-clear" }), (0, import_jsx_runtime23.jsx)("div", { className: "msp-toast-hide", children: (0, import_jsx_runtime23.jsx)(IconButton, { svg: CancelSvg, onClick: this.hide, title: "Hide", className: "msp-no-hover-outline" }) })] });
  }
};
var Toasts = class extends PluginUIComponent {
  componentDidMount() {
    this.subscribe(this.plugin.managers.toast.events.changed, () => this.forceUpdate());
  }
  render() {
    const state = this.plugin.managers.toast.state;
    if (!state.entries.count())
      return null;
    const entries = [];
    state.entries.forEach((t4, k) => entries.push(t4));
    entries.sort(function(x, y) {
      return x.serialNumber - y.serialNumber;
    });
    return (0, import_jsx_runtime23.jsx)("div", { className: "msp-toast-container", children: entries.map((e) => (0, import_jsx_runtime23.jsx)(ToastEntry, { entry: e }, e.serialNumber)) });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/viewport.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-ui/viewport/canvas.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var React8 = __toESM(require_react());
var ViewportCanvas = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.container = React8.createRef();
    this.state = {
      noWebGl: false,
      showLogo: true
    };
    this.handleLogo = () => {
      var _a;
      this.setState({ showLogo: !((_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.reprCount.value) });
    };
  }
  componentDidMount() {
    if (!this.container.current || !this.plugin.mount(this.container.current, { checkeredCanvasBackground: true })) {
      this.setState({ noWebGl: true });
      return;
    }
    this.handleLogo();
    this.subscribe(this.plugin.canvas3d.reprCount, this.handleLogo);
  }
  componentWillUnmount() {
    super.componentWillUnmount();
    this.plugin.unmount();
  }
  renderMissing() {
    if (this.props.noWebGl) {
      const C = this.props.noWebGl;
      return (0, import_jsx_runtime24.jsx)(C, {});
    }
    return (0, import_jsx_runtime24.jsx)("div", { className: "msp-no-webgl", children: (0, import_jsx_runtime24.jsxs)("div", { children: [(0, import_jsx_runtime24.jsx)("p", { children: (0, import_jsx_runtime24.jsx)("b", { children: "WebGL does not seem to be available." }) }), (0, import_jsx_runtime24.jsx)("p", { children: "This can be caused by an outdated browser, graphics card driver issue, or bad weather. Sometimes, just restarting the browser helps. Also, make sure hardware acceleration is enabled in your browser." }), (0, import_jsx_runtime24.jsxs)("p", { children: ["For a list of supported browsers, refer to ", (0, import_jsx_runtime24.jsx)("a", { href: "http://caniuse.com/#feat=webgl", target: "_blank", children: "http://caniuse.com/#feat=webgl" }), "."] })] }) });
  }
  render() {
    if (this.state.noWebGl)
      return this.renderMissing();
    const Logo2 = this.props.logo;
    return (0, import_jsx_runtime24.jsx)("div", { className: this.props.parentClassName || "msp-viewport", style: this.props.parentStyle, ref: this.container, children: this.state.showLogo && Logo2 && (0, import_jsx_runtime24.jsx)(Logo2, {}) });
  }
};

// node_modules/molstar/lib/mol-plugin-ui/viewport/screenshot.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-plugin-ui/controls/screenshot.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var React9 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var _ScreenshotPreview = (props) => {
  const { plugin, cropFrameColor } = props;
  const helper = plugin.helpers.viewportScreenshot;
  const [currentCanvas, setCurrentCanvas] = (0, import_react4.useState)(null);
  const canvasRef = (0, import_react4.useRef)(null);
  const propsRef = (0, import_react4.useRef)(props);
  (0, import_react4.useEffect)(() => {
    propsRef.current = props;
  }, Object.values(props));
  (0, import_react4.useEffect)(() => {
    if (currentCanvas !== canvasRef.current) {
      setCurrentCanvas(canvasRef.current);
    }
  });
  (0, import_react4.useEffect)(() => {
    var _a;
    let isDirty = false;
    const subs = [];
    function subscribe(xs, f) {
      if (!xs)
        return;
      subs.push(xs.subscribe(f));
    }
    function preview() {
      const p = propsRef.current;
      if (!p.suspend && canvasRef.current) {
        drawPreview(plugin, helper, canvasRef.current, p.customBackground, p.borderColor, p.borderWidth);
      }
      if (!canvasRef.current)
        isDirty = true;
    }
    const interval = setInterval(() => {
      if (isDirty) {
        isDirty = false;
        preview();
      }
    }, 1e3 / 8);
    subscribe(plugin.events.canvas3d.settingsUpdated, () => isDirty = true);
    subscribe((_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.didDraw, () => isDirty = true);
    subscribe(plugin.state.data.behaviors.isUpdating, (v2) => {
      if (!v2)
        isDirty = true;
    });
    subscribe(helper === null || helper === void 0 ? void 0 : helper.behaviors.values, () => isDirty = true);
    subscribe(helper === null || helper === void 0 ? void 0 : helper.behaviors.cropParams, () => isDirty = true);
    let resizeObserver = void 0;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(() => isDirty = true);
    }
    const canvas = canvasRef.current;
    resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(canvas);
    preview();
    return () => {
      clearInterval(interval);
      subs.forEach((s) => s.unsubscribe());
      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.unobserve(canvas);
    };
  }, [helper]);
  (0, import_react4.useLayoutEffect)(() => {
    if (canvasRef.current) {
      drawPreview(plugin, helper, canvasRef.current, props.customBackground, props.borderColor, props.borderWidth);
    }
  }, [...Object.values(props)]);
  return (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children: (0, import_jsx_runtime25.jsxs)("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [(0, import_jsx_runtime25.jsx)("canvas", { ref: canvasRef, onContextMenu: (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, style: { display: "block", width: "100%", height: "100%" } }), (0, import_jsx_runtime25.jsx)(ViewportFrame, { plugin, canvas: currentCanvas, color: cropFrameColor })] }) });
};
var ScreenshotPreview = React9.memo(_ScreenshotPreview, (prev, next) => shallowEqual2(prev, next));
async function drawPreview(plugin, helper, target, customBackground, borderColor, borderWidth) {
  const task = Task.create("Render Screenshot", async (runtime) => {
    if (!helper)
      return;
    const p = await helper.getPreview(runtime);
    if (!p)
      return;
    const ctx = target.getContext("2d");
    if (!ctx)
      return;
    const { canvas, width, height } = p;
    const w = target.clientWidth;
    const h = target.clientHeight;
    target.width = w;
    target.height = h;
    ctx.clearRect(0, 0, w, h);
    const frame = getViewportFrame(width, height, w, h);
    if (customBackground) {
      ctx.fillStyle = customBackground;
      ctx.fillRect(frame.x, frame.y, frame.width, frame.height);
    } else if (helper.values.transparent) {
      const s = 13;
      for (let i = 0; i < frame.width; i += s) {
        for (let j = 0; j < frame.height; j += s) {
          ctx.fillStyle = (i + j) % 2 ? "#ffffff" : "#bfbfbf";
          const x = frame.x + i, y = frame.y + j;
          const w2 = i + s > frame.width ? frame.width - i : s;
          const h2 = j + s > frame.height ? frame.height - j : s;
          ctx.fillRect(x, y, w2, h2);
        }
      }
    }
    ctx.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
    if (borderColor && borderWidth) {
      const w2 = borderWidth;
      ctx.rect(frame.x, frame.y, frame.width, frame.height);
      ctx.rect(frame.x + w2, frame.y + w2, frame.width - 2 * w2, frame.height - 2 * w2);
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
  });
  return plugin.runTask(task, { useOverlay: true });
}
function ViewportFrame({ plugin, canvas, color: color2 = "rgba(255, 87, 45, 0.75)" }) {
  var _a;
  const helper = plugin.helpers.viewportScreenshot;
  const params = useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.values);
  const cropParams = useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.cropParams);
  const crop = useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.relativeCrop);
  const cropFrameRef = (0, import_react4.useRef)({ x: 0, y: 0, width: 0, height: 0 });
  useBehavior((params === null || params === void 0 ? void 0 : params.resolution.name) === "viewport" ? (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.resized : void 0);
  const [drag, setDrag] = React9.useState("");
  const [start2, setStart] = (0, import_react4.useState)([0, 0]);
  const [current, setCurrent] = (0, import_react4.useState)([0, 0]);
  if (!helper || !canvas || !crop)
    return null;
  const { width, height } = helper.getSizeAndViewport();
  const frame = getViewportFrame(width, height, canvas.clientWidth, canvas.clientHeight);
  const cropFrame = {
    x: frame.x + Math.floor(frame.width * crop.x),
    y: frame.y + Math.floor(frame.height * crop.y),
    width: Math.ceil(frame.width * crop.width),
    height: Math.ceil(frame.height * crop.height)
  };
  const rectCrop = toRect(cropFrame);
  const rectFrame = toRect(frame);
  if (drag === "move") {
    rectCrop.l += current[0] - start2[0];
    rectCrop.r += current[0] - start2[0];
    rectCrop.t += current[1] - start2[1];
    rectCrop.b += current[1] - start2[1];
  } else if (drag) {
    if (drag.indexOf("left") >= 0) {
      rectCrop.l += current[0] - start2[0];
    } else if (drag.indexOf("right") >= 0) {
      rectCrop.r += current[0] - start2[0];
    }
    if (drag.indexOf("top") >= 0) {
      rectCrop.t += current[1] - start2[1];
    } else if (drag.indexOf("bottom") >= 0) {
      rectCrop.b += current[1] - start2[1];
    }
  }
  if (rectCrop.l > rectCrop.r) {
    const t4 = rectCrop.l;
    rectCrop.l = rectCrop.r;
    rectCrop.r = t4;
  }
  if (rectCrop.t > rectCrop.b) {
    const t4 = rectCrop.t;
    rectCrop.t = rectCrop.b;
    rectCrop.b = t4;
  }
  const pad = 40;
  rectCrop.l = Math.min(rectFrame.r - pad, Math.max(rectFrame.l, rectCrop.l));
  rectCrop.r = Math.max(rectFrame.l + pad, Math.min(rectFrame.r, rectCrop.r));
  rectCrop.t = Math.min(rectFrame.b - pad, Math.max(rectFrame.t, rectCrop.t));
  rectCrop.b = Math.max(rectFrame.t + pad, Math.min(rectFrame.b, rectCrop.b));
  cropFrame.x = rectCrop.l;
  cropFrame.y = rectCrop.t;
  cropFrame.width = rectCrop.r - rectCrop.l + 1;
  cropFrame.height = rectCrop.b - rectCrop.t + 1;
  cropFrameRef.current = cropFrame;
  const onMove = (e) => {
    e.preventDefault();
    setCurrent([e.pageX, e.pageY]);
  };
  const onTouchMove = (e) => {
    e.preventDefault();
    const t4 = e.touches[0];
    setCurrent([t4.pageX, t4.pageY]);
  };
  const onTouchStart = (e) => {
    e.preventDefault();
    setDrag(e.currentTarget.getAttribute("data-drag"));
    const t4 = e.touches[0];
    const p = [t4.pageX, t4.pageY];
    setStart(p);
    setCurrent(p);
    window.addEventListener("touchend", onTouchEnd);
    window.addEventListener("touchmove", onTouchMove);
  };
  const onStart = (e) => {
    e.preventDefault();
    setDrag(e.currentTarget.getAttribute("data-drag"));
    const p = [e.pageX, e.pageY];
    setStart(p);
    setCurrent(p);
    window.addEventListener("mouseup", onEnd);
    window.addEventListener("mousemove", onMove);
  };
  const onEnd = () => {
    window.removeEventListener("mouseup", onEnd);
    window.removeEventListener("mousemove", onMove);
    finish();
  };
  const onTouchEnd = () => {
    window.removeEventListener("touchend", onTouchEnd);
    window.removeEventListener("touchmove", onTouchMove);
    finish();
  };
  function finish() {
    const cropFrame2 = cropFrameRef.current;
    if (cropParams === null || cropParams === void 0 ? void 0 : cropParams.auto) {
      helper === null || helper === void 0 ? void 0 : helper.behaviors.cropParams.next({ ...cropParams, auto: false });
    }
    helper === null || helper === void 0 ? void 0 : helper.behaviors.relativeCrop.next({
      x: (cropFrame2.x - frame.x) / frame.width,
      y: (cropFrame2.y - frame.y) / frame.height,
      width: cropFrame2.width / frame.width,
      height: cropFrame2.height / frame.height
    });
    setDrag("");
    const p = [0, 0];
    setStart(p);
    setCurrent(p);
  }
  const contextMenu = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  const d3 = 4;
  const border = `3px solid ${color2}`;
  const transparent = "transparent";
  return (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, { children: [(0, import_jsx_runtime25.jsx)("div", { "data-drag": "move", style: { position: "absolute", left: cropFrame.x, top: cropFrame.y, width: cropFrame.width, height: cropFrame.height, border, cursor: "move" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "left", style: { position: "absolute", left: cropFrame.x - d3, top: cropFrame.y + d3, width: 4 * d3, height: cropFrame.height - d3, background: transparent, cursor: "w-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "right", style: { position: "absolute", left: rectCrop.r - 2 * d3, top: cropFrame.y, width: 4 * d3, height: cropFrame.height - d3, background: transparent, cursor: "w-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "top", style: { position: "absolute", left: cropFrame.x - d3, top: cropFrame.y - d3, width: cropFrame.width + 2 * d3, height: 4 * d3, background: transparent, cursor: "n-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "bottom", style: { position: "absolute", left: cropFrame.x - d3, top: rectCrop.b - 2 * d3, width: cropFrame.width + 2 * d3, height: 4 * d3, background: transparent, cursor: "n-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "top, left", style: { position: "absolute", left: rectCrop.l - d3, top: rectCrop.t - d3, width: 4 * d3, height: 4 * d3, background: transparent, cursor: "nw-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "bottom, right", style: { position: "absolute", left: rectCrop.r - 2 * d3, top: rectCrop.b - 2 * d3, width: 4 * d3, height: 4 * d3, background: transparent, cursor: "nw-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "top, right", style: { position: "absolute", left: rectCrop.r - 2 * d3, top: rectCrop.t - d3, width: 4 * d3, height: 4 * d3, background: transparent, cursor: "ne-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu }), (0, import_jsx_runtime25.jsx)("div", { "data-drag": "bottom, left", style: { position: "absolute", left: rectCrop.l - d3, top: rectCrop.b - 2 * d3, width: 4 * d3, height: 4 * d3, background: transparent, cursor: "ne-resize" }, onMouseDown: onStart, onTouchStart, draggable: false, onContextMenu: contextMenu })] });
}
function toRect(viewport) {
  return { l: viewport.x, t: viewport.y, r: viewport.x + viewport.width - 1, b: viewport.y + viewport.height - 1 };
}
function getViewportFrame(srcWidth, srcHeight, w, h) {
  const a0 = srcWidth / srcHeight;
  const a1 = w / h;
  if (a0 <= a1) {
    const t4 = h * a0;
    return { x: Math.round((w - t4) / 2), y: 0, width: Math.round(t4), height: h };
  } else {
    const t4 = w / a0;
    return { x: 0, y: Math.round((h - t4) / 2), width: w, height: Math.round(t4) };
  }
}

// node_modules/molstar/lib/mol-plugin-ui/viewport/screenshot.js
var import_react5 = __toESM(require_react());

// node_modules/molstar/lib/mol-util/camera.js
function distanceAdjustment(mode, fov) {
  if (mode === "orthographic")
    return 1 / (2 * Math.tan(fov / 2));
  else
    return 1 / (2 * Math.sin(fov / 2));
}
function fovNormalizedCameraPosition(target, refPosition, mode, fov) {
  const delta = Vec3.sub(Vec3(), refPosition, target);
  const adjustment = distanceAdjustment(mode, fov) || 1;
  return Vec3.scaleAndAdd(delta, target, delta, 1 / adjustment);
}

// node_modules/molstar/lib/mol-plugin-ui/viewport/screenshot.js
var DownloadScreenshotControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.state = {
      showPreview: true,
      isDisabled: false
    };
    this.download = () => {
      var _a;
      (_a = this.plugin.helpers.viewportScreenshot) === null || _a === void 0 ? void 0 : _a.download();
      this.props.close();
    };
    this.copy = async () => {
      var _a;
      try {
        await ((_a = this.plugin.helpers.viewportScreenshot) === null || _a === void 0 ? void 0 : _a.copyToClipboard());
        PluginCommands.Toast.Show(this.plugin, {
          message: "Copied to clipboard.",
          title: "Screenshot",
          timeoutMs: 1500
        });
      } catch (_b) {
        return this.copyImg();
      }
    };
    this.copyImg = async () => {
      var _a;
      const src = await ((_a = this.plugin.helpers.viewportScreenshot) === null || _a === void 0 ? void 0 : _a.getImageDataUri());
      this.setState({ imageData: src });
    };
    this.open = (e) => {
      if (!e.target.files || !e.target.files[0])
        return;
      PluginCommands.State.Snapshots.OpenFile(this.plugin, { file: e.target.files[0] });
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.state.data.behaviors.isUpdating, (v2) => {
      this.setState({ isDisabled: v2 });
    });
  }
  componentWillUnmount() {
    super.componentWillUnmount();
    this.setState({ imageData: void 0 });
  }
  render() {
    var _a;
    const hasClipboardApi = !!((_a = navigator.clipboard) === null || _a === void 0 ? void 0 : _a.write);
    return (0, import_jsx_runtime26.jsxs)("div", { children: [this.state.showPreview && (0, import_jsx_runtime26.jsxs)("div", { className: "msp-image-preview", children: [(0, import_jsx_runtime26.jsx)(ScreenshotPreview, { plugin: this.plugin }), (0, import_jsx_runtime26.jsx)(CropControls, { plugin: this.plugin })] }), (0, import_jsx_runtime26.jsxs)("div", { className: "msp-flex-row", children: [!this.state.imageData && (0, import_jsx_runtime26.jsx)(Button, { icon: CopySvg, onClick: hasClipboardApi ? this.copy : this.copyImg, disabled: this.state.isDisabled, children: "Copy" }), this.state.imageData && (0, import_jsx_runtime26.jsx)(Button, { onClick: () => this.setState({ imageData: void 0 }), disabled: this.state.isDisabled, children: "Clear" }), (0, import_jsx_runtime26.jsx)(Button, { icon: GetAppSvg, onClick: this.download, disabled: this.state.isDisabled, children: "Download" })] }), this.state.imageData && (0, import_jsx_runtime26.jsxs)("div", { className: "msp-row msp-copy-image-wrapper", children: [(0, import_jsx_runtime26.jsx)("div", { children: "Right click below + Copy Image" }), (0, import_jsx_runtime26.jsx)("img", { src: this.state.imageData, style: { width: "100%", height: 32, display: "block" } })] }), (0, import_jsx_runtime26.jsx)(ScreenshotParams, { plugin: this.plugin, isDisabled: this.state.isDisabled }), (0, import_jsx_runtime26.jsxs)(ExpandGroup, { header: "State", children: [(0, import_jsx_runtime26.jsx)(StateExportImportControls, { onAction: this.props.close }), (0, import_jsx_runtime26.jsx)(ExpandGroup, { header: "Save Options", initiallyExpanded: false, noOffset: true, children: (0, import_jsx_runtime26.jsx)(LocalStateSnapshotParams, {}) })] }), (0, import_jsx_runtime26.jsx)(ExpandGroup, { header: "Camera", children: (0, import_jsx_runtime26.jsx)(CameraInfo, { plugin: this.plugin }) })] });
  }
};
function renderVector(v2) {
  return `${v2 === null || v2 === void 0 ? void 0 : v2.map((v3) => round(v3, 2)).join(", ")}`;
}
function CameraInfoSection({ title, children }) {
  return (0, import_jsx_runtime26.jsxs)("div", { className: "msp-control-row", children: [(0, import_jsx_runtime26.jsx)("span", { className: "msp-control-row-label", children: title }), (0, import_jsx_runtime26.jsx)("div", { className: "msp-control-row-text", style: { fontSize: "0.85rem", overflow: "hidden", whiteSpace: "nowrap" }, children })] });
}
function normalizedCameraPosition(camera) {
  if (!camera)
    return;
  return fovNormalizedCameraPosition(camera.target, camera.position, camera.mode, camera.fov);
}
function CameraInfo({ plugin }) {
  var _a, _b, _c, _d, _e, _f;
  const [, setUpdate] = (0, import_react5.useState)({});
  (0, import_react5.useEffect)(() => {
    var _a2;
    const sub = (_a2 = plugin.canvas3d) === null || _a2 === void 0 ? void 0 : _a2.didDraw.subscribe(() => setUpdate({}));
    return () => sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  }, [plugin]);
  const state = (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera.state;
  const fovNormalized = normalizedCameraPosition(state);
  const direction = Vec3.sub(Vec3(), (_b = state === null || state === void 0 ? void 0 : state.target) !== null && _b !== void 0 ? _b : Vec3.origin, (_c = state === null || state === void 0 ? void 0 : state.position) !== null && _c !== void 0 ? _c : Vec3.origin);
  Vec3.normalize(direction, direction);
  return (0, import_jsx_runtime26.jsxs)("div", { children: [(0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Position", children: renderVector(state === null || state === void 0 ? void 0 : state.position) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "FoV Norm. Pos.", children: renderVector(fovNormalized) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Target", children: renderVector(state === null || state === void 0 ? void 0 : state.target) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Direction", children: renderVector(direction) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Up", children: renderVector(state === null || state === void 0 ? void 0 : state.up) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Distance", children: round(Vec3.distance((_d = state === null || state === void 0 ? void 0 : state.position) !== null && _d !== void 0 ? _d : Vec3.origin, (_e = state === null || state === void 0 ? void 0 : state.target) !== null && _e !== void 0 ? _e : Vec3.origin), 2) }), (0, import_jsx_runtime26.jsx)(CameraInfoSection, { title: "Radius", children: round((_f = state === null || state === void 0 ? void 0 : state.radius) !== null && _f !== void 0 ? _f : 0, 2) }), (0, import_jsx_runtime26.jsx)(Button, { onClick: () => {
    if (!navigator.clipboard)
      return;
    const ret = `{
    position: [${fovNormalized === null || fovNormalized === void 0 ? void 0 : fovNormalized.map((v2) => round(v2, 2)).join(", ")}],
    target: [${state === null || state === void 0 ? void 0 : state.target.map((v2) => round(v2, 2)).join(", ")}],
    up: [${state === null || state === void 0 ? void 0 : state.up.map((v2) => round(v2, 2)).join(", ")}],
}`;
    navigator.clipboard.writeText(ret);
  }, style: { marginTop: 1 }, title: "Copy JSON usable in MolViewSpec, uses FoV Normalized Position", children: "Copy MVS JSON" })] });
}
function ScreenshotParams({ plugin, isDisabled }) {
  const helper = plugin.helpers.viewportScreenshot;
  const values2 = useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.values);
  if (!helper)
    return null;
  return (0, import_jsx_runtime26.jsx)(ParameterControls, { params: helper.params, values: values2, onChangeValues: (v2) => helper.behaviors.values.next(v2), isDisabled });
}
function CropControls({ plugin }) {
  const helper = plugin.helpers.viewportScreenshot;
  const cropParams = useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.cropParams);
  useBehavior(helper === null || helper === void 0 ? void 0 : helper.behaviors.relativeCrop);
  if (!helper || !cropParams)
    return null;
  return (0, import_jsx_runtime26.jsxs)("div", { style: { width: "100%", height: "24px", marginTop: "8px" }, children: [(0, import_jsx_runtime26.jsx)(ToggleButton, { icon: CropOrginalSvg, title: "Auto-crop", inline: true, isSelected: cropParams.auto, style: { background: "transparent", float: "left", width: "auto", height: "24px", lineHeight: "24px" }, toggle: () => helper.toggleAutocrop(), label: "Auto-crop " + (cropParams.auto ? "On" : "Off") }), !cropParams.auto && (0, import_jsx_runtime26.jsx)(Button, { icon: CropSvg, title: "Crop", style: { background: "transparent", float: "right", height: "24px", lineHeight: "24px", width: "24px", padding: "0" }, onClick: () => helper.autocrop() }), !cropParams.auto && !helper.isFullFrame && (0, import_jsx_runtime26.jsx)(Button, { icon: CropFreeSvg, title: "Reset Crop", style: { background: "transparent", float: "right", height: "24px", lineHeight: "24px", width: "24px", padding: "0" }, onClick: () => helper.resetCrop() })] });
}

// node_modules/molstar/lib/mol-plugin-ui/viewport/simple-settings.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());

// node_modules/molstar/lib/mol-util/param-mapping.js
function ParamMapping(def) {
  return ({ values: values2, update, apply }) => ({
    params: typeof def.params === "function" ? def.params : (ctx) => def.params,
    getTarget: def.target,
    getValues: values2,
    update(s, ctx) {
      const t4 = def.target(ctx);
      return produce(t4, (t1) => update(s, t1, ctx));
    },
    apply: apply ? apply : () => {
    }
  });
}

// node_modules/molstar/lib/mol-plugin-ui/viewport/simple-settings.js
var SimpleSettingsControl = class extends PluginUIComponent {
  componentDidMount() {
    if (!this.plugin.canvas3d)
      return;
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
    this.subscribe(this.plugin.canvas3d.camera.stateChanged.pipe(throttleTime(500, void 0, { leading: true, trailing: true })), (state) => {
      if (state.radiusMax !== void 0 || state.radius !== void 0) {
        this.forceUpdate();
      }
    });
  }
  render() {
    if (!this.plugin.canvas3d)
      return null;
    return (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [(0, import_jsx_runtime27.jsx)(ParameterMappingControl, { mapping: SimpleSettingsMapping }), (0, import_jsx_runtime27.jsx)(ViewportHelpContent, {})] });
  }
};
var LayoutOptions = {
  "sequence": "Sequence",
  "log": "Log",
  "left": "Left Panel",
  "right": "Right Panel"
};
var SimpleSettingsParams = {
  animate: Canvas3DParams.trackball.params.animate,
  camera: Canvas3DParams.camera,
  background: ParamDefinition.Group({
    color: ParamDefinition.Color(Color(16579577), { label: "Background", description: "Custom background color" }),
    transparent: ParamDefinition.Boolean(false),
    style: Canvas3DParams.postprocessing.params.background
  }, { pivot: "color" }),
  lighting: ParamDefinition.Group({
    occlusion: Canvas3DParams.postprocessing.params.occlusion,
    shadow: Canvas3DParams.postprocessing.params.shadow,
    outline: Canvas3DParams.postprocessing.params.outline,
    dof: Canvas3DParams.postprocessing.params.dof,
    fog: Canvas3DParams.cameraFog
  }, { isFlat: true }),
  clipping: ParamDefinition.Group({
    ...Canvas3DParams.cameraClipping.params
  }, { pivot: "radius" }),
  layout: ParamDefinition.MultiSelect([], ParamDefinition.objectToOptions(LayoutOptions)),
  advanced: ParamDefinition.Group({
    illumination: Canvas3DParams.illumination,
    multiSample: Canvas3DParams.multiSample,
    hiZ: Canvas3DParams.hiZ,
    sharpening: Canvas3DParams.postprocessing.params.sharpening,
    bloom: Canvas3DParams.postprocessing.params.bloom,
    resolutionMode: Canvas3DContext.Params.resolutionMode,
    pixelScale: Canvas3DContext.Params.pixelScale,
    transparency: Canvas3DContext.Params.transparency
  })
};
var SimpleSettingsMapping = ParamMapping({
  params: (ctx) => {
    var _a;
    const params = ParamDefinition.clone(SimpleSettingsParams);
    const controls = (_a = ctx.spec.components) === null || _a === void 0 ? void 0 : _a.controls;
    if (controls) {
      const options = [];
      if (controls.top !== "none")
        options.push(["sequence", LayoutOptions.sequence]);
      if (controls.bottom !== "none")
        options.push(["log", LayoutOptions.log]);
      if (controls.left !== "none")
        options.push(["left", LayoutOptions.left]);
      if (controls.right !== "none")
        options.push(["right", LayoutOptions.right]);
      params.layout.options = options;
    }
    const bgStyles = ctx.config.get(PluginConfig.Background.Styles) || [];
    if (bgStyles.length > 0) {
      Object.assign(params.background.params.style, {
        presets: deepClone(bgStyles),
        isFlat: false
        // so the presets menu is shown
      });
    }
    return params;
  },
  target(ctx) {
    var _a, _b, _c;
    const c4 = (_a = ctx.spec.components) === null || _a === void 0 ? void 0 : _a.controls;
    const r = ctx.layout.state.regionState;
    const layout = [];
    if (r.top !== "hidden" && (!c4 || c4.top !== "none"))
      layout.push("sequence");
    if (r.bottom !== "hidden" && (!c4 || c4.bottom !== "none"))
      layout.push("log");
    if (r.left !== "hidden" && (!c4 || c4.left !== "none"))
      layout.push("left");
    if (r.right !== "hidden" && (!c4 || c4.right !== "none"))
      layout.push("right");
    const { pixelScale, transparency, resolutionMode } = (_b = ctx.canvas3dContext) === null || _b === void 0 ? void 0 : _b.props;
    return { canvas: (_c = ctx.canvas3d) === null || _c === void 0 ? void 0 : _c.props, layout, resolutionMode, pixelScale, transparency };
  }
})({
  values(props, ctx) {
    const { canvas } = props;
    const renderer = canvas.renderer;
    return {
      layout: props.layout,
      animate: canvas.trackball.animate,
      camera: canvas.camera,
      background: {
        color: renderer.backgroundColor,
        transparent: canvas.transparentBackground,
        style: canvas.postprocessing.background
      },
      lighting: {
        occlusion: canvas.postprocessing.occlusion,
        shadow: canvas.postprocessing.shadow,
        outline: canvas.postprocessing.outline,
        dof: canvas.postprocessing.dof,
        fog: canvas.cameraFog
      },
      clipping: {
        ...canvas.cameraClipping
      },
      advanced: {
        illumination: canvas.illumination,
        multiSample: canvas.multiSample,
        hiZ: canvas.hiZ,
        sharpening: canvas.postprocessing.sharpening,
        bloom: canvas.postprocessing.bloom,
        resolutionMode: props.resolutionMode,
        pixelScale: props.pixelScale,
        transparency: props.transparency
      }
    };
  },
  update(s, props) {
    const canvas = props.canvas;
    canvas.trackball.animate = s.animate;
    canvas.camera = s.camera;
    canvas.transparentBackground = s.background.transparent;
    canvas.renderer.backgroundColor = s.background.color;
    canvas.postprocessing.occlusion = s.lighting.occlusion;
    canvas.postprocessing.shadow = s.lighting.shadow;
    canvas.postprocessing.outline = s.lighting.outline;
    canvas.postprocessing.background = s.background.style;
    canvas.cameraFog = s.lighting.fog;
    canvas.cameraClipping = {
      radius: s.clipping.radius,
      far: s.clipping.far,
      minNear: s.clipping.minNear
    };
    canvas.illumination = s.advanced.illumination;
    canvas.multiSample = s.advanced.multiSample;
    canvas.hiZ = s.advanced.hiZ;
    canvas.postprocessing.sharpening = s.advanced.sharpening;
    canvas.postprocessing.bloom = s.advanced.bloom;
    canvas.postprocessing.dof = s.lighting.dof;
    props.layout = s.layout;
    props.resolutionMode = s.advanced.resolutionMode;
    props.pixelScale = s.advanced.pixelScale;
    props.transparency = s.advanced.transparency;
  },
  async apply(props, ctx) {
    var _a;
    await PluginCommands.Canvas3D.SetSettings(ctx, { settings: props.canvas });
    const hideLeft = props.layout.indexOf("left") < 0;
    const state = produce(ctx.layout.state, (s) => {
      s.regionState.top = props.layout.indexOf("sequence") >= 0 ? "full" : "hidden";
      s.regionState.bottom = props.layout.indexOf("log") >= 0 ? "full" : "hidden";
      s.regionState.left = hideLeft ? "hidden" : ctx.behaviors.layout.leftPanelTabName.value === "none" ? "collapsed" : "full";
      s.regionState.right = props.layout.indexOf("right") >= 0 ? "full" : "hidden";
    });
    await PluginCommands.Layout.Update(ctx, { state });
    if (hideLeft) {
      PluginCommands.State.SetCurrentObject(ctx, { state: ctx.state.data, ref: Transform.RootRef });
    }
    (_a = ctx.canvas3dContext) === null || _a === void 0 ? void 0 : _a.setProps({
      resolutionMode: props.resolutionMode,
      pixelScale: props.pixelScale,
      transparency: props.transparency
    });
  }
});

// node_modules/molstar/lib/mol-plugin-ui/viewport.js
var ViewportControls = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.allCollapsedState = {
      isSettingsExpanded: false,
      isScreenshotExpanded: false
    };
    this.state = {
      ...this.allCollapsedState,
      isCameraResetEnabled: true
    };
    this.resetCamera = () => {
      PluginCommands.Camera.Reset(this.plugin, {});
    };
    this.toggleSettingsExpanded = this.toggle("isSettingsExpanded");
    this.toggleScreenshotExpanded = this.toggle("isScreenshotExpanded");
    this.toggleControls = () => {
      PluginCommands.Layout.Update(this.plugin, { state: { showControls: !this.plugin.layout.state.showControls } });
    };
    this.toggleExpanded = () => {
      PluginCommands.Layout.Update(this.plugin, { state: { isExpanded: !this.plugin.layout.state.isExpanded } });
    };
    this.setSettings = (p) => {
      PluginCommands.Canvas3D.SetSettings(this.plugin, { settings: { [p.name]: p.value } });
    };
    this.setLayout = (p) => {
      PluginCommands.Layout.Update(this.plugin, { state: { [p.name]: p.value } });
    };
    this.screenshot = () => {
      var _a;
      (_a = this.plugin.helpers.viewportScreenshot) === null || _a === void 0 ? void 0 : _a.download();
    };
    this.enableCameraReset = (enable) => {
      this.setState((old) => ({ ...old, isCameraResetEnabled: enable }));
    };
  }
  toggle(panel) {
    return (e) => {
      this.setState((old) => ({ ...old, ...this.allCollapsedState, [panel]: !this.state[panel] }));
      e === null || e === void 0 ? void 0 : e.currentTarget.blur();
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.events.canvas3d.settingsUpdated, () => this.forceUpdate());
    this.subscribe(this.plugin.layout.events.updated, () => this.forceUpdate());
    if (this.plugin.canvas3d) {
      this.subscribe(this.plugin.canvas3d.camera.stateChanged.pipe(throttleTime(500, void 0, { leading: true, trailing: true })), (snapshot) => this.enableCameraReset(snapshot.radius !== 0 && snapshot.radiusMax !== 0));
    }
  }
  icon(icon, onClick, title, isOn = true) {
    return (0, import_jsx_runtime28.jsx)(IconButton, { svg: icon, toggleState: isOn, onClick, title, style: { background: "transparent" } });
  }
  render() {
    return (0, import_jsx_runtime28.jsxs)("div", { className: "msp-viewport-controls", children: [(0, import_jsx_runtime28.jsxs)("div", { className: "msp-viewport-controls-buttons", children: [(0, import_jsx_runtime28.jsxs)("div", { className: "msp-hover-box-wrapper", children: [(0, import_jsx_runtime28.jsx)("div", { className: "msp-semi-transparent-background" }), this.icon(AutorenewSvg, this.resetCamera, "Reset Zoom"), (0, import_jsx_runtime28.jsx)("div", { className: "msp-hover-box-body", children: (0, import_jsx_runtime28.jsxs)("div", { className: "msp-flex-column", children: [(0, import_jsx_runtime28.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime28.jsx)(Button, { onClick: () => this.resetCamera(), disabled: !this.state.isCameraResetEnabled, title: "Set camera zoom to fit the visible scene into view", children: "Reset Zoom" }) }), (0, import_jsx_runtime28.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime28.jsx)(Button, { onClick: () => PluginCommands.Camera.OrientAxes(this.plugin), disabled: !this.state.isCameraResetEnabled, title: "Align principal component axes of the loaded structures to the screen axes (lay flat)", children: "Orient Axes" }) }), (0, import_jsx_runtime28.jsx)("div", { className: "msp-flex-row", children: (0, import_jsx_runtime28.jsx)(Button, { onClick: () => PluginCommands.Camera.ResetAxes(this.plugin), disabled: !this.state.isCameraResetEnabled, title: "Align Cartesian axes to the screen axes", children: "Reset Axes" }) })] }) }), (0, import_jsx_runtime28.jsx)("div", { className: "msp-hover-box-spacer" })] }), this.plugin.config.get(PluginConfig.Viewport.ShowScreenshotControls) && (0, import_jsx_runtime28.jsxs)("div", { children: [(0, import_jsx_runtime28.jsx)("div", { className: "msp-semi-transparent-background" }), this.icon(CameraOutlinedSvg, this.toggleScreenshotExpanded, "Screenshot / State Snapshot", this.state.isScreenshotExpanded)] }), (0, import_jsx_runtime28.jsxs)("div", { children: [(0, import_jsx_runtime28.jsx)("div", { className: "msp-semi-transparent-background" }), this.plugin.config.get(PluginConfig.Viewport.ShowControls) && this.icon(BuildOutlinedSvg, this.toggleControls, "Toggle Controls Panel", this.plugin.layout.state.showControls), this.plugin.config.get(PluginConfig.Viewport.ShowExpand) && this.icon(FullscreenSvg, this.toggleExpanded, "Toggle Expanded Viewport", this.plugin.layout.state.isExpanded), this.plugin.config.get(PluginConfig.Viewport.ShowSettings) && this.icon(TuneSvg, this.toggleSettingsExpanded, "Settings / Controls Info", this.state.isSettingsExpanded)] }), this.plugin.config.get(PluginConfig.Viewport.ShowSelectionMode) && (0, import_jsx_runtime28.jsxs)("div", { children: [(0, import_jsx_runtime28.jsx)("div", { className: "msp-semi-transparent-background" }), (0, import_jsx_runtime28.jsx)(ToggleSelectionModeButton, {})] })] }), this.state.isScreenshotExpanded && (0, import_jsx_runtime28.jsx)("div", { className: "msp-viewport-controls-panel", children: (0, import_jsx_runtime28.jsx)(ControlGroup, { header: "Screenshot / State", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleScreenshotExpanded, topRightIcon: CloseSvg, noTopMargin: true, childrenClassName: "msp-viewport-controls-panel-controls", children: (0, import_jsx_runtime28.jsx)(DownloadScreenshotControls, { close: this.toggleScreenshotExpanded }) }) }), this.state.isSettingsExpanded && (0, import_jsx_runtime28.jsx)("div", { className: "msp-viewport-controls-panel", children: (0, import_jsx_runtime28.jsx)(ControlGroup, { header: "Settings / Controls Info", title: "Click to close.", initialExpanded: true, hideExpander: true, hideOffset: true, onHeaderClick: this.toggleSettingsExpanded, topRightIcon: CloseSvg, noTopMargin: true, childrenClassName: "msp-viewport-controls-panel-controls", children: (0, import_jsx_runtime28.jsx)(SimpleSettingsControl, {}) }) })] });
  }
};
var Logo = () => (0, import_jsx_runtime28.jsx)("a", { className: "msp-logo", href: "https://molstar.org", target: "_blank" });
var Viewport = () => (0, import_jsx_runtime28.jsx)(ViewportCanvas, { logo: Logo });

// node_modules/molstar/lib/mol-plugin-ui/plugin.js
function Plugin({ plugin }) {
  if (plugin.isInitialized) {
    return (0, import_jsx_runtime29.jsx)(PluginReactContext.Provider, { value: plugin, children: (0, import_jsx_runtime29.jsx)(Layout, {}) });
  }
  return (0, import_jsx_runtime29.jsx)(PluginInitWrapper, { plugin });
}
function PluginInitWrapper({ plugin }) {
  const [state, setState] = React10.useState({ kind: "pending" });
  React10.useEffect(() => {
    setState({ kind: "pending" });
    let mounted = true;
    plugin.initialized.then(() => {
      if (mounted)
        setState({ kind: "initialized" });
    }).catch((err) => {
      if (mounted)
        setState({ kind: "error", message: `${err}` });
    });
    return () => {
      mounted = false;
    };
  }, [plugin]);
  if (state.kind === "pending")
    return null;
  if (state.kind === "error") {
    return (0, import_jsx_runtime29.jsx)("div", { className: "msp-plugin", children: (0, import_jsx_runtime29.jsxs)("div", { className: "msp-plugin-init-error", children: ["Initialization error: ", state.message] }) });
  }
  return (0, import_jsx_runtime29.jsx)(PluginReactContext.Provider, { value: plugin, children: (0, import_jsx_runtime29.jsx)(Layout, {}) });
}
var Layout = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.onDrop = (ev) => {
      ev.preventDefault();
      const files = [];
      if (ev.dataTransfer.items) {
        for (let i = 0; i < ev.dataTransfer.items.length; i++) {
          if (ev.dataTransfer.items[i].kind !== "file")
            continue;
          const file = ev.dataTransfer.items[i].getAsFile();
          if (file)
            files.push(file);
        }
      } else {
        for (let i = 0; i < ev.dataTransfer.files.length; i++) {
          const file = ev.dataTransfer.files[i];
          if (file)
            files.push(file);
        }
      }
      const sessions = files.filter((f) => {
        const fn = f.name.toLowerCase();
        return fn.endsWith(".molx") || fn.endsWith(".molj");
      });
      if (sessions.length > 0) {
        PluginCommands.State.Snapshots.OpenFile(this.plugin, { file: sessions[0] });
      } else {
        this.plugin.runTask(this.plugin.state.data.applyAction(OpenFiles, {
          files: files.map((f) => Asset.File(f)),
          format: { name: "auto", params: {} },
          visuals: true
        }));
      }
    };
    this.onDragOver = (ev) => {
      ev.preventDefault();
    };
    this.showDragOverlay = new BehaviorSubject(false);
    this.onDragEnter = (ev) => {
      let hasFile = false;
      if (ev.dataTransfer.items && ev.dataTransfer.items.length > 0) {
        for (let i = 0; i < ev.dataTransfer.items.length; i++) {
          if (ev.dataTransfer.items[i].kind !== "file")
            continue;
          hasFile = true;
          break;
        }
      } else {
        for (let i = 0; i < ev.dataTransfer.types.length; i++) {
          if (ev.dataTransfer.types[i] !== "Files")
            continue;
          hasFile = true;
          break;
        }
      }
      if (hasFile) {
        this.showDragOverlay.next(true);
      }
    };
  }
  componentDidMount() {
    this.subscribe(this.plugin.layout.events.updated, () => this.forceUpdate());
  }
  region(kind, Element) {
    return (0, import_jsx_runtime29.jsx)("div", { className: `msp-layout-region msp-layout-${kind}`, children: (0, import_jsx_runtime29.jsx)("div", { className: "msp-layout-static", children: Element ? (0, import_jsx_runtime29.jsx)(Element, {}) : null }) });
  }
  get layoutVisibilityClassName() {
    var _a, _b;
    const layout = this.plugin.layout.state;
    const controls = (_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.controls) !== null && _b !== void 0 ? _b : {};
    const classList = [];
    if (controls.top === "none" || !layout.showControls || layout.regionState.top === "hidden") {
      classList.push("msp-layout-hide-top");
    }
    if (controls.left === "none" || !layout.showControls || layout.regionState.left === "hidden") {
      classList.push("msp-layout-hide-left");
    } else if (layout.regionState.left === "collapsed") {
      classList.push("msp-layout-collapse-left");
    }
    if (controls.right === "none" || !layout.showControls || layout.regionState.right === "hidden") {
      classList.push("msp-layout-hide-right");
    }
    if (controls.bottom === "none" || !layout.showControls || layout.regionState.bottom === "hidden") {
      classList.push("msp-layout-hide-bottom");
    }
    return classList.join(" ");
  }
  get layoutClassName() {
    const layout = this.plugin.layout.state;
    const classList = ["msp-plugin-content"];
    if (layout.isExpanded) {
      classList.push("msp-layout-expanded");
    } else {
      classList.push("msp-layout-standard", `msp-layout-standard-${layout.controlsDisplay}`);
    }
    return classList.join(" ");
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g;
    const layout = this.plugin.layout.state;
    const controls = ((_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.controls) || {};
    const viewport = ((_c = (_b = this.plugin.spec.components) === null || _b === void 0 ? void 0 : _b.viewport) === null || _c === void 0 ? void 0 : _c.view) || DefaultViewport;
    const sequenceView = ((_e = (_d = this.plugin.spec.components) === null || _d === void 0 ? void 0 : _d.sequenceViewer) === null || _e === void 0 ? void 0 : _e.view) || SequenceView;
    return (0, import_jsx_runtime29.jsx)("div", { className: "msp-plugin", children: (0, import_jsx_runtime29.jsxs)("div", { className: this.layoutClassName, onDragEnter: this.onDragEnter, children: [(0, import_jsx_runtime29.jsxs)("div", { className: this.layoutVisibilityClassName, children: [this.region("main", viewport), layout.showControls && controls.top !== "none" && this.region("top", controls.top || sequenceView), layout.showControls && controls.left !== "none" && this.region("left", controls.left || LeftPanelControls), layout.showControls && controls.right !== "none" && this.region("right", controls.right || ControlsWrapper), layout.showControls && controls.bottom !== "none" && this.region("bottom", controls.bottom || Log)] }), !((_f = this.plugin.spec.components) === null || _f === void 0 ? void 0 : _f.hideTaskOverlay) && (0, import_jsx_runtime29.jsx)(OverlayTaskProgress, {}), !((_g = this.plugin.spec.components) === null || _g === void 0 ? void 0 : _g.disableDragOverlay) && (0, import_jsx_runtime29.jsx)(DragOverlay, { plugin: this.plugin, showDragOverlay: this.showDragOverlay })] }) });
  }
};
function dropFiles(ev, plugin, showDragOverlay) {
  ev.preventDefault();
  ev.stopPropagation();
  showDragOverlay.next(false);
  const files = [];
  if (ev.dataTransfer.items) {
    for (let i = 0; i < ev.dataTransfer.items.length; i++) {
      if (ev.dataTransfer.items[i].kind !== "file")
        continue;
      const file = ev.dataTransfer.items[i].getAsFile();
      if (file)
        files.push(file);
    }
  } else {
    for (let i = 0; i < ev.dataTransfer.files.length; i++) {
      const file = ev.dataTransfer.files[i];
      if (file)
        files.push(file);
    }
  }
  plugin.managers.dragAndDrop.handle(files);
}
function DragOverlay({ plugin, showDragOverlay }) {
  const show = useBehavior(showDragOverlay);
  const preventDrag = (e) => {
    e.dataTransfer.dropEffect = "copy";
    e.preventDefault();
    e.stopPropagation();
  };
  return (0, import_jsx_runtime29.jsx)("div", { className: "msp-drag-drop-overlay", style: { display: show ? "flex" : "none" }, onDragEnter: preventDrag, onDragOver: preventDrag, onDragLeave: () => showDragOverlay.next(false), onDrop: (e) => dropFiles(e, plugin, showDragOverlay), children: "Load File(s)" });
}
var ControlsWrapper = class extends PluginUIComponent {
  render() {
    var _a;
    const StructureTools = ((_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.structureTools) || DefaultStructureTools;
    return (0, import_jsx_runtime29.jsx)("div", { className: "msp-scrollable-container", children: (0, import_jsx_runtime29.jsx)(StructureTools, {}) });
  }
};
var DefaultViewport = class extends PluginUIComponent {
  render() {
    var _a, _b, _c, _d, _e, _f;
    const VPControls = ((_b = (_a = this.plugin.spec.components) === null || _a === void 0 ? void 0 : _a.viewport) === null || _b === void 0 ? void 0 : _b.controls) || ViewportControls;
    const SVPControls = ((_d = (_c = this.plugin.spec.components) === null || _c === void 0 ? void 0 : _c.selectionTools) === null || _d === void 0 ? void 0 : _d.controls) || SelectionViewportControls;
    const SnapshotDescription = ((_f = (_e = this.plugin.spec.components) === null || _e === void 0 ? void 0 : _e.viewport) === null || _f === void 0 ? void 0 : _f.snapshotDescription) || ViewportSnapshotDescription;
    return (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, { children: [(0, import_jsx_runtime29.jsx)(Viewport, {}), (0, import_jsx_runtime29.jsxs)("div", { className: "msp-viewport-top-left-controls", children: [(0, import_jsx_runtime29.jsx)(AnimationViewportControls, {}), (0, import_jsx_runtime29.jsx)(TrajectoryViewportControls, {}), (0, import_jsx_runtime29.jsx)(StateSnapshotViewportControls, {}), (0, import_jsx_runtime29.jsx)(SnapshotDescription, {})] }), (0, import_jsx_runtime29.jsx)(SVPControls, {}), (0, import_jsx_runtime29.jsx)(VPControls, {}), (0, import_jsx_runtime29.jsx)(BackgroundTaskProgress, {}), (0, import_jsx_runtime29.jsxs)("div", { className: "msp-highlight-toast-wrapper", children: [(0, import_jsx_runtime29.jsx)(LociLabels, {}), (0, import_jsx_runtime29.jsx)(Toasts, {})] })] });
  }
};
var Log = class extends PluginUIComponent {
  constructor() {
    super(...arguments);
    this.wrapper = React10.createRef();
    this.state = { entries: this.plugin.log.entries };
  }
  componentDidMount() {
    this.subscribe(this.plugin.events.log, () => this.setState({ entries: this.plugin.log.entries }));
  }
  componentDidUpdate() {
    this.scrollToBottom();
  }
  scrollToBottom() {
    const log = this.wrapper.current;
    if (log)
      log.scrollTop = log.scrollHeight - log.clientHeight - 1;
  }
  render() {
    const maxEntries = 10;
    const xs = this.state.entries, l = xs.size;
    const entries = [];
    for (let i = Math.max(0, l - maxEntries), o = 0; i < l; i++) {
      const e = xs.get(i);
      entries.push((0, import_jsx_runtime29.jsxs)("li", { children: [(0, import_jsx_runtime29.jsx)("div", { className: "msp-log-entry-badge msp-log-entry-" + e.type }), (0, import_jsx_runtime29.jsx)("div", { className: "msp-log-timestamp", children: formatTime(e.timestamp) }), (0, import_jsx_runtime29.jsx)("div", { className: "msp-log-entry", children: e.message })] }, o++));
    }
    return (0, import_jsx_runtime29.jsx)("div", { ref: this.wrapper, className: "msp-log", style: { position: "absolute", top: "0", right: "0", bottom: "0", left: "0", overflowY: "auto" }, children: (0, import_jsx_runtime29.jsx)("ul", { className: "msp-list-unstyled", children: entries }) });
  }
};

// node_modules/molstar/lib/mol-model-props/common/custom-property.js
var CustomProperty;
(function(CustomProperty2) {
  class Registry {
    constructor() {
      this.providers = OrderedMap().asMutable();
      this.defaultAutoAttachValues = /* @__PURE__ */ new Map();
    }
    /** Get params for all applicable property providers */
    getParams(data) {
      const propertiesParams = {};
      const autoAttachOptions = [];
      const autoAttachDefault = [];
      if (data) {
        const values2 = this.providers.values();
        while (true) {
          const v2 = values2.next();
          if (v2.done)
            break;
          const provider = v2.value;
          if (!provider.isApplicable(data))
            continue;
          if (!provider.isHidden) {
            autoAttachOptions.push([provider.descriptor.name, provider.label]);
            if (this.defaultAutoAttachValues.get(provider.descriptor.name)) {
              autoAttachDefault.push(provider.descriptor.name);
            }
          }
          propertiesParams[provider.descriptor.name] = ParamDefinition.Group({
            ...provider.getParams(data)
          }, { label: provider.label, isHidden: provider.isHidden });
        }
      }
      return {
        autoAttach: ParamDefinition.MultiSelect(autoAttachDefault, autoAttachOptions),
        properties: ParamDefinition.Group(propertiesParams, { isFlat: true })
      };
    }
    setDefaultAutoAttach(name2, value) {
      this.defaultAutoAttachValues.set(name2, value);
    }
    get(name2) {
      const prop = this.providers.get(name2);
      if (!prop) {
        throw new Error(`Custom property '${name2}' is not registered.`);
      }
      return this.providers.get(name2);
    }
    register(provider, defaultAutoAttach) {
      this.providers.set(provider.descriptor.name, provider);
      this.defaultAutoAttachValues.set(provider.descriptor.name, defaultAutoAttach);
    }
    unregister(name2) {
      this.providers.delete(name2);
      this.defaultAutoAttachValues.delete(name2);
    }
  }
  CustomProperty2.Registry = Registry;
})(CustomProperty || (CustomProperty = {}));

// node_modules/molstar/lib/mol-plugin-state/builder/data.js
var DataBuilder = class {
  get dataState() {
    return this.plugin.state.data;
  }
  rawData(params, options) {
    const data = this.dataState.build().toRoot().apply(RawData, params, options);
    return data.commit({ revertOnError: true });
  }
  download(params, options) {
    const data = this.dataState.build().toRoot().apply(Download, params, options);
    return data.commit({ revertOnError: true });
  }
  downloadBlob(params, options) {
    const data = this.dataState.build().toRoot().apply(DownloadBlob, params, options);
    return data.commit({ revertOnError: true });
  }
  async readFile(params, options) {
    var _a, _b, _c;
    const data = await this.dataState.build().toRoot().apply(ReadFile, params, options).commit({ revertOnError: true });
    const fileInfo = getFileNameInfo((_c = (_b = (_a = params.file) === null || _a === void 0 ? void 0 : _a.file) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "");
    return { data, fileInfo };
  }
  constructor(plugin) {
    this.plugin = plugin;
  }
};

// node_modules/molstar/lib/mol-plugin-state/builder/structure/representation.js
var StructureRepresentationBuilder = class {
  get dataState() {
    return this.plugin.state.data;
  }
  resolveProvider(ref) {
    var _a;
    return typeof ref === "string" ? (_a = PresetStructureRepresentations[ref]) !== null && _a !== void 0 ? _a : arrayFind(this._providers, (p) => p.id === ref) : ref;
  }
  hasPreset(s) {
    for (const p of this._providers) {
      if (!p.isApplicable || p.isApplicable(s, this.plugin))
        return true;
    }
    return false;
  }
  get providers() {
    return this._providers;
  }
  getPresets(s) {
    if (!s)
      return this.providers;
    const ret = [];
    for (const p of this._providers) {
      if (p.isApplicable && !p.isApplicable(s, this.plugin))
        continue;
      ret.push(p);
    }
    return ret;
  }
  getPresetSelect(s) {
    const options = [];
    for (const p of this._providers) {
      if (s && p.isApplicable && !p.isApplicable(s, this.plugin))
        continue;
      options.push([p.id, p.display.name, p.display.group]);
    }
    return ParamDefinition.Select("auto", options);
  }
  getPresetsWithOptions(s) {
    const options = [];
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const p of this._providers) {
      if (p.isApplicable && !p.isApplicable(s, this.plugin))
        continue;
      options.push([p.id, p.display.name]);
      map2[p.id] = p.params ? ParamDefinition.Group(p.params(s, this.plugin)) : ParamDefinition.EmptyGroup();
    }
    if (options.length === 0)
      return ParamDefinition.MappedStatic("", { "": ParamDefinition.EmptyGroup() });
    return ParamDefinition.MappedStatic(options[0][0], map2, { options });
  }
  registerPreset(provider) {
    if (this.providerMap.has(provider.id)) {
      throw new Error(`Representation provider with id '${provider.id}' already registered.`);
    }
    this._providers.push(provider);
    this.providerMap.set(provider.id, provider);
  }
  unregisterPreset(provider) {
    this.providerMap.delete(provider.id);
    arrayRemoveInPlace(this._providers, provider);
  }
  applyPreset(parent, providerRef, params) {
    var _a;
    const provider = this.resolveProvider(providerRef);
    if (!provider)
      return;
    const state = this.plugin.state.data;
    const cell = StateObjectRef.resolveAndCheck(state, parent);
    if (!cell) {
      if (!isProductionMode)
        console.warn(`Applying structure repr. provider to bad cell.`);
      return;
    }
    const pd2 = ((_a = provider.params) === null || _a === void 0 ? void 0 : _a.call(provider, cell.obj, this.plugin)) || {};
    let prms = params || (provider.params ? ParamDefinition.getDefaultValues(pd2) : {});
    const defaults = this.plugin.config.get(PluginConfig.Structure.DefaultRepresentationPresetParams);
    prms = ParamDefinition.merge(pd2, defaults, prms);
    const task = Task.create(`${provider.display.name}`, () => provider.apply(cell, prms, this.plugin));
    return this.plugin.runTask(task);
  }
  async addRepresentation(structure, props, options) {
    const repr = this.dataState.build();
    const selector = this.buildRepresentation(repr, structure, props, options);
    if (!selector)
      return;
    await repr.commit();
    return selector;
  }
  buildRepresentation(builder, structure, props, options) {
    var _a, _b;
    if (!structure)
      return;
    const data = (_b = (_a = StateObjectRef.resolveAndCheck(this.dataState, structure)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!data)
      return;
    const params = createStructureRepresentationParams(this.plugin, data, props);
    return (options === null || options === void 0 ? void 0 : options.tag) ? builder.to(structure).applyOrUpdateTagged(options.tag, StructureRepresentation3D, params, { state: options === null || options === void 0 ? void 0 : options.initialState }).selector : builder.to(structure).apply(StructureRepresentation3D, params, { state: options === null || options === void 0 ? void 0 : options.initialState }).selector;
  }
  constructor(plugin) {
    this.plugin = plugin;
    this._providers = [];
    this.providerMap = /* @__PURE__ */ new Map();
    this.defaultProvider = PresetStructureRepresentations.auto;
    objectForEach(PresetStructureRepresentations, (r) => this.registerPreset(r));
  }
};

// node_modules/molstar/lib/mol-plugin-state/builder/structure/hierarchy-preset.js
function TrajectoryHierarchyPresetProvider(preset) {
  return preset;
}
(function(TrajectoryHierarchyPresetProvider2) {
  TrajectoryHierarchyPresetProvider2.CommonParams = (a4, plugin) => ({
    modelProperties: ParamDefinition.Optional(ParamDefinition.Group(Transformer.getParamDefinition(StateTransforms.Model.CustomModelProperties, void 0, plugin))),
    structureProperties: ParamDefinition.Optional(ParamDefinition.Group(Transformer.getParamDefinition(StateTransforms.Model.CustomStructureProperties, void 0, plugin))),
    representationPreset: ParamDefinition.Optional(ParamDefinition.Text("auto"))
  });
})(TrajectoryHierarchyPresetProvider || (TrajectoryHierarchyPresetProvider = {}));
var CommonParams = TrajectoryHierarchyPresetProvider.CommonParams;
var DefaultParams = (a4, plugin) => ({
  model: ParamDefinition.Optional(ParamDefinition.Group(Transformer.getParamDefinition(StateTransforms.Model.ModelFromTrajectory, a4, plugin))),
  showUnitcell: ParamDefinition.Optional(ParamDefinition.Boolean(false)),
  structure: ParamDefinition.Optional(RootStructureDefinition.getParams(void 0, "assembly").type),
  representationPresetParams: ParamDefinition.Optional(ParamDefinition.Group(StructureRepresentationPresetProvider.CommonParams)),
  ...CommonParams(a4, plugin)
});
var defaultPreset = TrajectoryHierarchyPresetProvider({
  id: "preset-trajectory-default",
  display: {
    name: "Default (Assembly)",
    group: "Preset",
    description: "Shows the first assembly or, if that is unavailable, the first model."
  },
  isApplicable: (o) => {
    return true;
  },
  params: DefaultParams,
  async apply(trajectory, params, plugin) {
    const builder = plugin.builders.structure;
    const model = await builder.createModel(trajectory, params.model);
    const modelProperties = await builder.insertModelProperties(model, params.modelProperties);
    const structure = await builder.createStructure(modelProperties || model, params.structure);
    const structureProperties = await builder.insertStructureProperties(structure, params.structureProperties);
    const unitcell2 = params.showUnitcell === void 0 || !!params.showUnitcell ? await builder.tryCreateUnitcell(modelProperties, void 0, { isHidden: true }) : void 0;
    const representationPreset = params.representationPreset || plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
    const representation = await plugin.builders.structure.representation.applyPreset(structureProperties, representationPreset, params.representationPresetParams);
    return {
      model,
      modelProperties,
      unitcell: unitcell2,
      structure,
      structureProperties,
      representation
    };
  }
});
var AllModelsParams = (a4, plugin) => ({
  useDefaultIfSingleModel: ParamDefinition.Optional(ParamDefinition.Boolean(false)),
  representationPresetParams: ParamDefinition.Optional(ParamDefinition.Group(StructureRepresentationPresetProvider.CommonParams)),
  ...CommonParams(a4, plugin)
});
var allModels = TrajectoryHierarchyPresetProvider({
  id: "preset-trajectory-all-models",
  display: {
    name: "All Models",
    group: "Preset",
    description: "Shows all models; colored by trajectory-index."
  },
  isApplicable: (o) => {
    return o.data.frameCount > 1;
  },
  params: AllModelsParams,
  async apply(trajectory, params, plugin) {
    var _a, _b;
    const tr = (_b = (_a = StateObjectRef.resolveAndCheck(plugin.state.data, trajectory)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!tr)
      return {};
    if (tr.frameCount === 1 && params.useDefaultIfSingleModel) {
      return defaultPreset.apply(trajectory, params, plugin);
    }
    const builder = plugin.builders.structure;
    const models = [], structures = [];
    for (let i = 0; i < tr.frameCount; i++) {
      const model = await builder.createModel(trajectory, { modelIndex: i });
      const modelProperties = await builder.insertModelProperties(model, params.modelProperties, { isCollapsed: true });
      const structure = await builder.createStructure(modelProperties || model, { name: "model", params: {} });
      const structureProperties = await builder.insertStructureProperties(structure, params.structureProperties);
      models.push(model);
      structures.push(structure);
      const quality = structure.obj ? getStructureQuality(structure.obj.data, { elementCountFactor: tr.frameCount }) : "medium";
      const representationPreset = params.representationPreset || plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
      await builder.representation.applyPreset(structureProperties, representationPreset, { theme: { globalName: "trajectory-index" }, quality });
    }
    return { models, structures };
  }
});
var CrystalSymmetryParams = (a4, plugin) => ({
  model: ParamDefinition.Optional(ParamDefinition.Group(Transformer.getParamDefinition(StateTransforms.Model.ModelFromTrajectory, a4, plugin))),
  ...CommonParams(a4, plugin)
});
async function applyCrystalSymmetry(props, trajectory, params, plugin) {
  const builder = plugin.builders.structure;
  const model = await builder.createModel(trajectory, params.model);
  const modelProperties = await builder.insertModelProperties(model, params.modelProperties);
  const structure = await builder.createStructure(modelProperties || model, {
    name: "symmetry",
    params: props
  });
  const structureProperties = await builder.insertStructureProperties(structure, params.structureProperties);
  const unitcell2 = await builder.tryCreateUnitcell(modelProperties, void 0, { isHidden: false });
  const representationPreset = params.representationPreset || plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
  const representation = await plugin.builders.structure.representation.applyPreset(structureProperties, representationPreset, { theme: { globalName: props.theme } });
  return {
    model,
    modelProperties,
    unitcell: unitcell2,
    structure,
    structureProperties,
    representation
  };
}
var unitcell = TrajectoryHierarchyPresetProvider({
  id: "preset-trajectory-unitcell",
  display: {
    name: "Unit Cell",
    group: "Preset",
    description: "Shows the fully populated unit cell."
  },
  isApplicable: (o) => {
    return Model.hasCrystalSymmetry(o.data.representative);
  },
  params: CrystalSymmetryParams,
  async apply(trajectory, params, plugin) {
    return await applyCrystalSymmetry({ ijkMin: Vec3.create(0, 0, 0), ijkMax: Vec3.create(0, 0, 0) }, trajectory, params, plugin);
  }
});
var supercell = TrajectoryHierarchyPresetProvider({
  id: "preset-trajectory-supercell",
  display: {
    name: "Super Cell",
    group: "Preset",
    description: "Shows the super cell, i.e. the central unit cell and all adjacent unit cells."
  },
  isApplicable: (o) => {
    return Model.hasCrystalSymmetry(o.data.representative);
  },
  params: CrystalSymmetryParams,
  async apply(trajectory, params, plugin) {
    return await applyCrystalSymmetry({ ijkMin: Vec3.create(-1, -1, -1), ijkMax: Vec3.create(1, 1, 1), theme: "operator-hkl" }, trajectory, params, plugin);
  }
});
var CrystalContactsParams = (a4, plugin) => ({
  model: ParamDefinition.Optional(ParamDefinition.Group(Transformer.getParamDefinition(StateTransforms.Model.ModelFromTrajectory, a4, plugin))),
  ...CommonParams(a4, plugin)
});
var crystalContacts = TrajectoryHierarchyPresetProvider({
  id: "preset-trajectory-crystal-contacts",
  display: {
    name: "Crystal Contacts",
    group: "Preset",
    description: "Showsasymetric unit and chains from neighbours within 5 , i.e., symmetry mates."
  },
  isApplicable: (o) => {
    return Model.hasCrystalSymmetry(o.data.representative);
  },
  params: CrystalContactsParams,
  async apply(trajectory, params, plugin) {
    const builder = plugin.builders.structure;
    const model = await builder.createModel(trajectory, params.model);
    const modelProperties = await builder.insertModelProperties(model, params.modelProperties);
    const structure = await builder.createStructure(modelProperties || model, {
      name: "symmetry-mates",
      params: { radius: 5 }
    });
    const structureProperties = await builder.insertStructureProperties(structure, params.structureProperties);
    const unitcell2 = await builder.tryCreateUnitcell(modelProperties, void 0, { isHidden: true });
    const representationPreset = params.representationPreset || plugin.config.get(PluginConfig.Structure.DefaultRepresentationPreset) || PresetStructureRepresentations.auto.id;
    const representation = await plugin.builders.structure.representation.applyPreset(structureProperties, representationPreset, { theme: { globalName: "operator-name", carbonColor: "operator-name", focus: { name: "element-symbol", params: { carbonColor: { name: "operator-name", params: OperatorNameColorThemeProvider.defaultValues } } } } });
    return {
      model,
      modelProperties,
      unitcell: unitcell2,
      structure,
      structureProperties,
      representation
    };
  }
});
var PresetTrajectoryHierarchy = {
  "default": defaultPreset,
  "all-models": allModels,
  unitcell,
  supercell,
  crystalContacts
};

// node_modules/molstar/lib/mol-plugin-state/builder/structure/hierarchy.js
var TrajectoryHierarchyBuilder = class {
  resolveProvider(ref) {
    var _a;
    return typeof ref === "string" ? (_a = PresetTrajectoryHierarchy[ref]) !== null && _a !== void 0 ? _a : arrayFind(this._providers, (p) => p.id === ref) : ref;
  }
  hasPreset(t4) {
    for (const p of this._providers) {
      if (!p.isApplicable || p.isApplicable(t4, this.plugin))
        return true;
    }
    return false;
  }
  get providers() {
    return this._providers;
  }
  getPresets(t4) {
    if (!t4)
      return this.providers;
    const ret = [];
    for (const p of this._providers) {
      if (p.isApplicable && !p.isApplicable(t4, this.plugin))
        continue;
      ret.push(p);
    }
    return ret;
  }
  getPresetSelect(t4) {
    const options = [];
    for (const p of this._providers) {
      if (t4 && p.isApplicable && !p.isApplicable(t4, this.plugin))
        continue;
      options.push([p.id, p.display.name]);
    }
    return ParamDefinition.Select("auto", options);
  }
  getPresetsWithOptions(t4) {
    const options = [];
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const p of this._providers) {
      if (p.isApplicable && !p.isApplicable(t4, this.plugin))
        continue;
      options.push([p.id, p.display.name]);
      map2[p.id] = p.params ? ParamDefinition.Group(p.params(t4, this.plugin)) : ParamDefinition.EmptyGroup();
    }
    if (options.length === 0)
      return ParamDefinition.MappedStatic("", { "": ParamDefinition.EmptyGroup() });
    return ParamDefinition.MappedStatic(options[0][0], map2, { options });
  }
  registerPreset(provider) {
    if (this.providerMap.has(provider.id)) {
      throw new Error(`Hierarchy provider with id '${provider.id}' already registered.`);
    }
    this._providers.push(provider);
    this.providerMap.set(provider.id, provider);
  }
  unregisterPreset(provider) {
    this.providerMap.delete(provider.id);
    arrayRemoveInPlace(this._providers, provider);
  }
  applyPreset(parent, providerRef, params) {
    const provider = this.resolveProvider(providerRef);
    if (!provider)
      return;
    const state = this.plugin.state.data;
    const cell = StateObjectRef.resolveAndCheck(state, parent);
    if (!cell) {
      if (!isProductionMode)
        console.warn(`Applying hierarchy preset provider to bad cell.`);
      return;
    }
    const prms = params || (provider.params ? ParamDefinition.getDefaultValues(provider.params(cell.obj, this.plugin)) : {});
    const task = Task.create(`${provider.display.name}`, () => provider.apply(cell, prms, this.plugin));
    return this.plugin.runTask(task);
  }
  constructor(plugin) {
    this.plugin = plugin;
    this._providers = [];
    this.providerMap = /* @__PURE__ */ new Map();
    this.defaultProvider = PresetTrajectoryHierarchy.default;
    objectForEach(PresetTrajectoryHierarchy, (r) => this.registerPreset(r));
  }
};

// node_modules/molstar/lib/mol-plugin-state/builder/structure.js
var StructureBuilder = class {
  get dataState() {
    return this.plugin.state.data;
  }
  async parseTrajectoryData(data, format) {
    const provider = typeof format === "string" ? this.plugin.dataFormats.get(format) : format;
    if (!provider)
      throw new Error(`'${format}' is not a supported data format.`);
    const { trajectory } = await provider.parse(this.plugin, data);
    return trajectory;
  }
  parseTrajectoryBlob(data, params) {
    const state = this.dataState;
    const trajectory = state.build().to(data).apply(StateTransforms.Data.ParseBlob, params, { state: { isGhost: true } }).apply(StateTransforms.Model.TrajectoryFromBlob, void 0);
    return trajectory.commit({ revertOnError: true });
  }
  parseTrajectory(data, params) {
    const cell = StateObjectRef.resolveAndCheck(this.dataState, data);
    if (!cell)
      throw new Error("Invalid data cell.");
    if (PluginStateObject.Data.Blob.is(cell.obj)) {
      return this.parseTrajectoryBlob(data, params);
    } else {
      return this.parseTrajectoryData(data, params);
    }
  }
  createModel(trajectory, params, initialState) {
    const state = this.dataState;
    const model = state.build().to(trajectory).apply(StateTransforms.Model.ModelFromTrajectory, params || { modelIndex: 0 }, { state: initialState });
    return model.commit({ revertOnError: true });
  }
  insertModelProperties(model, params, initialState) {
    const state = this.dataState;
    const props = state.build().to(model).apply(StateTransforms.Model.CustomModelProperties, params, { state: initialState });
    return props.commit({ revertOnError: true });
  }
  tryCreateUnitcell(model, params, initialState) {
    var _a, _b, _c;
    const state = this.dataState;
    const m = (_b = (_a = StateObjectRef.resolveAndCheck(state, model)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!m)
      return;
    const cell = (_c = ModelSymmetry.Provider.get(m)) === null || _c === void 0 ? void 0 : _c.spacegroup.cell;
    if (SpacegroupCell.isZero(cell))
      return;
    const unitcell2 = state.build().to(model).apply(StateTransforms.Representation.ModelUnitcell3D, params, { state: initialState });
    return unitcell2.commit({ revertOnError: true });
  }
  createStructure(modelRef, params, initialState, tags) {
    var _a;
    const state = this.dataState;
    if (!params) {
      const model = StateObjectRef.resolveAndCheck(state, modelRef);
      if (model) {
        const symm = ModelSymmetry.Provider.get((_a = model.obj) === null || _a === void 0 ? void 0 : _a.data);
        if (!symm || (symm === null || symm === void 0 ? void 0 : symm.assemblies.length) === 0)
          params = { name: "model", params: {} };
      }
    }
    const structure = state.build().to(modelRef).apply(StateTransforms.Model.StructureFromModel, { type: params || { name: "assembly", params: {} } }, { state: initialState, tags });
    return structure.commit({ revertOnError: true });
  }
  insertStructureProperties(structure, params) {
    const state = this.dataState;
    const props = state.build().to(structure).apply(StateTransforms.Model.CustomStructureProperties, params);
    return props.commit({ revertOnError: true });
  }
  isComponentTransform(cell) {
    return cell.transform.transformer === StateTransforms.Model.StructureComponent;
  }
  /** returns undefined if the component is empty/null */
  async tryCreateComponent(structure, params, key, tags) {
    var _a, _b;
    const state = this.dataState;
    const root3 = state.build().to(structure);
    const keyTag = `structure-component-${key}`;
    const component = root3.applyOrUpdateTagged(keyTag, StateTransforms.Model.StructureComponent, params, {
      tags: tags ? [...tags, keyTag] : [keyTag]
    });
    await component.commit();
    const selector = component.selector;
    if (!selector.isOk || ((_b = (_a = selector.cell) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data.elementCount) === 0) {
      await state.build().delete(selector.ref).commit();
      return;
    }
    return selector;
  }
  tryCreateComponentFromExpression(structure, expression, key, params) {
    return this.tryCreateComponent(structure, {
      type: { name: "expression", params: expression },
      nullIfEmpty: true,
      label: ((params === null || params === void 0 ? void 0 : params.label) || "").trim()
    }, key, params === null || params === void 0 ? void 0 : params.tags);
  }
  tryCreateComponentStatic(structure, type, params) {
    return this.tryCreateComponent(structure, {
      type: { name: "static", params: type },
      nullIfEmpty: true,
      label: ((params === null || params === void 0 ? void 0 : params.label) || "").trim()
    }, `static-${type}`, params === null || params === void 0 ? void 0 : params.tags);
  }
  tryCreateComponentFromSelection(structure, selection, key, params) {
    return this.plugin.runTask(Task.create("Query Component", async (taskCtx) => {
      var _a, _b;
      let { label, tags } = params || {};
      label = (label || "").trim();
      const structureData = (_b = (_a = StateObjectRef.resolveAndCheck(this.dataState, structure)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
      if (!structureData)
        return;
      const transformParams = selection.referencesCurrent ? {
        type: {
          name: "bundle",
          params: element_exports.Bundle.fromSelection(await selection.getSelection(this.plugin, taskCtx, structureData))
        },
        nullIfEmpty: true,
        label: label || selection.label
      } : {
        type: { name: "expression", params: selection.expression },
        nullIfEmpty: true,
        label: label || selection.label
      };
      if (selection.ensureCustomProperties) {
        await selection.ensureCustomProperties({ runtime: taskCtx, assetManager: this.plugin.managers.asset, errorContext: this.plugin.errorContext }, structureData);
      }
      return this.tryCreateComponent(structure, transformParams, key, tags);
    }));
  }
  constructor(plugin) {
    this.plugin = plugin;
    this.hierarchy = new TrajectoryHierarchyBuilder(this.plugin);
    this.representation = new StructureRepresentationBuilder(this.plugin);
  }
};

// node_modules/molstar/lib/mol-model-formats/volume/property.js
var PropertyProvider;
(function(PropertyProvider2) {
  function create2(descriptor) {
    const { name: name2 } = descriptor;
    return {
      descriptor,
      get(volume) {
        return volume._propertyData[name2];
      },
      set(volume, value) {
        volume.customProperties.add(descriptor);
        volume._propertyData[name2] = value;
      }
    };
  }
  PropertyProvider2.create = create2;
})(PropertyProvider || (PropertyProvider = {}));
var RecommendedIsoValue;
(function(RecommendedIsoValue2) {
  RecommendedIsoValue2.Descriptor = {
    name: "recommended_iso_value"
  };
  RecommendedIsoValue2.Provider = PropertyProvider.create(RecommendedIsoValue2.Descriptor);
})(RecommendedIsoValue || (RecommendedIsoValue = {}));

// node_modules/molstar/lib/mol-plugin-state/formats/volume.js
var VolumeFormatCategory = "Volume";
async function tryObtainRecommendedIsoValue(plugin, volume) {
  if (!volume)
    return;
  const { entryId } = volume;
  if (!entryId || !entryId.toLowerCase().startsWith("emd"))
    return;
  return plugin.runTask(Task.create("Try Set Recommended IsoValue", async (ctx) => {
    try {
      const absIsoLevel = await getContourLevelEmdb(plugin, ctx, entryId);
      RecommendedIsoValue.Provider.set(volume, Volume.IsoValue.absolute(absIsoLevel));
    } catch (e) {
      console.warn(e);
    }
  }));
}
function tryGetRecomendedIsoValue(volume) {
  const recommendedIsoValue = RecommendedIsoValue.Provider.get(volume);
  if (!recommendedIsoValue)
    return;
  if (recommendedIsoValue.kind === "relative")
    return recommendedIsoValue;
  return Volume.adjustedIsoValue(volume, recommendedIsoValue.absoluteValue, "absolute");
}
async function defaultVisuals(plugin, data) {
  const typeParams = {};
  const isoValue = data.volume.data && tryGetRecomendedIsoValue(data.volume.data);
  if (isoValue)
    typeParams.isoValue = isoValue;
  const visual = plugin.build().to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, data.volume.data, {
    type: "isosurface",
    typeParams
  }));
  return [await visual.commit()];
}
var Ccp4Provider = DataFormatProvider({
  label: "CCP4/MRC/MAP",
  description: "CCP4/MRC/MAP",
  category: VolumeFormatCategory,
  binaryExtensions: ["ccp4", "mrc", "map"],
  parse: async (plugin, data, params) => {
    const format = plugin.build().to(data).apply(StateTransforms.Data.ParseCcp4, {}, { state: { isGhost: true } });
    const volume = format.apply(StateTransforms.Volume.VolumeFromCcp4, { entryId: params === null || params === void 0 ? void 0 : params.entryId });
    await format.commit({ revertOnError: true });
    await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
    return { format: format.selector, volume: volume.selector };
  },
  visuals: defaultVisuals
});
var Dsn6Provider = DataFormatProvider({
  label: "DSN6/BRIX",
  description: "DSN6/BRIX",
  category: VolumeFormatCategory,
  binaryExtensions: ["dsn6", "brix"],
  parse: async (plugin, data, params) => {
    const format = plugin.build().to(data).apply(StateTransforms.Data.ParseDsn6, {}, { state: { isGhost: true } });
    const volume = format.apply(StateTransforms.Volume.VolumeFromDsn6, { entryId: params === null || params === void 0 ? void 0 : params.entryId });
    await format.commit({ revertOnError: true });
    await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
    return { format: format.selector, volume: volume.selector };
  },
  visuals: defaultVisuals
});
var DxProvider = DataFormatProvider({
  label: "DX",
  description: "DX",
  category: VolumeFormatCategory,
  stringExtensions: ["dx"],
  binaryExtensions: ["dxbin"],
  parse: async (plugin, data, params) => {
    const format = plugin.build().to(data).apply(StateTransforms.Data.ParseDx, {}, { state: { isGhost: true } });
    const volume = format.apply(StateTransforms.Volume.VolumeFromDx, { entryId: params === null || params === void 0 ? void 0 : params.entryId });
    await volume.commit({ revertOnError: true });
    await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
    return { volume: volume.selector };
  },
  visuals: defaultVisuals
});
var CubeProvider = DataFormatProvider({
  label: "Cube",
  description: "Cube",
  category: VolumeFormatCategory,
  stringExtensions: ["cub", "cube"],
  parse: async (plugin, data, params) => {
    const format = plugin.build().to(data).apply(StateTransforms.Data.ParseCube, {}, { state: { isGhost: true } });
    const volume = format.apply(StateTransforms.Volume.VolumeFromCube, { entryId: params === null || params === void 0 ? void 0 : params.entryId });
    const structure = format.apply(StateTransforms.Model.TrajectoryFromCube, void 0, { state: { isGhost: true } }).apply(StateTransforms.Model.ModelFromTrajectory).apply(StateTransforms.Model.StructureFromModel);
    await format.commit({ revertOnError: true });
    await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
    return { format: format.selector, volume: volume.selector, structure: structure.selector };
  },
  visuals: async (plugin, data) => {
    var _a, _b;
    const surfaces = plugin.build();
    const volumeReprs = [];
    const volumeData = (_b = (_a = data.volume.cell) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (volumeData && Volume.isOrbitals(volumeData)) {
      const volumePos = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
        type: "isosurface",
        typeParams: { isoValue: Volume.IsoValue.relative(1), alpha: 0.4 },
        color: "uniform",
        colorParams: { value: ColorNames.blue }
      }));
      const volumeNeg = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
        type: "isosurface",
        typeParams: { isoValue: Volume.IsoValue.relative(-1), alpha: 0.4 },
        color: "uniform",
        colorParams: { value: ColorNames.red }
      }));
      volumeReprs.push(volumePos.selector, volumeNeg.selector);
    } else {
      const volume = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
        type: "isosurface",
        typeParams: { isoValue: Volume.IsoValue.relative(2), alpha: 0.4 },
        color: "uniform",
        colorParams: { value: ColorNames.grey }
      }));
      volumeReprs.push(volume.selector);
    }
    const structure = await plugin.builders.structure.representation.applyPreset(data.structure, "auto");
    await surfaces.commit();
    const structureReprs = [];
    objectForEach(structure === null || structure === void 0 ? void 0 : structure.representations, (r) => {
      if (r)
        structureReprs.push(r);
    });
    return [...volumeReprs, ...structureReprs];
  }
});
var DscifProvider = DataFormatProvider({
  label: "DensityServer CIF",
  description: "DensityServer CIF",
  category: VolumeFormatCategory,
  stringExtensions: ["cif"],
  binaryExtensions: ["bcif"],
  isApplicable: (info, data) => {
    return guessCifVariant(info, data) === "dscif" ? true : false;
  },
  parse: async (plugin, data, params) => {
    var _a;
    const cifCell = await plugin.build().to(data).apply(StateTransforms.Data.ParseCif).commit();
    const b4 = plugin.build().to(cifCell);
    const blocks = cifCell.obj.data.blocks;
    if (blocks.length === 0)
      throw new Error("no data blocks");
    const volumes = [];
    let i = 0;
    for (const block of blocks) {
      if (block.header.toUpperCase() === "SERVER")
        continue;
      const entryId = Array.isArray(params === null || params === void 0 ? void 0 : params.entryId) ? params === null || params === void 0 ? void 0 : params.entryId[i] : params === null || params === void 0 ? void 0 : params.entryId;
      if (((_a = block.categories["volume_data_3d_info"]) === null || _a === void 0 ? void 0 : _a.rowCount) > 0) {
        volumes.push(b4.apply(StateTransforms.Volume.VolumeFromDensityServerCif, { blockHeader: block.header, entryId }).selector);
        i++;
      }
    }
    await b4.commit();
    for (const v2 of volumes)
      await tryObtainRecommendedIsoValue(plugin, v2.data);
    return { volumes };
  },
  visuals: async (plugin, data) => {
    const { volumes } = data;
    const tree = plugin.build();
    const visuals = [];
    if (volumes.length > 0) {
      const isoValue = volumes[0].data && tryGetRecomendedIsoValue(volumes[0].data) || Volume.IsoValue.relative(1.5);
      visuals[0] = tree.to(volumes[0]).apply(StateTransforms.Representation.VolumeRepresentation3D, VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, "isosurface", { isoValue, alpha: 1 }, "uniform", { value: ColorNames.teal })).selector;
    }
    if (volumes.length > 1) {
      const posParams = VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, "isosurface", { isoValue: Volume.IsoValue.relative(3), alpha: 0.3 }, "uniform", { value: ColorNames.green });
      const negParams = VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, "isosurface", { isoValue: Volume.IsoValue.relative(-3), alpha: 0.3 }, "uniform", { value: ColorNames.red });
      visuals[visuals.length] = tree.to(volumes[1]).apply(StateTransforms.Representation.VolumeRepresentation3D, posParams).selector;
      visuals[visuals.length] = tree.to(volumes[1]).apply(StateTransforms.Representation.VolumeRepresentation3D, negParams).selector;
    }
    await tree.commit();
    return visuals;
  }
});
var SegcifProvider = DataFormatProvider({
  label: "Segmentation CIF",
  description: "Segmentation CIF",
  category: VolumeFormatCategory,
  stringExtensions: ["cif"],
  binaryExtensions: ["bcif"],
  isApplicable: (info, data) => {
    return guessCifVariant(info, data) === "segcif" ? true : false;
  },
  parse: async (plugin, data) => {
    var _a;
    const cifCell = await plugin.build().to(data).apply(StateTransforms.Data.ParseCif).commit();
    const b4 = plugin.build().to(cifCell);
    const blocks = cifCell.obj.data.blocks;
    if (blocks.length === 0)
      throw new Error("no data blocks");
    const volumes = [];
    for (const block of blocks) {
      if (block.header.toUpperCase() === "SERVER")
        continue;
      if (((_a = block.categories["volume_data_3d_info"]) === null || _a === void 0 ? void 0 : _a.rowCount) > 0) {
        volumes.push(b4.apply(StateTransforms.Volume.VolumeFromSegmentationCif, { blockHeader: block.header }).selector);
      }
    }
    await b4.commit();
    return { volumes };
  },
  visuals: async (plugin, data) => {
    const { volumes } = data;
    const tree = plugin.build();
    const visuals = [];
    if (volumes.length > 0) {
      const segmentation = Volume.Segmentation.get(volumes[0].data);
      if (segmentation) {
        visuals[visuals.length] = tree.to(volumes[0]).apply(StateTransforms.Representation.VolumeRepresentation3D, VolumeRepresentation3DHelpers.getDefaultParams(plugin, "segment", volumes[0].data, { alpha: 1, instanceGranularity: true }, "volume-segment", {})).selector;
      }
    }
    await tree.commit();
    return visuals;
  }
});
var BuiltInVolumeFormats = [
  ["ccp4", Ccp4Provider],
  ["dsn6", Dsn6Provider],
  ["cube", CubeProvider],
  ["dx", DxProvider],
  ["dscif", DscifProvider],
  ["segcif", SegcifProvider]
];

// node_modules/molstar/lib/mol-plugin-state/formats/shape.js
var ShapeFormatCategory = "Shape";
var PlyProvider = DataFormatProvider({
  label: "PLY",
  description: "PLY",
  category: ShapeFormatCategory,
  stringExtensions: ["ply"],
  parse: async (plugin, data) => {
    const format = plugin.state.data.build().to(data).apply(StateTransforms.Data.ParsePly, {}, { state: { isGhost: true } });
    const shape = format.apply(StateTransforms.Model.ShapeFromPly);
    await format.commit();
    return { format: format.selector, shape: shape.selector };
  },
  visuals(plugin, data) {
    const repr = plugin.state.data.build().to(data.shape).apply(StateTransforms.Representation.ShapeRepresentation3D);
    return repr.commit();
  }
});
var BuiltInShapeFormats = [
  ["ply", PlyProvider]
];

// node_modules/molstar/lib/mol-plugin-state/formats/registry.js
var DataFormatRegistry = class {
  get types() {
    return this._list.map((e) => [e.name, e.provider.label]);
  }
  get extensions() {
    if (this._extensions)
      return this._extensions;
    const extensions = /* @__PURE__ */ new Set();
    this._list.forEach(({ provider }) => {
      var _a, _b;
      (_a = provider.stringExtensions) === null || _a === void 0 ? void 0 : _a.forEach((ext) => extensions.add(ext));
      (_b = provider.binaryExtensions) === null || _b === void 0 ? void 0 : _b.forEach((ext) => extensions.add(ext));
    });
    this._extensions = extensions;
    return extensions;
  }
  get binaryExtensions() {
    if (this._binaryExtensions)
      return this._binaryExtensions;
    const binaryExtensions = /* @__PURE__ */ new Set();
    this._list.forEach(({ provider }) => {
      var _a;
      return (_a = provider.binaryExtensions) === null || _a === void 0 ? void 0 : _a.forEach((ext) => binaryExtensions.add(ext));
    });
    this._binaryExtensions = binaryExtensions;
    return binaryExtensions;
  }
  get options() {
    if (this._options)
      return this._options;
    const options = [];
    this._list.forEach(({ name: name2, provider }) => options.push([name2, provider.label, provider.category || ""]));
    this._options = options;
    return options;
  }
  constructor() {
    this._list = [];
    this._map = /* @__PURE__ */ new Map();
    this._extensions = void 0;
    this._binaryExtensions = void 0;
    this._options = void 0;
    for (const [id, p] of BuiltInVolumeFormats)
      this.add(id, p);
    for (const [id, p] of BuiltInTopologyFormats)
      this.add(id, p);
    for (const [id, p] of BuiltInCoordinatesFormats)
      this.add(id, p);
    for (const [id, p] of BuiltInShapeFormats)
      this.add(id, p);
    for (const [id, p] of BuiltInTrajectoryFormats)
      this.add(id, p);
  }
  _clear() {
    this._extensions = void 0;
    this._binaryExtensions = void 0;
    this._options = void 0;
  }
  add(name2, provider) {
    this._clear();
    this._list.push({ name: name2, provider });
    this._map.set(name2, provider);
  }
  remove(name2) {
    this._clear();
    this._list.splice(this._list.findIndex((e) => e.name === name2), 1);
    this._map.delete(name2);
  }
  auto(info, dataStateObject) {
    var _a, _b;
    for (let i = 0, il = this.list.length; i < il; ++i) {
      const p = this._list[i].provider;
      let hasExt = false;
      if ((_a = p.binaryExtensions) === null || _a === void 0 ? void 0 : _a.includes(info.ext))
        hasExt = true;
      else if ((_b = p.stringExtensions) === null || _b === void 0 ? void 0 : _b.includes(info.ext))
        hasExt = true;
      if (hasExt && (!p.isApplicable || p.isApplicable(info, dataStateObject.data)))
        return p;
    }
    return;
  }
  get(name2) {
    if (this._map.has(name2)) {
      return this._map.get(name2);
    } else {
      throw new Error(`unknown data format name '${name2}'`);
    }
  }
  get list() {
    return this._list;
  }
};

// node_modules/molstar/lib/mol-plugin-state/manager/animation.js
var PluginAnimationManager = class extends StatefulPluginComponent {
  get isEmpty() {
    return this._animations.length === 0;
  }
  get current() {
    return this._current;
  }
  get animations() {
    return this._animations;
  }
  triggerUpdate() {
    this.events.updated.next(void 0);
  }
  triggerApply() {
    this.events.applied.next(void 0);
  }
  getParams() {
    if (!this._params) {
      this._params = {
        current: ParamDefinition.Select(this._animations[0] && this._animations[0].name, this._animations.map((a4) => [a4.name, a4.display.name]), { label: "Animation" })
      };
    }
    return this._params;
  }
  updateParams(newParams) {
    if (this.isEmpty)
      return;
    this.updateState({ params: { ...this.state.params, ...newParams } });
    const anim = this.map.get(this.state.params.current);
    const params = anim.params(this.context);
    this._current = {
      anim,
      params,
      paramValues: ParamDefinition.getDefaultValues(params),
      state: {},
      startedTime: -1,
      lastTime: 0
    };
    this.triggerUpdate();
  }
  updateCurrentParams(values2) {
    if (this.isEmpty)
      return;
    this._current.paramValues = { ...this._current.paramValues, ...values2 };
    this.triggerUpdate();
  }
  register(animation) {
    if (this.map.has(animation.name)) {
      this.context.log.error(`Animation '${animation.name}' is already registered.`);
      return;
    }
    this._params = void 0;
    this.map.set(animation.name, animation);
    this._animations.push(animation);
    if (this._animations.length === 1) {
      this.updateParams({ current: animation.name });
    } else {
      this.triggerUpdate();
    }
  }
  async play(animation, params) {
    await this.stop();
    if (!this.map.has(animation.name)) {
      this.register(animation);
    }
    this.updateParams({ current: animation.name });
    this.updateCurrentParams(params);
    await this.start();
  }
  async tick(t4, isSynchronous, animation) {
    this.currentTime = t4;
    if (this.isStopped)
      return;
    if (isSynchronous || animation) {
      await this.applyFrame(animation);
    } else {
      this.applyAsync();
    }
  }
  async start() {
    this.updateState({ animationState: "playing" });
    if (!this.context.behaviors.state.isAnimating.value) {
      this.context.behaviors.state.isAnimating.next(true);
    }
    this.triggerUpdate();
    const anim = this._current.anim;
    let initialState = this._current.anim.initialState(this._current.paramValues, this.context);
    if (anim.setup) {
      const state = await anim.setup(this._current.paramValues, initialState, this.context);
      if (state)
        initialState = state;
    }
    this._current.lastTime = 0;
    this._current.startedTime = -1;
    this._current.state = initialState;
    this.isStopped = false;
  }
  async stop() {
    this.isStopped = true;
    if (this.state.animationState !== "stopped") {
      const anim = this._current.anim;
      if (anim.teardown) {
        await anim.teardown(this._current.paramValues, this._current.state, this.context);
      }
      this.updateState({ animationState: "stopped" });
      this.triggerUpdate();
    }
    if (this.context.behaviors.state.isAnimating.value) {
      this.context.behaviors.state.isAnimating.next(false);
    }
  }
  get isAnimating() {
    return this.state.animationState === "playing";
  }
  async applyAsync() {
    if (this.isApplying)
      return;
    this.isApplying = true;
    try {
      await this.applyFrame();
    } finally {
      this.isApplying = false;
    }
  }
  async applyFrame(animation) {
    const t4 = this.currentTime;
    if (this._current.startedTime < 0)
      this._current.startedTime = t4;
    const newState = await this._current.anim.apply(this._current.state, { lastApplied: this._current.lastTime, current: t4 - this._current.startedTime, animation }, { params: this._current.paramValues, plugin: this.context });
    if (newState.kind === "finished") {
      this.stop();
    } else if (newState.kind === "next") {
      this._current.state = newState.state;
      this._current.lastTime = t4 - this._current.startedTime;
    }
    this.triggerApply();
  }
  getSnapshot() {
    if (!this.current)
      return { state: this.state };
    return {
      state: this.state,
      current: {
        paramValues: this._current.paramValues,
        state: this._current.anim.stateSerialization ? this._current.anim.stateSerialization.toJSON(this._current.state) : this._current.state
      }
    };
  }
  setSnapshot(snapshot) {
    if (this.isEmpty)
      return;
    this.updateState({ animationState: snapshot.state.animationState });
    this.updateParams(snapshot.state.params);
    if (snapshot.current) {
      this.current.paramValues = snapshot.current.paramValues;
      this.current.state = this._current.anim.stateSerialization ? this._current.anim.stateSerialization.fromJSON(snapshot.current.state) : snapshot.current.state;
      this.triggerUpdate();
      if (this.state.animationState === "playing")
        this.resume();
    }
  }
  async resume() {
    this._current.lastTime = 0;
    this._current.startedTime = -1;
    const anim = this._current.anim;
    if (!this.context.behaviors.state.isAnimating.value) {
      this.context.behaviors.state.isAnimating.next(true);
    }
    if (anim.setup) {
      await anim.setup(this._current.paramValues, this._current.state, this.context);
    }
    this.isStopped = false;
  }
  constructor(context) {
    super({ params: { current: "" }, animationState: "stopped" });
    this.context = context;
    this.map = /* @__PURE__ */ new Map();
    this._animations = [];
    this.currentTime = 0;
    this._params = void 0;
    this.events = {
      updated: this.ev(),
      applied: this.ev()
    };
    this.isStopped = true;
    this.isApplying = false;
  }
};

// node_modules/molstar/lib/mol-plugin-state/manager/focus-camera/focus-first-residue.js
function calculateDisplacement(position3, origin, normalDir) {
  const A = normalDir[0];
  const B = normalDir[1];
  const C = normalDir[2];
  const D = -A * origin[0] - B * origin[1] - C * origin[2];
  const x = position3[0];
  const y = position3[1];
  const z = position3[2];
  const displacement = (A * x + B * y + C * z + D) / Math.sqrt(A * A + B * B + C * C);
  return displacement;
}
function getAxesToFlip(position3, origin, up, normalDir) {
  const toYAxis = calculateDisplacement(position3, origin, normalDir);
  const toXAxis = calculateDisplacement(position3, origin, up);
  return {
    aroundX: toXAxis < 0,
    aroundY: toYAxis < 0
  };
}
function pcaFocus(plugin, radius, options) {
  if (!plugin.canvas3d)
    return;
  const { origin, dirA, dirB, dirC } = options.principalAxes.boxAxes;
  const up = Vec3.clone(dirA);
  const dir = Vec3.clone(dirC);
  if (options.positionToFlip) {
    const { aroundX, aroundY } = getAxesToFlip(options.positionToFlip, origin, up, dirB);
    if (aroundX) {
      Vec3.negate(dir, dir);
      Vec3.negate(up, up);
    }
    if (aroundY) {
      Vec3.negate(dir, dir);
    }
  }
  const position3 = Vec3.scale(Vec3(), origin, -100);
  if (Vec3.dot(position3, up) <= 0) {
    Vec3.negate(dir, dir);
  }
  if (Vec3.dot(Vec3.unitY, dir) <= 0) {
    Vec3.negate(up, up);
  }
  return plugin.canvas3d.camera.getFocus(origin, radius, up, dir, Camera.createDefaultSnapshot());
}

// node_modules/molstar/lib/mol-plugin-state/manager/focus-camera/focus-object.js
function getFocusSnapshot(plugin, options) {
  var _a, _b;
  if (!plugin.canvas3d)
    return void 0;
  const targetSpheres = (_a = options.targets) === null || _a === void 0 ? void 0 : _a.map((target) => {
    var _a2, _b2, _c;
    const bounding = target.targetRef !== void 0 ? getCellBoundingSphere(plugin, target.targetRef) : getPluginBoundingSphere(plugin);
    if (!bounding)
      return void 0;
    const radius = (_a2 = target.radius) !== null && _a2 !== void 0 ? _a2 : bounding.radius * ((_b2 = target.radiusFactor) !== null && _b2 !== void 0 ? _b2 : 1) + ((_c = target.extraRadius) !== null && _c !== void 0 ? _c : 0);
    return Sphere3D.create(bounding.center, radius);
  }).filter((sphere) => sphere !== void 0);
  const mergedSphere = targetSpheres && targetSpheres.length > 0 ? boundingSphereOfSpheres(targetSpheres) : getPluginBoundingSphere(plugin);
  return snapshotFromSphereAndDirections(plugin.canvas3d.camera, {
    center: mergedSphere.center,
    radius: Math.max(mergedSphere.radius, (_b = options.minRadius) !== null && _b !== void 0 ? _b : 0),
    up: options.up,
    direction: options.direction
  });
}
var _tmpVec = Vec3();
function snapshotFromSphereAndDirections(camera, options) {
  var _a, _b;
  const target = options.center;
  const radius = Math.max(options.radius, 0.01);
  const direction = (_a = options.direction) !== null && _a !== void 0 ? _a : Vec3.sub(Vec3(), camera.target, camera.position);
  const up = Vec3.orthogonalize(Vec3(), direction, (_b = options.up) !== null && _b !== void 0 ? _b : camera.up);
  const distance = camera.getTargetDistance(radius);
  const deltaDirection = Vec3.setMagnitude(_tmpVec, direction, distance);
  const position3 = Vec3.sub(Vec3(), target, deltaDirection);
  return { target, position: position3, up, radius };
}
function getCellBoundingSphere(plugin, cellRef) {
  const spheres = collectCellBoundingSpheres([], plugin, cellRef);
  if (spheres.length === 0)
    return void 0;
  if (spheres.length === 1)
    return spheres[0];
  return boundingSphereOfSpheres(spheres);
}
function collectCellBoundingSpheres(out, plugin, cellRef) {
  const cell = plugin.state.data.cells.get(cellRef);
  const spheres = getStateObjectBoundingSpheres(cell === null || cell === void 0 ? void 0 : cell.obj);
  if (spheres) {
    out.push(...spheres);
  } else {
    const children = plugin.state.data.tree.children.get(cellRef);
    children.forEach((child) => collectCellBoundingSpheres(out, plugin, child));
  }
  return out;
}
function getStateObjectBoundingSpheres(obj) {
  if (!obj)
    return void 0;
  if (!obj.data) {
    console.warn("Focus: no data");
    return void 0;
  }
  if (obj.data instanceof Structure) {
    const sphere = Loci.getBoundingSphere(Structure.Loci(obj.data));
    return sphere ? [sphere] : [];
  } else if (PluginStateObject.isRepresentation3D(obj)) {
    const out = [];
    for (const renderObject of obj.data.repr.renderObjects) {
      const sphere = renderObject.values.boundingSphere.ref.value;
      if (sphere.radius > 0)
        out.push(sphere);
    }
    return out;
  }
  return void 0;
}
function getPluginBoundingSphere(plugin) {
  const renderObjects = getRenderObjects(plugin, false);
  const spheres = renderObjects.map((r) => r.values.boundingSphere.ref.value).filter((sphere) => sphere.radius > 0);
  return boundingSphereOfSpheres(spheres);
}
function getRenderObjects(plugin, includeHidden) {
  let reprCells = Array.from(plugin.state.data.cells.values()).filter((cell) => cell.obj && PluginStateObject.isRepresentation3D(cell.obj));
  if (!includeHidden)
    reprCells = reprCells.filter((cell) => !cell.state.isHidden);
  const renderables = reprCells.flatMap((cell) => cell.obj.data.repr.renderObjects);
  return renderables;
}
var boundaryHelper = void 0;
function boundingSphereOfSpheres(spheres) {
  boundaryHelper !== null && boundaryHelper !== void 0 ? boundaryHelper : boundaryHelper = new BoundaryHelper("98");
  boundaryHelper.reset();
  for (const s of spheres)
    boundaryHelper.includeSphere(s);
  boundaryHelper.finishedIncludeStep();
  for (const s of spheres)
    boundaryHelper.radiusSphere(s);
  return boundaryHelper.getSphere();
}

// node_modules/molstar/lib/mol-plugin-state/manager/focus-camera/orient-axes.js
var MIN_ATOMS_FOR_PCA = 3;
var ROTATION_MATRICES = {
  // The order of elements in the matrices in column-wise (F-style)
  identity: Mat3.create(1, 0, 0, 0, 1, 0, 0, 0, 1),
  rotX90: Mat3.create(1, 0, 0, 0, 0, 1, 0, -1, 0),
  rotY90: Mat3.create(0, 0, -1, 0, 1, 0, 1, 0, 0),
  rotZ90: Mat3.create(0, 1, 0, -1, 0, 0, 0, 0, 1),
  rotX270: Mat3.create(1, 0, 0, 0, 0, -1, 0, 1, 0),
  rotY270: Mat3.create(0, 0, 1, 0, 1, 0, -1, 0, 0),
  rotZ270: Mat3.create(0, -1, 0, 1, 0, 0, 0, 0, 1),
  rotX180: Mat3.create(1, 0, 0, 0, -1, 0, 0, 0, -1),
  rotY180: Mat3.create(-1, 0, 0, 0, 1, 0, 0, 0, -1),
  rotZ180: Mat3.create(-1, 0, 0, 0, -1, 0, 0, 0, 1)
};
function structureLayingTransform(structures, referenceRotation) {
  const coords = smartSelectCoords(structures, MIN_ATOMS_FOR_PCA);
  return layingTransform(coords, referenceRotation);
}
function layingTransform(coords, referenceRotation) {
  if (coords.length === 0) {
    console.warn("Skipping PCA, no atoms");
    return { rotation: ROTATION_MATRICES.identity, origin: Vec3.zero() };
  }
  const axes = PrincipalAxes.calculateMomentsAxes(coords);
  const normAxes = PrincipalAxes.calculateNormalizedAxes(axes);
  const R = mat3FromRows(normAxes.dirA, normAxes.dirB, normAxes.dirC);
  avoidMirrorRotation(R);
  const flip = referenceRotation ? minimalFlip(R, referenceRotation) : canonicalFlip(coords, R, axes.origin);
  Mat3.mul(R, flip, R);
  return { rotation: R, origin: normAxes.origin };
}
function smartSelectCoords(structures, minAtoms) {
  let coords;
  coords = selectCoords(structures, { onlyTrace: true });
  if (coords.length >= 3 * minAtoms)
    return coords;
  coords = selectCoords(structures, { skipHydrogens: true, skipWater: true });
  if (coords.length >= 3 * minAtoms)
    return coords;
  coords = selectCoords(structures, {});
  return coords;
}
function selectCoords(structures, options) {
  const { onlyTrace, skipHydrogens, skipWater } = options;
  const { x, y, z, type_symbol, label_comp_id } = StructureProperties.atom;
  const coords = [];
  for (const struct of structures) {
    const loc = element_exports.Location.create(struct);
    for (const unit of struct.units) {
      loc.unit = unit;
      const elements = onlyTrace ? unit.polymerElements : unit.elements;
      for (let i = 0; i < elements.length; i++) {
        loc.element = elements[i];
        if (skipHydrogens && type_symbol(loc) === "H")
          continue;
        if (skipWater && label_comp_id(loc) === "HOH")
          continue;
        coords.push(x(loc), y(loc), z(loc));
      }
    }
  }
  return coords;
}
function minimalFlip(rotation, referenceRotation) {
  let bestFlip = ROTATION_MATRICES.identity;
  let bestScore = 0;
  const aux = Mat3();
  for (const flip of [ROTATION_MATRICES.identity, ROTATION_MATRICES.rotX180, ROTATION_MATRICES.rotY180, ROTATION_MATRICES.rotZ180]) {
    const score = Mat3.innerProduct(Mat3.mul(aux, flip, rotation), referenceRotation);
    if (score > bestScore) {
      bestFlip = flip;
      bestScore = score;
    }
  }
  return bestFlip;
}
function canonicalFlip(coords, rotation, origin) {
  const pcaX = Vec3.create(Mat3.getValue(rotation, 0, 0), Mat3.getValue(rotation, 0, 1), Mat3.getValue(rotation, 0, 2));
  const pcaY = Vec3.create(Mat3.getValue(rotation, 1, 0), Mat3.getValue(rotation, 1, 1), Mat3.getValue(rotation, 1, 2));
  const pcaZ = Vec3.create(Mat3.getValue(rotation, 2, 0), Mat3.getValue(rotation, 2, 1), Mat3.getValue(rotation, 2, 2));
  const n = Math.floor(coords.length / 3);
  const v2 = Vec3();
  let xCum = 0;
  let yCum = 0;
  let zCum = 0;
  for (let i = 0; i < n; i++) {
    Vec3.fromArray(v2, coords, 3 * i);
    Vec3.sub(v2, v2, origin);
    xCum += i * Vec3.dot(v2, pcaX);
    yCum += i * Vec3.dot(v2, pcaY);
    zCum += veeSlope(i, n) * Vec3.dot(v2, pcaZ);
  }
  const wrongFrontBack = zCum < 0;
  const wrongLeftTopRightBottom = wrongFrontBack ? xCum + yCum < 0 : xCum - yCum < 0;
  if (wrongLeftTopRightBottom && wrongFrontBack) {
    return ROTATION_MATRICES.rotY180;
  } else if (wrongFrontBack) {
    return ROTATION_MATRICES.rotX180;
  } else if (wrongLeftTopRightBottom) {
    return ROTATION_MATRICES.rotZ180;
  } else {
    return ROTATION_MATRICES.identity;
  }
}
function veeSlope(i, n) {
  const mid2 = Math.floor(n / 2);
  if (i < mid2) {
    if (n % 2)
      return mid2 - i;
    else
      return mid2 - i - 1;
  } else {
    return i - mid2;
  }
}
function mat3FromRows(row0, row1, row2) {
  const m = Mat3();
  Mat3.setValue(m, 0, 0, row0[0]);
  Mat3.setValue(m, 0, 1, row0[1]);
  Mat3.setValue(m, 0, 2, row0[2]);
  Mat3.setValue(m, 1, 0, row1[0]);
  Mat3.setValue(m, 1, 1, row1[1]);
  Mat3.setValue(m, 1, 2, row1[2]);
  Mat3.setValue(m, 2, 0, row2[0]);
  Mat3.setValue(m, 2, 1, row2[1]);
  Mat3.setValue(m, 2, 2, row2[2]);
  return m;
}
function avoidMirrorRotation(rot) {
  if (Mat3.determinant(rot) < 0) {
    Mat3.setValue(rot, 2, 0, -Mat3.getValue(rot, 2, 0));
    Mat3.setValue(rot, 2, 1, -Mat3.getValue(rot, 2, 1));
    Mat3.setValue(rot, 2, 2, -Mat3.getValue(rot, 2, 2));
  }
}
function changeCameraRotation(old, rotation) {
  const cameraRotation = Mat3.invert(Mat3(), rotation);
  const dist = Vec3.distance(old.position, old.target);
  const relPosition = Vec3.transformMat3(Vec3(), Vec3.create(0, 0, dist), cameraRotation);
  const newUp = Vec3.transformMat3(Vec3(), Vec3.create(0, 1, 0), cameraRotation);
  const newPosition = Vec3.add(Vec3(), old.target, relPosition);
  return { ...old, position: newPosition, up: newUp };
}

// node_modules/molstar/lib/mol-plugin-state/manager/camera.js
var DefaultCameraFocusOptions = {
  minRadius: 5,
  extraRadius: 4,
  durationMs: 250
};
var CameraManager = class {
  transformedLoci(loci) {
    var _a, _b;
    if (element_exports.Loci.is(loci)) {
      const parent = (_b = (_a = this.plugin.helpers.substructureParent.get(loci.structure)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
      if (parent)
        loci = element_exports.Loci.remap(loci, parent);
    }
    return loci;
  }
  focusRenderObjects(objects, options) {
    if (!objects)
      return;
    const spheres = [];
    for (const o of objects) {
      const s = o.values.boundingSphere.ref.value;
      if (s.radius === 0)
        continue;
      spheres.push(s);
    }
    this.focusSpheres(spheres, (s) => s, options);
  }
  focusLoci(loci, options) {
    let sphere;
    if (Array.isArray(loci) && loci.length > 1) {
      const spheres = [];
      for (const l of loci) {
        const s = Loci.getBoundingSphere(this.transformedLoci(l));
        if (s)
          spheres.push(s);
      }
      if (spheres.length === 0)
        return;
      this.boundaryHelper.reset();
      for (const s of spheres) {
        this.boundaryHelper.includeSphere(s);
      }
      this.boundaryHelper.finishedIncludeStep();
      for (const s of spheres) {
        this.boundaryHelper.radiusSphere(s);
      }
      sphere = this.boundaryHelper.getSphere();
    } else if (Array.isArray(loci)) {
      if (loci.length === 0)
        return;
      sphere = Loci.getBoundingSphere(this.transformedLoci(loci[0]));
    } else {
      sphere = Loci.getBoundingSphere(this.transformedLoci(loci));
    }
    if (sphere) {
      this.focusSphere(sphere, options);
    }
  }
  focusSpheres(xs, sphere, options) {
    const spheres = [];
    for (const x of xs) {
      const s = sphere(x);
      if (s)
        spheres.push(s);
    }
    if (spheres.length === 0)
      return;
    if (spheres.length === 1)
      return this.focusSphere(spheres[0], options);
    this.boundaryHelper.reset();
    for (const s of spheres) {
      this.boundaryHelper.includeSphere(s);
    }
    this.boundaryHelper.finishedIncludeStep();
    for (const s of spheres) {
      this.boundaryHelper.radiusSphere(s);
    }
    this.focusSphere(this.boundaryHelper.getSphere(), options);
  }
  focusSphere(sphere, options) {
    var _a;
    const { canvas3d } = this.plugin;
    if (!canvas3d)
      return;
    const { extraRadius, minRadius, durationMs } = { ...DefaultCameraFocusOptions, ...options };
    const radius = Math.max(sphere.radius + extraRadius, minRadius);
    if (options === null || options === void 0 ? void 0 : options.principalAxes) {
      const snapshot = pcaFocus(this.plugin, radius, options);
      (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({ durationMs, snapshot });
    } else {
      const snapshot = canvas3d.camera.getFocus(sphere.center, radius);
      canvas3d.requestCameraReset({ durationMs, snapshot });
    }
  }
  /** Focus on a set of plugin state object cells (if `options.targets` is non-empty) or on the whole scene (if `options.targets` is empty). */
  focusObject(options) {
    var _a, _b, _c;
    if (!this.plugin.canvas3d)
      return;
    const snapshot = getFocusSnapshot(this.plugin, {
      ...options,
      targets: (_a = options.targets) === null || _a === void 0 ? void 0 : _a.map((t4) => {
        var _a2;
        return { ...t4, extraRadius: (_a2 = t4.extraRadius) !== null && _a2 !== void 0 ? _a2 : DefaultCameraFocusOptions.extraRadius };
      }),
      minRadius: (_b = options.minRadius) !== null && _b !== void 0 ? _b : DefaultCameraFocusOptions.minRadius
    });
    this.plugin.canvas3d.requestCameraReset({ snapshot, durationMs: (_c = options.durationMs) !== null && _c !== void 0 ? _c : DefaultCameraFocusOptions.durationMs });
  }
  /** Align PCA axes of `structures` (default: all loaded structures) to the screen axes. */
  orientAxes(structures, durationMs) {
    if (!this.plugin.canvas3d)
      return;
    if (!structures) {
      const structCells = this.plugin.state.data.selectQ((q) => q.ofType(PluginStateObject.Molecule.Structure));
      const rootStructCells = structCells.filter((cell) => cell.obj && !cell.transform.transformer.definition.isDecorator && !cell.obj.data.parent);
      structures = rootStructCells.map((cell) => {
        var _a;
        return (_a = cell.obj) === null || _a === void 0 ? void 0 : _a.data;
      }).filter((struct) => !!struct);
    }
    const { rotation } = structureLayingTransform(structures);
    const newSnapshot = changeCameraRotation(this.plugin.canvas3d.camera.getSnapshot(), rotation);
    this.setSnapshot(newSnapshot, durationMs);
  }
  /** Align Cartesian axes to the screen axes (X right, Y up). */
  resetAxes(durationMs) {
    if (!this.plugin.canvas3d)
      return;
    const newSnapshot = changeCameraRotation(this.plugin.canvas3d.camera.getSnapshot(), Mat3.Identity);
    this.setSnapshot(newSnapshot, durationMs);
  }
  setSnapshot(snapshot, durationMs) {
    var _a;
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({ snapshot, durationMs });
  }
  reset(snapshot, durationMs) {
    var _a;
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({ snapshot, durationMs });
  }
  constructor(plugin) {
    this.plugin = plugin;
    this.boundaryHelper = new BoundaryHelper("98");
  }
};

// node_modules/molstar/lib/mol-plugin-state/manager/loci-label.js
var LociLabelManager = class {
  clearProviders() {
    this.providers = [];
    this.isDirty = true;
    this.showLabels();
  }
  addProvider(provider) {
    this.providers.push(provider);
    this.providers.sort((a4, b4) => (b4.priority || 0) - (a4.priority || 0));
    this.isDirty = true;
    this.showLabels();
  }
  removeProvider(provider) {
    this.providers = this.providers.filter((p) => p !== provider);
    this.isDirty = true;
    this.showLabels();
  }
  mark(loci, action) {
    const idx = this.locis.findIndex((l) => Representation.Loci.areEqual(loci, l));
    if (idx === -1 && action === MarkerAction.Highlight) {
      this.locis.push(loci);
      this.isDirty = true;
    } else if (idx !== -1 && action === MarkerAction.RemoveHighlight) {
      arrayRemoveAtInPlace(this.locis, idx);
      this.isDirty = true;
    }
  }
  showLabels() {
    this.ctx.behaviors.labels.highlight.next({ labels: this.getLabels() });
  }
  getLabels() {
    if (this.isDirty) {
      this.groupedLabels.clear();
      this.labels.length = 0;
      for (const provider of this.providers) {
        for (const loci of this.locis) {
          if (Loci.isEmpty(loci.loci))
            continue;
          const label = provider.label(loci.loci, loci.repr);
          if (label) {
            const hash = provider.group ? provider.group(label) : label.toString();
            const group = this.groupedLabels.get(hash);
            if (group)
              group.push(label);
            else
              this.groupedLabels.set(hash, [label]);
          }
        }
      }
      this.labels.length = 0;
      this.groupedLabels.forEach((group, hash) => {
        const count2 = group.length;
        const entry = count2 > 1 && group[0] !== group[1] ? hash : group[0];
        this.labels.push(count2 === 1 ? entry : `${entry} <small>||  ${count2}</small>`);
      });
      this.isDirty = false;
    }
    return this.labels;
  }
  constructor(ctx) {
    this.ctx = ctx;
    this.providers = [];
    this.locis = [];
    this.isDirty = false;
    this.labels = [];
    this.groupedLabels = /* @__PURE__ */ new Map();
    ctx.managers.interactivity.lociHighlights.addProvider((loci, action, noRender) => {
      if (this.providers.length === 0)
        return;
      this.mark(loci, action);
      if (!noRender)
        this.showLabels();
    });
  }
};

// node_modules/molstar/lib/mol-plugin-state/manager/structure/selection.js
var boundaryHelper2 = new BoundaryHelper("98");
var HISTORY_CAPACITY = 24;
var StructureSelectionManager = class extends StatefulPluginComponent {
  get entries() {
    return this.state.entries;
  }
  get additionsHistory() {
    return this.state.additionsHistory;
  }
  get stats() {
    if (this.state.stats)
      return this.state.stats;
    this.state.stats = this.calcStats();
    return this.state.stats;
  }
  getEntry(s) {
    const cell = this.plugin.helpers.substructureParent.get(s, true);
    if (!cell)
      return;
    const ref = cell.transform.ref;
    if (!this.entries.has(ref)) {
      const entry = new SelectionEntry(element_exports.Loci(s, []));
      this.entries.set(ref, entry);
      return entry;
    }
    return this.entries.get(ref);
  }
  calcStats() {
    let structureCount = 0;
    let elementCount = 0;
    const stats = element_exports.Stats.create();
    this.entries.forEach((v2) => {
      const { elements } = v2.selection;
      if (elements.length) {
        structureCount += 1;
        for (let i = 0, il = elements.length; i < il; ++i) {
          elementCount += OrderedSet.size(elements[i].indices);
        }
        element_exports.Stats.add(stats, stats, element_exports.Stats.ofLoci(v2.selection));
      }
    });
    const label = structureElementStatsLabel(stats, { countsOnly: true });
    return { structureCount, elementCount, label };
  }
  add(loci) {
    if (!element_exports.Loci.is(loci))
      return false;
    const entry = this.getEntry(loci.structure);
    if (!entry)
      return false;
    const sel = entry.selection;
    entry.selection = element_exports.Loci.union(entry.selection, loci);
    this.tryAddHistory(loci);
    this.referenceLoci = loci;
    this.events.loci.add.next(loci);
    return !element_exports.Loci.areEqual(sel, entry.selection);
  }
  remove(loci) {
    if (!element_exports.Loci.is(loci))
      return false;
    const entry = this.getEntry(loci.structure);
    if (!entry)
      return false;
    const sel = entry.selection;
    entry.selection = element_exports.Loci.subtract(entry.selection, loci);
    this.referenceLoci = loci;
    this.events.loci.remove.next(loci);
    return !element_exports.Loci.areEqual(sel, entry.selection);
  }
  intersect(loci) {
    if (!element_exports.Loci.is(loci))
      return false;
    const entry = this.getEntry(loci.structure);
    if (!entry)
      return false;
    const sel = entry.selection;
    entry.selection = element_exports.Loci.intersect(entry.selection, loci);
    this.referenceLoci = loci;
    return !element_exports.Loci.areEqual(sel, entry.selection);
  }
  set(loci) {
    if (!element_exports.Loci.is(loci))
      return false;
    const entry = this.getEntry(loci.structure);
    if (!entry)
      return false;
    const sel = entry.selection;
    entry.selection = loci;
    this.tryAddHistory(loci);
    this.referenceLoci = void 0;
    return !element_exports.Loci.areEqual(sel, entry.selection);
  }
  modifyHistory(entry, action, modulus, groupByStructure = false) {
    const history = this.additionsHistory;
    const idx = history.indexOf(entry);
    if (idx < 0)
      return;
    let swapWith = void 0;
    switch (action) {
      case "remove":
        arrayRemoveAtInPlace(history, idx);
        break;
      case "up":
        swapWith = idx - 1;
        break;
      case "down":
        swapWith = idx + 1;
        break;
    }
    if (swapWith !== void 0) {
      const mod = modulus ? Math.min(history.length, modulus) : history.length;
      while (true) {
        swapWith = swapWith % mod;
        if (swapWith < 0)
          swapWith += mod;
        if (!groupByStructure || history[idx].loci.structure === history[swapWith].loci.structure) {
          const t4 = history[idx];
          history[idx] = history[swapWith];
          history[swapWith] = t4;
          break;
        } else {
          swapWith += action === "up" ? -1 : 1;
        }
      }
    }
    this.events.additionsHistoryUpdated.next(void 0);
  }
  tryAddHistory(loci) {
    if (Loci.isEmpty(loci))
      return;
    let idx = 0, entry = void 0;
    for (const l of this.additionsHistory) {
      if (Loci.areEqual(l.loci, loci)) {
        entry = l;
        break;
      }
      idx++;
    }
    if (entry) {
      arrayRemoveAtInPlace(this.additionsHistory, idx);
      this.additionsHistory.unshift(entry);
      this.events.additionsHistoryUpdated.next(void 0);
      return;
    }
    const stats = element_exports.Stats.ofLoci(loci);
    const label = structureElementStatsLabel(stats, { reverse: true });
    this.additionsHistory.unshift({ id: UUID.create22(), loci, label });
    if (this.additionsHistory.length > HISTORY_CAPACITY)
      this.additionsHistory.pop();
    this.events.additionsHistoryUpdated.next(void 0);
  }
  clearHistory() {
    if (this.state.additionsHistory.length !== 0) {
      this.state.additionsHistory = [];
      this.events.additionsHistoryUpdated.next(void 0);
    }
  }
  clearHistoryForStructure(structure) {
    const historyEntryToRemove = [];
    for (const e of this.state.additionsHistory) {
      if (e.loci.structure.root === structure.root) {
        historyEntryToRemove.push(e);
      }
    }
    for (const e of historyEntryToRemove) {
      this.modifyHistory(e, "remove");
    }
    if (historyEntryToRemove.length !== 0) {
      this.events.additionsHistoryUpdated.next(void 0);
    }
  }
  onRemove(ref, obj) {
    var _a;
    if (this.entries.has(ref)) {
      this.entries.delete(ref);
      if (obj === null || obj === void 0 ? void 0 : obj.data) {
        this.clearHistoryForStructure(obj.data);
      }
      if (((_a = this.referenceLoci) === null || _a === void 0 ? void 0 : _a.structure) === (obj === null || obj === void 0 ? void 0 : obj.data)) {
        this.referenceLoci = void 0;
      }
      this.state.stats = void 0;
      this.events.changed.next(void 0);
    }
  }
  onUpdate(ref, oldObj, obj) {
    var _a, _b, _c, _d;
    if (oldObj === obj || (oldObj === null || oldObj === void 0 ? void 0 : oldObj.data) === obj.data)
      return;
    const cell = this.plugin.helpers.substructureParent.get(obj.data, true);
    if (!cell)
      return;
    if (ref !== cell.transform.ref)
      return;
    if (!this.entries.has(ref))
      return;
    const structure = (_b = (_a = this.plugin.helpers.substructureParent.get(obj.data)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!structure)
      return;
    if (!(oldObj === null || oldObj === void 0 ? void 0 : oldObj.data) || Structure.areUnitIdsAndIndicesEqual(oldObj.data, obj.data)) {
      this.entries.set(ref, remapSelectionEntry(this.entries.get(ref), structure));
      if (((_c = this.referenceLoci) === null || _c === void 0 ? void 0 : _c.structure.root) === structure.root) {
        this.referenceLoci = element_exports.Loci.remap(this.referenceLoci, structure);
      }
      let changedHistory = false;
      for (const e of this.state.additionsHistory) {
        if (e.loci.structure.root === structure.root) {
          e.loci = element_exports.Loci.remap(e.loci, structure);
          changedHistory = true;
        }
      }
      if (changedHistory)
        this.events.additionsHistoryUpdated.next(void 0);
    } else {
      this.entries.set(ref, new SelectionEntry(element_exports.Loci(structure, [])));
      if (((_d = this.referenceLoci) === null || _d === void 0 ? void 0 : _d.structure.root) === structure.root) {
        this.referenceLoci = void 0;
      }
      this.clearHistoryForStructure(structure);
      this.state.stats = void 0;
      this.events.changed.next(void 0);
    }
  }
  /** Removes all selections and returns them */
  clear() {
    const keys2 = this.entries.keys();
    const selections = [];
    while (true) {
      const k = keys2.next();
      if (k.done)
        break;
      const s = this.entries.get(k.value);
      if (!element_exports.Loci.isEmpty(s.selection))
        selections.push(s.selection);
      s.selection = element_exports.Loci(s.selection.structure, []);
    }
    this.referenceLoci = void 0;
    this.state.stats = void 0;
    this.events.changed.next(void 0);
    this.events.loci.clear.next(void 0);
    this.clearHistory();
    return selections;
  }
  getLoci(structure) {
    const entry = this.getEntry(structure);
    if (!entry)
      return EmptyLoci;
    return entry.selection;
  }
  getStructure(structure) {
    const entry = this.getEntry(structure);
    if (!entry)
      return;
    return entry.structure;
  }
  structureHasSelection(structure) {
    var _a, _b;
    const s = (_b = (_a = structure.cell) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!s)
      return false;
    const entry = this.getEntry(s);
    return !!entry && !element_exports.Loci.isEmpty(entry.selection);
  }
  has(loci) {
    if (element_exports.Loci.is(loci)) {
      const entry = this.getEntry(loci.structure);
      if (entry) {
        return element_exports.Loci.isSubset(entry.selection, loci);
      }
    }
    return false;
  }
  tryGetRange(loci) {
    if (!element_exports.Loci.is(loci))
      return;
    if (!this.getEntry(loci.structure))
      return;
    return getLociRange(this.referenceLoci, loci);
  }
  /** Count of all selected elements */
  elementCount() {
    let count2 = 0;
    this.entries.forEach((v2) => {
      count2 += element_exports.Loci.size(v2.selection);
    });
    return count2;
  }
  getBoundary() {
    const min2 = Vec3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max2 = Vec3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    boundaryHelper2.reset();
    const boundaries = [];
    this.entries.forEach((v2) => {
      const loci = v2.selection;
      if (!element_exports.Loci.isEmpty(loci)) {
        boundaries.push(element_exports.Loci.getBoundary(loci));
      }
    });
    for (let i = 0, il = boundaries.length; i < il; ++i) {
      const { box: box3, sphere } = boundaries[i];
      Vec3.min(min2, min2, box3.min);
      Vec3.max(max2, max2, box3.max);
      boundaryHelper2.includePositionRadius(sphere.center, sphere.radius);
    }
    boundaryHelper2.finishedIncludeStep();
    for (let i = 0, il = boundaries.length; i < il; ++i) {
      const { sphere } = boundaries[i];
      boundaryHelper2.radiusPositionRadius(sphere.center, sphere.radius);
    }
    return { box: { min: min2, max: max2 }, sphere: boundaryHelper2.getSphere() };
  }
  getPrincipalAxes() {
    const values2 = iterableToArray(this.entries.values());
    return element_exports.Loci.getPrincipalAxesMany(values2.map((v2) => v2.selection));
  }
  modify(modifier, loci) {
    let changed = false;
    switch (modifier) {
      case "add":
        changed = this.add(loci);
        break;
      case "remove":
        changed = this.remove(loci);
        break;
      case "intersect":
        changed = this.intersect(loci);
        break;
      case "set":
        changed = this.set(loci);
        break;
    }
    if (changed) {
      this.state.stats = void 0;
      this.events.changed.next(void 0);
    }
  }
  get applicableStructures() {
    return this.plugin.managers.structure.hierarchy.selection.structures.filter((s) => !!s.cell.obj).map((s) => s.cell.obj.data);
  }
  triggerInteraction(modifier, loci, applyGranularity = true) {
    switch (modifier) {
      case "add":
        this.plugin.managers.interactivity.lociSelects.select({ loci }, applyGranularity);
        break;
      case "remove":
        this.plugin.managers.interactivity.lociSelects.deselect({ loci }, applyGranularity);
        break;
      case "intersect":
        this.plugin.managers.interactivity.lociSelects.selectJoin({ loci }, applyGranularity);
        break;
      case "set":
        this.plugin.managers.interactivity.lociSelects.selectOnly({ loci }, applyGranularity);
        break;
    }
  }
  fromLoci(modifier, loci, applyGranularity = true) {
    this.triggerInteraction(modifier, loci, applyGranularity);
  }
  fromCompiledQuery(modifier, query, applyGranularity = true) {
    for (const s of this.applicableStructures) {
      const loci = query(new QueryContext(s));
      this.triggerInteraction(modifier, StructureSelection.toLociWithSourceUnits(loci), applyGranularity);
    }
  }
  fromSelectionQuery(modifier, query, applyGranularity = true) {
    this.plugin.runTask(Task.create("Structure Selection", async (runtime) => {
      for (const s of this.applicableStructures) {
        const loci = await query.getSelection(this.plugin, runtime, s);
        this.triggerInteraction(modifier, StructureSelection.toLociWithSourceUnits(loci), applyGranularity);
      }
    }));
  }
  fromSelections(ref) {
    var _a;
    const cell = StateObjectRef.resolveAndCheck(this.plugin.state.data, ref);
    if (!cell || !cell.obj)
      return;
    if (!PluginStateObject.Molecule.Structure.Selections.is(cell.obj)) {
      console.warn("fromSelections applied to wrong object type.", cell.obj);
      return;
    }
    this.clear();
    for (const s of (_a = cell.obj) === null || _a === void 0 ? void 0 : _a.data) {
      this.fromLoci("set", s.loci);
    }
  }
  getSnapshot() {
    const entries = [];
    this.entries.forEach((entry, ref) => {
      entries.push({
        ref,
        bundle: element_exports.Bundle.fromLoci(entry.selection)
      });
    });
    return { entries };
  }
  setSnapshot(snapshot) {
    var _a, _b;
    this.entries.clear();
    for (const { ref, bundle } of snapshot.entries) {
      const structure = (_b = (_a = this.plugin.state.data.select(StateSelection.Generators.byRef(ref))[0]) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
      if (!structure)
        continue;
      const loci = element_exports.Bundle.toLoci(bundle, structure);
      this.fromLoci("set", loci, false);
    }
  }
  constructor(plugin) {
    super({ entries: /* @__PURE__ */ new Map(), additionsHistory: [], stats: SelectionStats() });
    this.plugin = plugin;
    this.events = {
      changed: this.ev(),
      additionsHistoryUpdated: this.ev(),
      loci: {
        add: this.ev(),
        remove: this.ev(),
        clear: this.ev()
      }
    };
    plugin.helpers.substructureParent.events.removed.subscribe((e) => this.onRemove(e.ref, e.obj));
    plugin.helpers.substructureParent.events.updated.subscribe((e) => this.onUpdate(e.ref, e.oldObj, e.obj));
  }
};
function SelectionStats() {
  return { structureCount: 0, elementCount: 0, label: "Nothing Selected" };
}
var SelectionEntry = class {
  get selection() {
    return this._selection;
  }
  set selection(value) {
    this._selection = value;
    this._structure = void 0;
  }
  get structure() {
    if (this._structure)
      return this._structure;
    if (Loci.isEmpty(this._selection)) {
      this._structure = void 0;
    } else {
      this._structure = element_exports.Loci.toStructure(this._selection);
    }
    return this._structure;
  }
  constructor(selection) {
    this._structure = void 0;
    this._selection = selection;
  }
};
function remapSelectionEntry(e, s) {
  return new SelectionEntry(element_exports.Loci.remap(e.selection, s));
}
function getLociRange(fromLoci, toLoci) {
  if (!element_exports.Loci.is(fromLoci))
    return;
  if (!element_exports.Loci.is(toLoci))
    return;
  if (fromLoci.structure !== toLoci.structure)
    return;
  if (toLoci.elements.length !== 1)
    return;
  const xs = toLoci.elements[0];
  if (!xs)
    return;
  let e;
  for (const _e of fromLoci.elements) {
    if (xs.unit === _e.unit) {
      e = _e;
      break;
    }
  }
  if (!e)
    return;
  if (xs.unit !== e.unit)
    return;
  return getElementRange(toLoci.structure, e, xs);
}
function getElementRange(structure, ref, ext) {
  const min2 = Math.min(OrderedSet.min(ref.indices), OrderedSet.min(ext.indices));
  const max2 = Math.max(OrderedSet.max(ref.indices), OrderedSet.max(ext.indices));
  return element_exports.Loci(structure, [{
    unit: ref.unit,
    indices: OrderedSet.ofRange(min2, max2)
  }]);
}

// node_modules/molstar/lib/mol-plugin-state/manager/structure/focus.js
var HISTORY_CAPACITY2 = 8;
var StructureFocusManager = class extends StatefulPluginComponent {
  get current() {
    return this.state.current;
  }
  get history() {
    return this.state.history;
  }
  tryAddHistory(entry) {
    if (element_exports.Loci.isEmpty(entry.loci))
      return;
    let idx = 0, existingEntry = void 0;
    for (const e of this.state.history) {
      if (element_exports.Loci.areEqual(e.loci, entry.loci)) {
        existingEntry = e;
        break;
      }
      idx++;
    }
    if (existingEntry) {
      arrayRemoveAtInPlace(this.state.history, idx);
      this.state.history.unshift(entry);
      this.events.historyUpdated.next(void 0);
      return;
    }
    this.state.history.unshift(entry);
    if (this.state.history.length > HISTORY_CAPACITY2)
      this.state.history.pop();
    this.events.historyUpdated.next(void 0);
  }
  set(entry) {
    this.tryAddHistory(entry);
    if (!this.state.current || !element_exports.Loci.areEqual(this.state.current.loci, entry.loci)) {
      this.state.current = entry;
      this.behaviors.current.next(entry);
    }
  }
  tryGetRange(loci) {
    return getLociRange(this.referenceLoci, loci);
  }
  setFromLoci(anyLoci) {
    const loci = Loci.normalize(anyLoci);
    if (!element_exports.Loci.is(loci) || element_exports.Loci.isEmpty(loci)) {
      this.clear();
      return;
    }
    this.set({ loci, label: lociLabel(loci, { reverse: true, hidePrefix: true, htmlStyling: false }) });
    this.referenceLoci = loci;
  }
  addFromLoci(anyLoci) {
    const union = this.state.current && element_exports.Loci.is(anyLoci) && anyLoci.structure === this.state.current.loci.structure ? element_exports.Loci.union(anyLoci, this.state.current.loci) : anyLoci;
    this.setFromLoci(union);
    const refLoci = Loci.normalize(anyLoci);
    this.referenceLoci = element_exports.Loci.is(refLoci) ? refLoci : void 0;
  }
  toggleFromLoci(anyLoci) {
    var _a;
    const { kind, loci } = toggleLoci((_a = this.state.current) === null || _a === void 0 ? void 0 : _a.loci, anyLoci);
    this.setFromLoci(loci);
    const refLoci = Loci.normalize(anyLoci);
    this.referenceLoci = element_exports.Loci.is(refLoci) && kind !== "subtract" ? refLoci : void 0;
  }
  extendFromLoci(anyLoci) {
    var _a;
    const range = (_a = this.tryGetRange(anyLoci)) !== null && _a !== void 0 ? _a : anyLoci;
    this.toggleFromLoci(range);
  }
  clear() {
    if (this.state.current) {
      this.state.current = void 0;
      this.behaviors.current.next(void 0);
    }
    this.referenceLoci = void 0;
  }
  getSnapshot() {
    if (!this.current)
      return {};
    const node2 = this.plugin.helpers.substructureParent.get(this.current.loci.structure);
    const ref = node2 === null || node2 === void 0 ? void 0 : node2.transform.ref;
    if (!ref)
      return {};
    return {
      current: {
        label: this.current.label,
        ref,
        bundle: element_exports.Bundle.fromLoci(this.current.loci),
        category: this.current.category
      }
    };
  }
  setSnapshot(snapshot) {
    var _a, _b;
    if (!snapshot.current) {
      this.clear();
      return;
    }
    const { label, ref, bundle, category } = snapshot.current;
    const structure = (_b = (_a = this.plugin.state.data.select(StateSelection.Generators.byRef(ref))[0]) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
    if (!structure)
      return;
    const loci = element_exports.Bundle.toLoci(bundle, structure);
    this.set({ label, loci, category });
  }
  constructor(plugin) {
    super({ history: [] });
    this.plugin = plugin;
    this.events = {
      historyUpdated: this.ev()
    };
    this.behaviors = {
      current: this.ev.behavior(void 0)
    };
    plugin.state.data.events.object.removed.subscribe(({ obj }) => {
      var _a;
      if (!PluginStateObject.Molecule.Structure.is(obj))
        return;
      if (((_a = this.current) === null || _a === void 0 ? void 0 : _a.loci.structure) === obj.data) {
        this.clear();
      }
      const keep = [];
      for (const e of this.history) {
        if (e.loci.structure === obj.data)
          keep.push(e);
      }
      if (keep.length !== this.history.length) {
        this.history.length = 0;
        this.history.push(...keep);
        this.events.historyUpdated.next(void 0);
      }
    });
    const sphere = Sphere3D();
    plugin.state.data.events.object.updated.subscribe(({ oldData, obj, action }) => {
      var _a;
      if (!PluginStateObject.Molecule.Structure.is(obj))
        return;
      if (oldData === obj.data)
        return;
      if (action === "in-place") {
        const current = this.state.current;
        const structure = obj.data;
        if (current && current.loci.structure === oldData) {
          const loci = element_exports.Loci.remap(current.loci, structure);
          this.state.current = { ...current, loci };
          this.behaviors.current.next(this.state.current);
          Loci.getBoundingSphere(loci, sphere);
          const camera = (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera;
          const d3 = camera.getTargetDistance(sphere.radius + 4);
          if (Vec3.distance(camera.target, sphere.center) > sphere.radius || d3 > camera.viewport.height / camera.zoom) {
            this.plugin.managers.camera.focusSphere(sphere, { durationMs: 0 });
          }
        }
      }
    });
  }
};
function toggleLoci(currentLoci, newLoci) {
  if (currentLoci && element_exports.Loci.is(newLoci) && newLoci.structure === currentLoci.structure) {
    if (element_exports.Loci.isSubset(currentLoci, newLoci)) {
      return { kind: "subtract", loci: element_exports.Loci.subtract(currentLoci, newLoci) };
    } else {
      return { kind: "add", loci: element_exports.Loci.union(newLoci, currentLoci) };
    }
  } else {
    return { kind: "new", loci: newLoci };
  }
}

// node_modules/molstar/lib/mol-plugin/layout.js
var regionStateOptions = [
  ["full", "Full"],
  ["collapsed", "Collapsed"],
  ["hidden", "Hidden"]
];
var simpleRegionStateOptions = [
  ["full", "Full"],
  ["hidden", "Hidden"]
];
var PluginLayoutStateParams = {
  isExpanded: ParamDefinition.Boolean(false),
  showControls: ParamDefinition.Boolean(true),
  regionState: ParamDefinition.Group({
    left: ParamDefinition.Select("full", regionStateOptions),
    top: ParamDefinition.Select("full", simpleRegionStateOptions),
    right: ParamDefinition.Select("full", simpleRegionStateOptions),
    bottom: ParamDefinition.Select("full", simpleRegionStateOptions)
  }),
  controlsDisplay: ParamDefinition.Value("outside", { isHidden: true })
};
var PluginLayout = class extends StatefulPluginComponent {
  updateProps(state) {
    const prevExpanded = !!this.state.isExpanded;
    this.updateState(state);
    if (this.root && typeof state.isExpanded === "boolean" && state.isExpanded !== prevExpanded)
      this.handleExpand();
    this.events.updated.next(void 0);
  }
  setProps(props) {
    this.updateState(props);
  }
  setRoot(root3) {
    this.root = root3;
    if (this.state.isExpanded)
      this.handleExpand();
  }
  getScrollElement() {
    if (document.scrollingElement)
      return document.scrollingElement;
    if (document.documentElement)
      return document.documentElement;
    return document.body;
  }
  handleExpand() {
    try {
      const body = document.getElementsByTagName("body")[0];
      const head = document.getElementsByTagName("head")[0];
      if (!body || !head || !this.root)
        return;
      if (this.state.isExpanded) {
        const children = head.children;
        const viewports = [];
        let hasExp = false;
        for (let i = 0; i < children.length; i++) {
          if (children[i] === this.expandedViewport) {
            hasExp = true;
          } else if ((children[i].name || "").toLowerCase() === "viewport") {
            viewports.push(children[i]);
          }
        }
        for (const v2 of viewports) {
          head.removeChild(v2);
        }
        if (!hasExp)
          head.appendChild(this.expandedViewport);
        const s = body.style;
        const doc = this.getScrollElement();
        const scrollLeft = doc.scrollLeft;
        const scrollTop = doc.scrollTop;
        this.rootState = {
          top: s.top,
          bottom: s.bottom,
          right: s.right,
          left: s.left,
          scrollTop,
          scrollLeft,
          position: s.position,
          overflow: s.overflow,
          viewports,
          zIndex: this.root.style.zIndex,
          width: s.width,
          height: s.height,
          maxWidth: s.maxWidth,
          maxHeight: s.maxHeight,
          margin: s.margin,
          marginLeft: s.marginLeft,
          marginRight: s.marginRight,
          marginTop: s.marginTop,
          marginBottom: s.marginBottom
        };
        s.overflow = "hidden";
        s.position = "fixed";
        s.top = "0";
        s.bottom = "0";
        s.right = "0";
        s.left = "0";
        s.width = "100%";
        s.height = "100%";
        s.maxWidth = "100%";
        s.maxHeight = "100%";
        s.margin = "0";
        s.marginLeft = "0";
        s.marginRight = "0";
        s.marginTop = "0";
        s.marginBottom = "0";
      } else {
        const children = head.children;
        for (let i = 0; i < children.length; i++) {
          if (children[i] === this.expandedViewport) {
            head.removeChild(this.expandedViewport);
            break;
          }
        }
        if (this.rootState) {
          const t4 = this.rootState;
          for (const v2 of t4.viewports) {
            head.appendChild(v2);
          }
          const s = body.style;
          s.top = t4.top;
          s.bottom = t4.bottom;
          s.left = t4.left;
          s.right = t4.right;
          s.width = t4.width;
          s.height = t4.height;
          s.maxWidth = t4.maxWidth;
          s.maxHeight = t4.maxHeight;
          s.margin = t4.margin;
          s.marginLeft = t4.marginLeft;
          s.marginRight = t4.marginRight;
          s.marginTop = t4.marginTop;
          s.marginBottom = t4.marginBottom;
          s.position = t4.position;
          s.overflow = t4.overflow || "";
          const doc = this.getScrollElement();
          doc.scrollTop = t4.scrollTop;
          doc.scrollLeft = t4.scrollLeft;
          this.rootState = void 0;
          this.root.style.zIndex = t4.zIndex;
        }
      }
    } catch (e) {
      const msg = "Layout change error, you might have to reload the page.";
      this.context.log.error(msg);
      console.error(msg, e);
    }
  }
  constructor(context) {
    super({ ...ParamDefinition.getDefaultValues(PluginLayoutStateParams), ...context.spec.layout && context.spec.layout.initial });
    this.context = context;
    this.events = {
      updated: this.ev()
    };
    this.rootState = void 0;
    PluginCommands.Layout.Update.subscribe(context, (e) => this.updateProps(e.state));
    if (typeof document !== "undefined") {
      this.expandedViewport = document.createElement("meta");
      this.expandedViewport.name = "viewport";
      this.expandedViewport.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0";
    }
  }
};

// node_modules/molstar/lib/mol-repr/structure/visual/util/bond.js
var BondParams = {
  includeTypes: ParamDefinition.MultiSelect(ObjectKeys(BondType.Names), ParamDefinition.objectToOptions(BondType.Names)),
  excludeTypes: ParamDefinition.MultiSelect([], ParamDefinition.objectToOptions(BondType.Names)),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  aromaticBonds: ParamDefinition.Boolean(true, { description: "Display aromatic bonds with dashes" }),
  multipleBonds: ParamDefinition.Select("symmetric", ParamDefinition.arrayToOptions(["off", "symmetric", "offset"]))
};
var DefaultBondProps = ParamDefinition.getDefaultValues(BondParams);
var BondCylinderParams = {
  ...LinkCylinderParams,
  ...BondParams,
  adjustCylinderLength: ParamDefinition.Boolean(false, { description: "Shorten cylinders to reduce overlap with spheres. Useful for for transparent bonds. Not working well with aromatic bonds." })
};
var DefaultBondCylinderProps = ParamDefinition.getDefaultValues(BondCylinderParams);
var BondLineParams = {
  ...LinkLineParams,
  ...BondParams
};
var DefaultBondLineProps = ParamDefinition.getDefaultValues(BondLineParams);
function ignoreBondType(include, exclude, f) {
  return !BondType.is(include, f) || BondType.is(exclude, f);
}
function makeIntraBondIgnoreTest(structure, unit, props) {
  const elements = unit.elements;
  const bonds = unit.bonds;
  const { a: a4, b: b4, edgeProps } = bonds;
  const { flags: _flags } = edgeProps;
  const { ignoreHydrogens, ignoreHydrogensVariant, includeTypes, excludeTypes } = props;
  const include = BondType.fromNames(includeTypes);
  const exclude = BondType.fromNames(excludeTypes);
  const allBondTypes = BondType.isAll(include) && BondType.Flag.None === exclude;
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    throw new Error("expected childUnit to exist if child exists");
  if (allBondTypes && !ignoreHydrogens && !child)
    return;
  return (edgeIndex) => {
    const aI = a4[edgeIndex];
    const bI = b4[edgeIndex];
    if (!!childUnit && !SortedArray.has(childUnit.elements, elements[aI])) {
      return true;
    }
    if (!allBondTypes && ignoreBondType(include, exclude, _flags[edgeIndex])) {
      return true;
    }
    if (!ignoreHydrogens)
      return false;
    if (isHydrogen(structure, unit, elements[aI], ignoreHydrogensVariant) || isHydrogen(structure, unit, elements[bI], ignoreHydrogensVariant))
      return true;
    return false;
  };
}
function makeInterBondIgnoreTest(structure, props) {
  const bonds = structure.interUnitBonds;
  const { edges } = bonds;
  const { ignoreHydrogens, ignoreHydrogensVariant, includeTypes, excludeTypes } = props;
  const include = BondType.fromNames(includeTypes);
  const exclude = BondType.fromNames(excludeTypes);
  const allBondTypes = BondType.isAll(include) && BondType.Flag.None === exclude;
  const { child } = structure;
  if (allBondTypes && !ignoreHydrogens && !child)
    return;
  return (edgeIndex) => {
    if (child) {
      const b4 = edges[edgeIndex];
      const childUnitA = child.unitMap.get(b4.unitA);
      if (!childUnitA)
        return true;
      const unitA = structure.unitMap.get(b4.unitA);
      const eA = unitA.elements[b4.indexA];
      if (!SortedArray.has(childUnitA.elements, eA))
        return true;
    }
    if (ignoreHydrogens) {
      const b4 = edges[edgeIndex];
      const uA = structure.unitMap.get(b4.unitA);
      const uB = structure.unitMap.get(b4.unitB);
      if (isHydrogen(structure, uA, uA.elements[b4.indexA], ignoreHydrogensVariant) || isHydrogen(structure, uB, uB.elements[b4.indexB], ignoreHydrogensVariant))
        return true;
    }
    if (!allBondTypes) {
      if (ignoreBondType(include, exclude, edges[edgeIndex].props.flag))
        return true;
    }
    return false;
  };
}
function hasUnitVisibleBonds(unit, props) {
  if (Unit.Traits.is(unit.traits, Unit.Trait.Water)) {
    return !props.ignoreHydrogens || props.ignoreHydrogensVariant === "non-polar";
  }
  return true;
}
function hasStructureVisibleBonds(structure, props) {
  for (const { units } of structure.unitSymmetryGroups) {
    if (Unit.isAtomic(units[0]) && hasUnitVisibleBonds(units[0], props))
      return true;
  }
  return false;
}
var BondIterator;
(function(BondIterator2) {
  function fromGroup(structureGroup, props) {
    const { group, structure } = structureGroup;
    const unit = group.units[0];
    const groupCount = Unit.isAtomic(unit) ? unit.bonds.edgeCount * 2 : 0;
    const instanceCount = group.units.length;
    const location = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
    const getLocation = (groupIndex, instanceIndex) => {
      const unit2 = group.units[instanceIndex];
      location.aUnit = unit2;
      location.bUnit = unit2;
      location.aIndex = unit2.bonds.a[groupIndex];
      location.bIndex = unit2.bonds.b[groupIndex];
      return location;
    };
    if (props === null || props === void 0 ? void 0 : props.includeLocation2) {
      const location2 = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
      const getLocation2 = (groupIndex, instanceIndex) => {
        const unit2 = group.units[instanceIndex];
        location2.aUnit = unit2;
        location2.bUnit = unit2;
        location2.aIndex = unit2.bonds.b[groupIndex];
        location2.bIndex = unit2.bonds.a[groupIndex];
        return location2;
      };
      return LocationIterator(groupCount, instanceCount, 1, getLocation, false, () => false, getLocation2);
    }
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  BondIterator2.fromGroup = fromGroup;
  function fromStructure(structure, props) {
    const groupCount = structure.interUnitBonds.edgeCount;
    const instanceCount = 1;
    const location = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
    const getLocation = (groupIndex) => {
      const bond = structure.interUnitBonds.edges[groupIndex];
      location.aUnit = structure.unitMap.get(bond.unitA);
      location.aIndex = bond.indexA;
      location.bUnit = structure.unitMap.get(bond.unitB);
      location.bIndex = bond.indexB;
      return location;
    };
    if (props === null || props === void 0 ? void 0 : props.includeLocation2) {
      const location2 = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
      const getLocation2 = (groupIndex) => {
        const bond = structure.interUnitBonds.edges[groupIndex];
        location2.aUnit = structure.unitMap.get(bond.unitB);
        location2.aIndex = bond.indexB;
        location2.bUnit = structure.unitMap.get(bond.unitA);
        location2.bIndex = bond.indexA;
        return location2;
      };
      return LocationIterator(groupCount, instanceCount, 1, getLocation, true, () => false, getLocation2);
    }
    ;
    return LocationIterator(groupCount, instanceCount, 1, getLocation, true);
  }
  BondIterator2.fromStructure = fromStructure;
  function fromStructureGroups(structure, props) {
    const { bondCount: bondCount2, unitIndex, unitGroupIndex, unitEdgeIndex } = structure.intraUnitBondMapping;
    const groupCount = bondCount2;
    const instanceCount = 1;
    const location = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
    const getLocation = (groupIndex) => {
      const ug = structure.unitSymmetryGroups[unitIndex[groupIndex]];
      const unit = ug.units[unitGroupIndex[groupIndex]];
      const edgeIndex = unitEdgeIndex[groupIndex];
      location.aUnit = unit;
      location.bUnit = unit;
      location.aIndex = unit.bonds.a[edgeIndex];
      location.bIndex = unit.bonds.b[edgeIndex];
      return location;
    };
    if (props === null || props === void 0 ? void 0 : props.includeLocation2) {
      const location2 = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
      const getLocation2 = (groupIndex) => {
        const ug = structure.unitSymmetryGroups[unitIndex[groupIndex]];
        const unit = ug.units[unitGroupIndex[groupIndex]];
        const edgeIndex = unitEdgeIndex[groupIndex];
        location2.aUnit = unit;
        location2.bUnit = unit;
        location2.aIndex = unit.bonds.b[edgeIndex];
        location2.bIndex = unit.bonds.a[edgeIndex];
        return location2;
      };
      return LocationIterator(groupCount, instanceCount, 1, getLocation, true, () => false, getLocation2);
    }
    ;
    return LocationIterator(groupCount, instanceCount, 1, getLocation, true);
  }
  BondIterator2.fromStructureGroups = fromStructureGroups;
})(BondIterator || (BondIterator = {}));
function getIntraBondLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId, groupId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    if (Unit.isAtomic(unit)) {
      const { target } = structure;
      const iA = unit.bonds.a[groupId];
      const iB = unit.bonds.b[groupId];
      return Bond.Loci(target, [
        Bond.Location(target, unit, iA, target, unit, iB),
        Bond.Location(target, unit, iB, target, unit, iA)
      ]);
    }
  }
  return EmptyLoci;
}
function eachIntraBond(loci, structureGroup, apply, isMarking) {
  let changed = false;
  if (Bond.isLoci(loci)) {
    const { structure, group } = structureGroup;
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    const unit = group.units[0];
    if (!Unit.isAtomic(unit))
      return false;
    const groupCount = unit.bonds.edgeCount * 2;
    for (const b4 of loci.bonds) {
      if (b4.aUnit !== b4.bUnit)
        continue;
      const unitIdx = group.unitIndexMap.get(b4.aUnit.id);
      if (unitIdx !== void 0) {
        const idx = unit.bonds.getDirectedEdgeIndex(b4.aIndex, b4.bIndex);
        if (idx !== -1) {
          if (apply(Interval.ofSingleton(unitIdx * groupCount + idx)))
            changed = true;
        }
      }
    }
  } else if (element_exports.Loci.is(loci)) {
    const { structure, group } = structureGroup;
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    const unit = group.units[0];
    if (!Unit.isAtomic(unit))
      return false;
    const groupCount = unit.bonds.edgeCount * 2;
    for (const e of loci.elements) {
      const unitIdx = group.unitIndexMap.get(e.unit.id);
      if (unitIdx !== void 0) {
        const { offset, b: b4 } = unit.bonds;
        OrderedSet.forEach(e.indices, (v2) => {
          for (let t4 = offset[v2], _t = offset[v2 + 1]; t4 < _t; t4++) {
            if (!isMarking || OrderedSet.has(e.indices, b4[t4])) {
              if (apply(Interval.ofSingleton(unitIdx * groupCount + t4)))
                changed = true;
            }
          }
        });
      }
    }
  }
  return changed;
}
function getInterBondLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const { target } = structure;
    const b4 = structure.interUnitBonds.edges[groupId];
    const uA = structure.unitMap.get(b4.unitA);
    const uB = structure.unitMap.get(b4.unitB);
    return Bond.Loci(target, [
      Bond.Location(target, uA, b4.indexA, target, uB, b4.indexB),
      Bond.Location(target, uB, b4.indexB, target, uA, b4.indexA)
    ]);
  }
  return EmptyLoci;
}
var __unitMap = /* @__PURE__ */ new Map();
function eachInterBond(loci, structure, apply, isMarking) {
  let changed = false;
  if (Bond.isLoci(loci)) {
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    for (const b4 of loci.bonds) {
      const idx = structure.interUnitBonds.getBondIndexFromLocation(b4);
      if (idx !== -1) {
        if (apply(Interval.ofSingleton(idx)))
          changed = true;
      }
    }
  } else if (element_exports.Loci.is(loci)) {
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    if (isMarking && loci.elements.length === 1)
      return false;
    for (const e of loci.elements)
      __unitMap.set(e.unit.id, e.indices);
    for (const e of loci.elements) {
      const { unit } = e;
      if (!Unit.isAtomic(unit))
        continue;
      for (const b4 of structure.interUnitBonds.getConnectedUnits(unit.id)) {
        const otherLociIndices = __unitMap.get(b4.unitB);
        if (!isMarking || otherLociIndices) {
          OrderedSet.forEach(e.indices, (v2) => {
            if (!b4.connectedIndices.includes(v2))
              return;
            for (const bi of b4.getEdges(v2)) {
              if (!isMarking || otherLociIndices && OrderedSet.has(otherLociIndices, bi.indexB)) {
                const idx = structure.interUnitBonds.getEdgeIndex(v2, unit.id, bi.indexB, b4.unitB);
                if (apply(Interval.ofSingleton(idx)))
                  changed = true;
              }
            }
          });
        }
      }
    }
    __unitMap.clear();
  }
  return changed;
}
function getStructureGroupsBondLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const mapping = structure.intraUnitBondMapping;
    return getIntraBondLoci({
      objectId,
      instanceId: mapping.unitGroupIndex[groupId],
      groupId: mapping.unitEdgeIndex[groupId]
    }, {
      structure,
      group: structure.unitSymmetryGroups[mapping.unitIndex[groupId]]
    }, id);
  }
  return EmptyLoci;
}
function eachStructureGroupsBond(loci, structure, apply, isMarking) {
  const { unitGroupOffset } = structure.intraUnitBondMapping;
  let changed = false;
  if (Bond.isLoci(loci)) {
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    for (const b4 of loci.bonds) {
      if (b4.aUnit !== b4.bUnit)
        continue;
      const groupIdx = structure.unitSymmetryGroupsIndexMap.get(b4.aUnit.id);
      const group = structure.unitSymmetryGroups[groupIdx];
      const unit = group.units[0];
      if (!Unit.isAtomic(unit))
        continue;
      const o = unitGroupOffset[groupIdx];
      const groupCount = unit.bonds.edgeCount * 2;
      const unitIdx = group.unitIndexMap.get(b4.aUnit.id);
      if (unitIdx !== void 0) {
        const idx = unit.bonds.getDirectedEdgeIndex(b4.aIndex, b4.bIndex);
        if (idx !== -1) {
          if (apply(Interval.ofSingleton(unitIdx * groupCount + idx + o)))
            changed = true;
        }
      }
    }
  } else if (element_exports.Loci.is(loci)) {
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    for (const e of loci.elements) {
      const groupIdx = structure.unitSymmetryGroupsIndexMap.get(e.unit.id);
      const group = structure.unitSymmetryGroups[groupIdx];
      const unit = group.units[0];
      if (!Unit.isAtomic(unit))
        continue;
      const o = unitGroupOffset[groupIdx];
      const groupCount = unit.bonds.edgeCount * 2;
      const unitIdx = group.unitIndexMap.get(e.unit.id);
      if (unitIdx !== void 0) {
        const { offset, b: b4 } = unit.bonds;
        OrderedSet.forEach(e.indices, (v2) => {
          for (let t4 = offset[v2], _t = offset[v2 + 1]; t4 < _t; t4++) {
            if (!isMarking || OrderedSet.has(e.indices, b4[t4])) {
              if (apply(Interval.ofSingleton(unitIdx * groupCount + t4 + o)))
                changed = true;
            }
          }
        });
      }
    }
  }
  return changed;
}

// node_modules/molstar/lib/mol-repr/structure/visual/bond-intra-unit-cylinder.js
var isBondType = BondType.is;
function getIntraUnitBondCylinderBuilderProps(unit, structure, theme, props) {
  const elements = unit.elements;
  const bonds = unit.bonds;
  const { edgeCount, a: a4, b: b4, edgeProps, offset } = bonds;
  const { order: _order, flags: _flags } = edgeProps;
  const { sizeFactor, sizeAspectRatio, adjustCylinderLength, aromaticBonds, includeTypes, excludeTypes, multipleBonds } = props;
  const mbOff = multipleBonds === "off";
  const mbSymmetric = multipleBonds === "symmetric";
  const include = BondType.fromNames(includeTypes);
  const exclude = BondType.fromNames(excludeTypes);
  const ignoreComputedAromatic = ignoreBondType(include, exclude, BondType.Flag.Computed);
  const vRef = Vec3(), delta = Vec3();
  const c4 = unit.conformation;
  let stub;
  const locE = element_exports.Location.create(structure, unit);
  const locB = Bond.Location(structure, unit, void 0, structure, unit, void 0);
  const { child } = structure;
  if (props.includeParent && child) {
    const childUnit = child.unitMap.get(unit.id);
    if (!childUnit)
      throw new Error("expected childUnit to exist");
    stub = (edgeIndex) => {
      const eA = elements[a4[edgeIndex]];
      const eB = elements[b4[edgeIndex]];
      return SortedArray.has(childUnit.elements, eA) && !SortedArray.has(childUnit.elements, eB);
    };
  }
  const radius = (edgeIndex) => {
    locB.aIndex = a4[edgeIndex];
    locB.bIndex = b4[edgeIndex];
    return theme.size.size(locB) * sizeFactor;
  };
  const radiusA = (edgeIndex) => {
    locE.element = elements[a4[edgeIndex]];
    return theme.size.size(locE) * sizeFactor;
  };
  const radiusB = (edgeIndex) => {
    locE.element = elements[b4[edgeIndex]];
    return theme.size.size(locE) * sizeFactor;
  };
  const { elementRingIndices, elementAromaticRingIndices } = unit.rings;
  const deloTriplets = aromaticBonds ? unit.resonance.delocalizedTriplets : void 0;
  return {
    linkCount: edgeCount * 2,
    referencePosition: (edgeIndex) => {
      let aI = a4[edgeIndex], bI = b4[edgeIndex];
      const rI = deloTriplets === null || deloTriplets === void 0 ? void 0 : deloTriplets.getThirdElement(aI, bI);
      if (rI !== void 0)
        return c4.invariantPosition(elements[rI], vRef);
      if (aI > bI)
        [aI, bI] = [bI, aI];
      if (offset[aI + 1] - offset[aI] === 1)
        [aI, bI] = [bI, aI];
      const aR = elementAromaticRingIndices.get(aI) || elementRingIndices.get(aI);
      let maxSize = 0;
      for (let i = offset[aI], il = offset[aI + 1]; i < il; ++i) {
        const _bI = b4[i];
        if (_bI !== bI && _bI !== aI) {
          if (aR) {
            const _bR = elementAromaticRingIndices.get(_bI) || elementRingIndices.get(_bI);
            if (!_bR)
              continue;
            const size = arrayIntersectionSize(aR, _bR);
            if (size > maxSize) {
              maxSize = size;
              c4.invariantPosition(elements[_bI], vRef);
            }
          } else {
            return c4.invariantPosition(elements[_bI], vRef);
          }
        }
      }
      return maxSize > 0 ? vRef : null;
    },
    position: (posA, posB, edgeIndex, adjust) => {
      c4.invariantPosition(elements[a4[edgeIndex]], posA);
      c4.invariantPosition(elements[b4[edgeIndex]], posB);
      if (adjust && adjustCylinderLength) {
        const rA = radiusA(edgeIndex), rB = radiusB(edgeIndex);
        const r = Math.min(rA, rB) * sizeAspectRatio;
        const oA = Math.sqrt(Math.max(0, rA * rA - r * r)) - 0.05;
        const oB = Math.sqrt(Math.max(0, rB * rB - r * r)) - 0.05;
        if (oA <= 0.01 && oB <= 0.01)
          return;
        Vec3.normalize(delta, Vec3.sub(delta, posB, posA));
        Vec3.scaleAndAdd(posA, posA, delta, oA);
        Vec3.scaleAndAdd(posB, posB, delta, -oB);
      }
    },
    style: (edgeIndex) => {
      const o = _order[edgeIndex];
      const f = _flags[edgeIndex];
      if (isBondType(f, BondType.Flag.MetallicCoordination) || isBondType(f, BondType.Flag.HydrogenBond)) {
        return LinkStyle.Dashed;
      } else if (o === 3) {
        return mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Triple : LinkStyle.OffsetTriple;
      } else if (aromaticBonds) {
        const aI = a4[edgeIndex], bI = b4[edgeIndex];
        const aR = elementAromaticRingIndices.get(aI);
        const bR = elementAromaticRingIndices.get(bI);
        const arCount = aR && bR ? arrayIntersectionSize(aR, bR) : 0;
        if (isBondType(f, BondType.Flag.Aromatic) || arCount && !ignoreComputedAromatic) {
          if (arCount === 2) {
            return LinkStyle.MirroredAromatic;
          } else {
            return LinkStyle.Aromatic;
          }
        }
      }
      return o !== 2 || mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Double : LinkStyle.OffsetDouble;
    },
    radius: (edgeIndex) => {
      return radius(edgeIndex) * sizeAspectRatio;
    },
    ignore: makeIntraBondIgnoreTest(structure, unit, props),
    stub
  };
}
function createIntraUnitBondCylinderImpostors(ctx, unit, structure, theme, props, cylinders) {
  if (!Unit.isAtomic(unit))
    return Cylinders.createEmpty(cylinders);
  if (!hasUnitVisibleBonds(unit, props))
    return Cylinders.createEmpty(cylinders);
  if (!unit.bonds.edgeCount)
    return Cylinders.createEmpty(cylinders);
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Cylinders.createEmpty(cylinders);
  const builderProps = getIntraUnitBondCylinderBuilderProps(unit, structure, theme, props);
  const { cylinders: c4, boundingSphere } = createLinkCylinderImpostors(ctx, builderProps, props, cylinders);
  if (boundingSphere) {
    c4.setBoundingSphere(boundingSphere);
  } else if (c4.cylinderCount > 0) {
    const sphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, 1 * props.sizeFactor);
    c4.setBoundingSphere(sphere);
  }
  return c4;
}
function createIntraUnitBondCylinderMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  if (!hasUnitVisibleBonds(unit, props))
    return Mesh.createEmpty(mesh);
  if (!unit.bonds.edgeCount)
    return Mesh.createEmpty(mesh);
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Mesh.createEmpty(mesh);
  const builderProps = getIntraUnitBondCylinderBuilderProps(unit, structure, theme, props);
  const { mesh: m, boundingSphere } = createLinkCylinderMesh(ctx, builderProps, props, mesh);
  if (boundingSphere) {
    m.setBoundingSphere(boundingSphere);
  } else if (m.triangleCount > 0) {
    const sphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, 1 * props.sizeFactor);
    m.setBoundingSphere(sphere);
  }
  return m;
}
var IntraUnitBondCylinderParams = {
  ...UnitsMeshParams,
  ...UnitsCylindersParams,
  ...BondCylinderParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  sizeAspectRatio: ParamDefinition.Numeric(2 / 3, { min: 0, max: 3, step: 0.01 }),
  tryUseImpostor: ParamDefinition.Boolean(true),
  includeParent: ParamDefinition.Boolean(false)
};
function IntraUnitBondCylinderVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? IntraUnitBondCylinderImpostorVisual(materialId) : IntraUnitBondCylinderMeshVisual(materialId);
}
function IntraUnitBondCylinderImpostorVisual(materialId) {
  return UnitsCylindersVisual({
    defaultProps: ParamDefinition.getDefaultValues(IntraUnitBondCylinderParams),
    createGeometry: createIntraUnitBondCylinderImpostors,
    createLocationIterator: (structureGroup, props) => BondIterator.fromGroup(structureGroup, { includeLocation2: props.colorMode === "interpolate" }),
    getLoci: getIntraBondLoci,
    eachLocation: eachIntraBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.aromaticBonds !== currentProps.aromaticBonds || newProps.multipleBonds !== currentProps.multipleBonds || newProps.adjustCylinderLength && !SizeTheme.areEqual(newTheme.size, currentTheme.size);
      if (newProps.colorMode !== currentProps.colorMode) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
      }
      const newUnit = newStructureGroup.group.units[0];
      const currentUnit = currentStructureGroup.group.units[0];
      if (Unit.isAtomic(newUnit) && Unit.isAtomic(currentUnit)) {
        if (!IntAdjacencyGraph.areEqual(newUnit.bonds, currentUnit.bonds)) {
          state.createGeometry = true;
          state.updateTransform = true;
          state.updateColor = true;
          state.updateSize = true;
        }
      }
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function IntraUnitBondCylinderMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(IntraUnitBondCylinderParams),
    createGeometry: createIntraUnitBondCylinderMesh,
    createLocationIterator: (structureGroup) => BondIterator.fromGroup(structureGroup),
    getLoci: getIntraBondLoci,
    eachLocation: eachIntraBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.radialSegments !== currentProps.radialSegments || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.aromaticBonds !== currentProps.aromaticBonds || newProps.multipleBonds !== currentProps.multipleBonds;
      const newUnit = newStructureGroup.group.units[0];
      const currentUnit = currentStructureGroup.group.units[0];
      if (Unit.isAtomic(newUnit) && Unit.isAtomic(currentUnit)) {
        if (!IntAdjacencyGraph.areEqual(newUnit.bonds, currentUnit.bonds)) {
          state.createGeometry = true;
          state.updateTransform = true;
          state.updateColor = true;
          state.updateSize = true;
        }
      }
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}
function getStructureIntraUnitBondCylinderBuilderProps(structure, theme, props) {
  const intraUnitProps = [];
  const { bondCount: bondCount2, unitIndex, unitEdgeIndex, unitGroupIndex } = structure.intraUnitBondMapping;
  const { child } = structure;
  for (const ug of structure.unitSymmetryGroups) {
    const unit = ug.units[0];
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    const p = Unit.isAtomic(unit) && !(child && !childUnit) ? getIntraUnitBondCylinderBuilderProps(unit, structure, theme, props) : EmptyLinkBuilderProps;
    intraUnitProps.push({ group: ug, props: p });
  }
  return {
    linkCount: bondCount2,
    referencePosition: (edgeIndex) => {
      const { group, props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      if (!props2.referencePosition)
        return null;
      const v2 = props2.referencePosition(unitEdgeIndex[edgeIndex]);
      if (!v2)
        return null;
      const u2 = group.units[unitGroupIndex[edgeIndex]];
      Vec3.transformMat4(v2, v2, u2.conformation.operator.matrix);
      return v2;
    },
    position: (posA, posB, edgeIndex, adjust) => {
      const { group, props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      props2.position(posA, posB, unitEdgeIndex[edgeIndex], adjust);
      const u2 = group.units[unitGroupIndex[edgeIndex]];
      Vec3.transformMat4(posA, posA, u2.conformation.operator.matrix);
      Vec3.transformMat4(posB, posB, u2.conformation.operator.matrix);
    },
    style: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.style ? props2.style(unitEdgeIndex[edgeIndex]) : LinkStyle.Solid;
    },
    radius: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.radius(unitEdgeIndex[edgeIndex]);
    },
    ignore: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.ignore ? props2.ignore(unitEdgeIndex[edgeIndex]) : false;
    },
    stub: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.stub ? props2.stub(unitEdgeIndex[edgeIndex]) : false;
    }
  };
}
function createStructureIntraUnitBondCylinderImpostors(ctx, structure, theme, props, cylinders) {
  if (!hasStructureVisibleBonds(structure, props))
    return Cylinders.createEmpty(cylinders);
  if (!structure.intraUnitBondMapping.bondCount)
    return Cylinders.createEmpty(cylinders);
  const builderProps = getStructureIntraUnitBondCylinderBuilderProps(structure, theme, props);
  const { cylinders: c4, boundingSphere } = createLinkCylinderImpostors(ctx, builderProps, props, cylinders);
  if (boundingSphere) {
    c4.setBoundingSphere(boundingSphere);
  } else if (c4.cylinderCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    c4.setBoundingSphere(sphere);
  }
  return c4;
}
function createStructureIntraUnitBondCylinderMesh(ctx, structure, theme, props, mesh) {
  if (!hasStructureVisibleBonds(structure, props))
    return Mesh.createEmpty(mesh);
  if (!structure.intraUnitBondMapping.bondCount)
    return Mesh.createEmpty(mesh);
  const builderProps = getStructureIntraUnitBondCylinderBuilderProps(structure, theme, props);
  const { mesh: m, boundingSphere } = createLinkCylinderMesh(ctx, builderProps, props, mesh);
  if (boundingSphere) {
    m.setBoundingSphere(boundingSphere);
  } else if (m.triangleCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    m.setBoundingSphere(sphere);
  }
  return m;
}
var StructureIntraUnitBondCylinderParams = {
  ...ComplexMeshParams,
  ...ComplexCylindersParams,
  ...BondCylinderParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  sizeAspectRatio: ParamDefinition.Numeric(2 / 3, { min: 0, max: 3, step: 0.01 }),
  tryUseImpostor: ParamDefinition.Boolean(true),
  includeParent: ParamDefinition.Boolean(false)
};
function StructureIntraUnitBondCylinderVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? StructureIntraUnitBondCylinderImpostorVisual(materialId) : StructureIntraUnitBondCylinderMeshVisual(materialId);
}
function StructureIntraUnitBondCylinderImpostorVisual(materialId) {
  return ComplexCylindersVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureIntraUnitBondCylinderParams),
    createGeometry: createStructureIntraUnitBondCylinderImpostors,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructureGroups(structure, { includeLocation2: props.colorMode === "interpolate" });
    },
    getLoci: getStructureGroupsBondLoci,
    eachLocation: eachStructureGroupsBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.multipleBonds !== currentProps.multipleBonds;
      if (newProps.colorMode !== currentProps.colorMode) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
      }
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function StructureIntraUnitBondCylinderMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureIntraUnitBondCylinderParams),
    createGeometry: createStructureIntraUnitBondCylinderMesh,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructureGroups(structure);
    },
    getLoci: getStructureGroupsBondLoci,
    eachLocation: eachStructureGroupsBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.radialSegments !== currentProps.radialSegments || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.multipleBonds !== currentProps.multipleBonds || newProps.adjustCylinderLength && !SizeTheme.areEqual(newTheme.size, currentTheme.size);
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/bond-inter-unit-cylinder.js
var tmpRefPosBondIt = new Bond.ElementBondIterator();
function setRefPosition(pos, structure, unit, index2) {
  tmpRefPosBondIt.setElement(structure, unit, index2);
  while (tmpRefPosBondIt.hasNext) {
    const bA = tmpRefPosBondIt.move();
    bA.otherUnit.conformation.position(bA.otherUnit.elements[bA.otherIndex], pos);
    return pos;
  }
  return null;
}
var tmpRef = Vec3();
function getInterUnitBondCylinderBuilderProps(structure, theme, props) {
  const locE = element_exports.Location.create(structure);
  const locB = Bond.Location(structure, void 0, void 0, structure, void 0, void 0);
  const bonds = structure.interUnitBonds;
  const { edgeCount, edges } = bonds;
  const { sizeFactor, sizeAspectRatio, adjustCylinderLength, aromaticBonds, multipleBonds } = props;
  const mbOff = multipleBonds === "off";
  const mbSymmetric = multipleBonds === "symmetric";
  const delta = Vec3();
  let stub;
  const { child } = structure;
  if (props.includeParent && child) {
    stub = (edgeIndex) => {
      const b4 = edges[edgeIndex];
      const childUnitA = child.unitMap.get(b4.unitA);
      const childUnitB = child.unitMap.get(b4.unitB);
      const unitA = structure.unitMap.get(b4.unitA);
      const eA = unitA.elements[b4.indexA];
      const unitB = structure.unitMap.get(b4.unitB);
      const eB = unitB.elements[b4.indexB];
      return childUnitA && SortedArray.has(childUnitA.elements, eA) && (!childUnitB || !SortedArray.has(childUnitB.elements, eB));
    };
  }
  const radius = (edgeIndex) => {
    const b4 = edges[edgeIndex];
    locB.aUnit = structure.unitMap.get(b4.unitA);
    locB.aIndex = b4.indexA;
    locB.bUnit = structure.unitMap.get(b4.unitB);
    locB.bIndex = b4.indexB;
    return theme.size.size(locB) * sizeFactor;
  };
  const radiusA = (edgeIndex) => {
    const b4 = edges[edgeIndex];
    locE.unit = structure.unitMap.get(b4.unitA);
    locE.element = locE.unit.elements[b4.indexA];
    return theme.size.size(locE) * sizeFactor;
  };
  const radiusB = (edgeIndex) => {
    const b4 = edges[edgeIndex];
    locE.unit = structure.unitMap.get(b4.unitB);
    locE.element = locE.unit.elements[b4.indexB];
    return theme.size.size(locE) * sizeFactor;
  };
  return {
    linkCount: edgeCount,
    referencePosition: (edgeIndex) => {
      const b4 = edges[edgeIndex];
      let unitA, unitB;
      let indexA, indexB;
      if (b4.unitA < b4.unitB) {
        unitA = structure.unitMap.get(b4.unitA);
        unitB = structure.unitMap.get(b4.unitB);
        indexA = b4.indexA;
        indexB = b4.indexB;
      } else if (b4.unitA > b4.unitB) {
        unitA = structure.unitMap.get(b4.unitB);
        unitB = structure.unitMap.get(b4.unitA);
        indexA = b4.indexB;
        indexB = b4.indexA;
      } else {
        throw new Error("same units in createInterUnitBondCylinderMesh");
      }
      return setRefPosition(tmpRef, structure, unitA, indexA) || setRefPosition(tmpRef, structure, unitB, indexB);
    },
    position: (posA, posB, edgeIndex, adjust) => {
      const b4 = edges[edgeIndex];
      const uA = structure.unitMap.get(b4.unitA);
      const uB = structure.unitMap.get(b4.unitB);
      uA.conformation.position(uA.elements[b4.indexA], posA);
      uB.conformation.position(uB.elements[b4.indexB], posB);
      if (adjust && adjustCylinderLength) {
        const rA = radiusA(edgeIndex), rB = radiusB(edgeIndex);
        const r = Math.min(rA, rB) * sizeAspectRatio;
        const oA = Math.sqrt(Math.max(0, rA * rA - r * r)) - 0.05;
        const oB = Math.sqrt(Math.max(0, rB * rB - r * r)) - 0.05;
        if (oA <= 0.01 && oB <= 0.01)
          return;
        Vec3.normalize(delta, Vec3.sub(delta, posB, posA));
        Vec3.scaleAndAdd(posA, posA, delta, oA);
        Vec3.scaleAndAdd(posB, posB, delta, -oB);
      }
    },
    style: (edgeIndex) => {
      const o = edges[edgeIndex].props.order;
      const f = BitFlags.create(edges[edgeIndex].props.flag);
      if (BondType.is(f, BondType.Flag.MetallicCoordination) || BondType.is(f, BondType.Flag.HydrogenBond)) {
        return LinkStyle.Dashed;
      } else if (o === 3) {
        return mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Triple : LinkStyle.OffsetTriple;
      } else if (aromaticBonds && BondType.is(f, BondType.Flag.Aromatic)) {
        return LinkStyle.Aromatic;
      }
      return o !== 2 || mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Double : LinkStyle.OffsetDouble;
    },
    radius: (edgeIndex) => {
      return radius(edgeIndex) * sizeAspectRatio;
    },
    ignore: makeInterBondIgnoreTest(structure, props),
    stub
  };
}
function createInterUnitBondCylinderImpostors(ctx, structure, theme, props, cylinders) {
  if (!hasStructureVisibleBonds(structure, props))
    return Cylinders.createEmpty(cylinders);
  if (!structure.interUnitBonds.edgeCount)
    return Cylinders.createEmpty(cylinders);
  const builderProps = getInterUnitBondCylinderBuilderProps(structure, theme, props);
  const { cylinders: c4, boundingSphere } = createLinkCylinderImpostors(ctx, builderProps, props, cylinders);
  if (boundingSphere) {
    c4.setBoundingSphere(boundingSphere);
  } else if (c4.cylinderCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    c4.setBoundingSphere(sphere);
  }
  return c4;
}
function createInterUnitBondCylinderMesh(ctx, structure, theme, props, mesh) {
  if (!hasStructureVisibleBonds(structure, props))
    return Mesh.createEmpty(mesh);
  if (!structure.interUnitBonds.edgeCount)
    return Mesh.createEmpty(mesh);
  const builderProps = getInterUnitBondCylinderBuilderProps(structure, theme, props);
  const { mesh: m, boundingSphere } = createLinkCylinderMesh(ctx, builderProps, props, mesh);
  if (boundingSphere) {
    m.setBoundingSphere(boundingSphere);
  } else if (m.triangleCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    m.setBoundingSphere(sphere);
  }
  return m;
}
var InterUnitBondCylinderParams = {
  ...ComplexMeshParams,
  ...ComplexCylindersParams,
  ...BondCylinderParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  sizeAspectRatio: ParamDefinition.Numeric(2 / 3, { min: 0, max: 3, step: 0.01 }),
  tryUseImpostor: ParamDefinition.Boolean(true),
  includeParent: ParamDefinition.Boolean(false)
};
function InterUnitBondCylinderVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? InterUnitBondCylinderImpostorVisual(materialId) : InterUnitBondCylinderMeshVisual(materialId);
}
function InterUnitBondCylinderImpostorVisual(materialId) {
  return ComplexCylindersVisual({
    defaultProps: ParamDefinition.getDefaultValues(InterUnitBondCylinderParams),
    createGeometry: createInterUnitBondCylinderImpostors,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructure(structure, { includeLocation2: props.colorMode === "interpolate" });
    },
    getLoci: getInterBondLoci,
    eachLocation: eachInterBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.multipleBonds !== currentProps.multipleBonds;
      if (newProps.colorMode !== currentProps.colorMode) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
      }
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function InterUnitBondCylinderMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(InterUnitBondCylinderParams),
    createGeometry: createInterUnitBondCylinderMesh,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructure(structure);
    },
    getLoci: getInterBondLoci,
    eachLocation: eachInterBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.sizeAspectRatio !== currentProps.sizeAspectRatio || newProps.radialSegments !== currentProps.radialSegments || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.linkCap !== currentProps.linkCap || newProps.aromaticScale !== currentProps.aromaticScale || newProps.aromaticSpacing !== currentProps.aromaticSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.dashScale !== currentProps.dashScale || newProps.dashCap !== currentProps.dashCap || newProps.stubCap !== currentProps.stubCap || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.adjustCylinderLength !== currentProps.adjustCylinderLength || newProps.multipleBonds !== currentProps.multipleBonds || newProps.adjustCylinderLength && !SizeTheme.areEqual(newTheme.size, currentTheme.size);
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/element.js
var v3add = Vec3.add;
function makeElementIgnoreTest(structure, unit, props) {
  const { ignoreHydrogens, ignoreHydrogensVariant, traceOnly } = props;
  const isCoarse = Unit.isCoarse(unit);
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    throw new Error("expected childUnit to exist if child exists");
  if (!child && !ignoreHydrogens && !traceOnly)
    return;
  return (element3) => {
    return !!childUnit && !SortedArray.has(childUnit.elements, element3) || !isCoarse && ignoreHydrogens && isHydrogen(structure, unit, element3, ignoreHydrogensVariant) || traceOnly && !isTrace(unit, element3);
  };
}
function createElementSphereMesh(ctx, unit, structure, theme, props, mesh) {
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Mesh.createEmpty(mesh);
  const { detail, sizeFactor, stride } = props;
  const { elements, conformation: c4 } = unit;
  const elementCount = elements.length;
  const vertexCount = elementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const v2 = Vec3();
  const ignore2 = makeElementIgnoreTest(structure, unit, props);
  const l = element_exports.Location.create(structure, unit);
  const themeSize = theme.size.size;
  const center2 = Vec3();
  let maxSize = 0;
  let count2 = 0;
  for (let i = 0; i < elementCount; i++) {
    if (stride && i % stride !== 0)
      continue;
    if (ignore2 && ignore2(elements[i]))
      continue;
    c4.invariantPosition(elements[i], v2);
    v3add(center2, center2, v2);
    count2 += 1;
    l.element = elements[i];
    const size = themeSize(l);
    if (size > maxSize)
      maxSize = size;
    builderState.currentGroup = i;
    addSphere(builderState, v2, size * sizeFactor, detail);
  }
  const m = MeshBuilder.getMesh(builderState);
  if (count2 === 0)
    return m;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, maxSize * sizeFactor + 0.05);
  }
  m.setBoundingSphere(boundingSphere);
  return m;
}
function createElementSphereImpostor(ctx, unit, structure, theme, props, spheres) {
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Spheres.createEmpty(spheres);
  const { sizeFactor, stride } = props;
  const { elements, conformation: c4 } = unit;
  const elementCount = elements.length;
  const builder = SpheresBuilder.create(elementCount, elementCount / 2, spheres);
  const v2 = Vec3();
  const ignore2 = makeElementIgnoreTest(structure, unit, props);
  const l = element_exports.Location.create(structure, unit);
  const themeSize = theme.size.size;
  const center2 = Vec3();
  let maxSize = 0;
  let count2 = 0;
  if (stride && stride > 1 || ignore2 || theme.size.granularity !== "uniform") {
    for (let i = 0; i < elementCount; i++) {
      if (stride && i % stride !== 0)
        continue;
      if (ignore2 && ignore2(elements[i]))
        continue;
      c4.invariantPosition(elements[i], v2);
      builder.add(v2[0], v2[1], v2[2], i);
      v3add(center2, center2, v2);
      count2 += 1;
      l.element = elements[i];
      const size = themeSize(l);
      if (size > maxSize)
        maxSize = size;
    }
  } else {
    for (let i = 0; i < elementCount; i++) {
      c4.invariantPosition(elements[i], v2);
      builder.add(v2[0], v2[1], v2[2], i);
      v3add(center2, center2, v2);
    }
    count2 = elementCount;
    maxSize = themeSize(l);
  }
  const s = builder.getSpheres();
  if (count2 === 0)
    return s;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = spheres ? Sphere3D.clone(spheres.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, maxSize * sizeFactor + 0.05);
  }
  s.setBoundingSphere(boundingSphere);
  return s;
}
function eachElement(loci, structureGroup, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  const { structure, group } = structureGroup;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const elementCount = group.elements.length;
  const { unitIndexMap } = group;
  for (const e of loci.elements) {
    const unitIdx = unitIndexMap.get(e.unit.id);
    if (unitIdx !== void 0) {
      const offset = unitIdx * elementCount;
      if (Interval.is(e.indices)) {
        const start2 = offset + Interval.start(e.indices);
        const end = offset + Interval.end(e.indices);
        if (apply(Interval.ofBounds(start2, end)))
          changed = true;
      } else {
        for (let i = 0, _i = e.indices.length; i < _i; i++) {
          const start2 = e.indices[i];
          let endI = i + 1;
          while (endI < _i && e.indices[endI] === start2)
            endI++;
          i = endI - 1;
          const end = e.indices[i];
          changed = apply(Interval.ofRange(offset + start2, offset + end)) || changed;
        }
      }
    }
  }
  return changed;
}
function getElementLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId, groupId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    const indices = OrderedSet.ofSingleton(groupId);
    return element_exports.Loci(structure.target, [{ unit, indices }]);
  }
  return EmptyLoci;
}
function createStructureElementSphereMesh(ctx, structure, theme, props, mesh) {
  const { child } = structure;
  const { detail, sizeFactor, stride } = props;
  const { getSerialIndex } = structure.serialMapping;
  const structureElementCount = structure.elementCount;
  const vertexCount = structureElementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const themeSize = theme.size.size;
  const center2 = Vec3();
  let maxSize = 0;
  let count2 = 0;
  for (const unit of structure.units) {
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
      continue;
    const { elements, conformation: c4 } = unit;
    const elementCount = elements.length;
    const v2 = Vec3();
    const ignore2 = makeElementIgnoreTest(structure, unit, props);
    const l = element_exports.Location.create(structure, unit);
    for (let i = 0; i < elementCount; i++) {
      const eI = elements[i];
      if (stride && i % stride !== 0)
        continue;
      if (ignore2 && ignore2(eI))
        continue;
      c4.position(eI, v2);
      v3add(center2, center2, v2);
      count2 += 1;
      l.element = eI;
      const size = themeSize(l);
      if (size > maxSize)
        maxSize = size;
      builderState.currentGroup = getSerialIndex(unit, eI);
      addSphere(builderState, v2, size * sizeFactor, detail);
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  if (count2 === 0)
    return m;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, maxSize * sizeFactor + 0.05);
  }
  m.setBoundingSphere(boundingSphere);
  return m;
}
function createStructureElementSphereImpostor(ctx, structure, theme, props, spheres) {
  const { child } = structure;
  const { sizeFactor, stride } = props;
  const { getSerialIndex } = structure.serialMapping;
  const structureElementCount = structure.elementCount;
  const builder = SpheresBuilder.create(structureElementCount, structureElementCount / 2, spheres);
  const themeSize = theme.size.size;
  const center2 = Vec3();
  let maxSize = 0;
  let count2 = 0;
  for (const unit of structure.units) {
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
      continue;
    const { elements, conformation: c4 } = unit;
    const elementCount = elements.length;
    const v2 = Vec3();
    const ignore2 = makeElementIgnoreTest(structure, unit, props);
    const l = element_exports.Location.create(structure, unit);
    if (stride && stride > 1 || ignore2 || theme.size.granularity !== "uniform") {
      for (let i = 0; i < elementCount; i++) {
        const eI = elements[i];
        if (stride && i % stride !== 0)
          continue;
        if (ignore2 && ignore2(eI))
          continue;
        c4.position(eI, v2);
        builder.add(v2[0], v2[1], v2[2], getSerialIndex(unit, eI));
        v3add(center2, center2, v2);
        count2 += 1;
        l.element = eI;
        const size = themeSize(l);
        if (size > maxSize)
          maxSize = size;
      }
    } else {
      for (let i = 0; i < elementCount; i++) {
        const eI = elements[i];
        c4.position(eI, v2);
        builder.add(v2[0], v2[1], v2[2], getSerialIndex(unit, eI));
        v3add(center2, center2, v2);
      }
      count2 += elementCount;
      maxSize = themeSize(l);
    }
  }
  const s = builder.getSpheres();
  if (count2 === 0)
    return s;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = spheres ? Sphere3D.clone(spheres.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, maxSize * sizeFactor + 0.05);
  }
  s.setBoundingSphere(boundingSphere);
  return s;
}
function eachSerialElement(loci, structure, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const { cumulativeUnitElementCount } = structure.serialMapping;
  for (const e of loci.elements) {
    const unitIdx = structure.unitIndexMap.get(e.unit.id);
    if (unitIdx !== void 0) {
      if (Interval.is(e.indices)) {
        const start2 = cumulativeUnitElementCount[unitIdx] + Interval.start(e.indices);
        const end = cumulativeUnitElementCount[unitIdx] + Interval.end(e.indices);
        if (apply(Interval.ofBounds(start2, end)))
          changed = true;
      } else {
        for (let i = 0, _i = e.indices.length; i < _i; i++) {
          const idx = cumulativeUnitElementCount[unitIdx] + e.indices[i];
          if (apply(Interval.ofSingleton(idx)))
            changed = true;
        }
      }
    }
  }
  return changed;
}
function getSerialElementLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const { unitIndices, cumulativeUnitElementCount } = structure.serialMapping;
    const unitIdx = unitIndices[groupId];
    const unit = structure.units[unitIdx];
    const idx = groupId - cumulativeUnitElementCount[unitIdx];
    const indices = OrderedSet.ofSingleton(idx);
    return element_exports.Loci(structure, [{ unit, indices }]);
  }
  return EmptyLoci;
}
var ElementIterator;
(function(ElementIterator2) {
  function fromGroup(structureGroup) {
    const { group, structure } = structureGroup;
    const groupCount = group.elements.length;
    const instanceCount = group.units.length;
    const location = element_exports.Location.create(structure);
    const getLocation = (groupIndex, instanceIndex) => {
      const unit = group.units[instanceIndex];
      location.unit = unit;
      location.element = unit.elements[groupIndex];
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  ElementIterator2.fromGroup = fromGroup;
  function fromStructure(structure) {
    const { units, elementCount } = structure;
    const groupCount = elementCount;
    const instanceCount = 1;
    const { unitIndices, elementIndices } = structure.serialMapping;
    const location = element_exports.Location.create(structure);
    const getLocation = (groupIndex) => {
      location.unit = units[unitIndices[groupIndex]];
      location.element = elementIndices[groupIndex];
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation, true);
  }
  ElementIterator2.fromStructure = fromStructure;
})(ElementIterator || (ElementIterator = {}));

// node_modules/molstar/lib/mol-repr/structure/visual/element-sphere.js
var CommonElementSphereParams = {
  sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false),
  tryUseImpostor: ParamDefinition.Boolean(true),
  stride: ParamDefinition.Numeric(1, { min: 1, max: 100, step: 1 })
};
var ElementSphereParams = {
  ...UnitsMeshParams,
  ...UnitsSpheresParams,
  ...CommonElementSphereParams
};
function ElementSphereVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth && webgl.extensions.textureFloat ? ElementSphereImpostorVisual(materialId) : ElementSphereMeshVisual(materialId);
}
function ElementSphereImpostorVisual(materialId) {
  return UnitsSpheresVisual({
    defaultProps: ParamDefinition.getDefaultValues(ElementSphereParams),
    createGeometry: createElementSphereImpostor,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function ElementSphereMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(ElementSphereParams),
    createGeometry: createElementSphereMesh,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}
var StructureElementSphereParams = {
  ...ComplexMeshParams,
  ...ComplexSpheresParams,
  ...CommonElementSphereParams
};
function StructureElementSphereVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth && webgl.extensions.textureFloat ? StructureElementSphereImpostorVisual(materialId) : StructureElementSphereMeshVisual(materialId);
}
function StructureElementSphereImpostorVisual(materialId) {
  return ComplexSpheresVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureElementSphereParams),
    createGeometry: createStructureElementSphereImpostor,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    },
    mustRecreate: (structure, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function StructureElementSphereMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureElementSphereParams),
    createGeometry: createStructureElementSphereMesh,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    },
    mustRecreate: (structure, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/ball-and-stick.js
var BallAndStickVisuals = {
  "element-sphere": (ctx, getParams) => UnitsRepresentation("Element sphere", ctx, getParams, ElementSphereVisual),
  "intra-bond": (ctx, getParams) => UnitsRepresentation("Intra-unit bond cylinder", ctx, getParams, IntraUnitBondCylinderVisual),
  "inter-bond": (ctx, getParams) => ComplexRepresentation("Inter-unit bond cylinder", ctx, getParams, InterUnitBondCylinderVisual),
  "structure-element-sphere": (ctx, getParams) => ComplexRepresentation("Structure element sphere", ctx, getParams, StructureElementSphereVisual),
  "structure-intra-bond": (ctx, getParams) => ComplexRepresentation("Structure intra-unit bond cylinder", ctx, getParams, StructureIntraUnitBondCylinderVisual)
};
var BallAndStickParams = {
  ...ElementSphereParams,
  traceOnly: ParamDefinition.Boolean(false, { isHidden: true }),
  // not useful here
  ...IntraUnitBondCylinderParams,
  ...InterUnitBondCylinderParams,
  includeParent: ParamDefinition.Boolean(false),
  unitKinds: getUnitKindsParam(["atomic"]),
  sizeFactor: ParamDefinition.Numeric(0.15, { min: 0.01, max: 10, step: 0.01 }),
  sizeAspectRatio: ParamDefinition.Numeric(2 / 3, { min: 0.01, max: 3, step: 0.01 }),
  visuals: ParamDefinition.MultiSelect(["element-sphere", "intra-bond", "inter-bond"], ParamDefinition.objectToOptions(BallAndStickVisuals)),
  bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getBallAndStickParams(ctx, structure) {
  let params = BallAndStickParams;
  const size = Structure.getSize(structure);
  if (size >= Structure.Size.Huge) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["element-sphere", "intra-bond"];
  } else if (structure.unitSymmetryGroups.length > 5e3) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["structure-element-sphere", "structure-intra-bond"];
  }
  return params;
}
function BallAndStickRepresentation(ctx, getParams) {
  return Representation.createMulti("Ball & Stick", ctx, getParams, StructureRepresentationStateBuilder, BallAndStickVisuals);
}
var BallAndStickRepresentationProvider = StructureRepresentationProvider({
  name: "ball-and-stick",
  label: "Ball & Stick",
  description: "Displays atoms as spheres and bonds as cylinders.",
  factory: BallAndStickRepresentation,
  getParams: getBallAndStickParams,
  defaultValues: ParamDefinition.getDefaultValues(BallAndStickParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0,
  getData: (structure, props) => {
    return props.includeParent ? structure.asParent() : structure;
  },
  mustRecreate: (oldProps, newProps) => {
    return oldProps.includeParent !== newProps.includeParent;
  }
});

// node_modules/molstar/lib/mol-repr/structure/visual/carbohydrate-link-cylinder.js
function createCarbohydrateLinkCylinderMesh(ctx, structure, theme, props, mesh) {
  const { links, elements } = structure.carbohydrates;
  const { linkSizeFactor } = props;
  const location = element_exports.Location.create(structure);
  const builderProps = {
    linkCount: links.length,
    position: (posA, posB, edgeIndex) => {
      const l = links[edgeIndex];
      Vec3.copy(posA, elements[l.carbohydrateIndexA].geometry.center);
      Vec3.copy(posB, elements[l.carbohydrateIndexB].geometry.center);
    },
    radius: (edgeIndex) => {
      const l = links[edgeIndex];
      const carbA = elements[l.carbohydrateIndexA];
      const ringA = carbA.unit.rings.all[carbA.ringIndex];
      location.unit = carbA.unit;
      location.element = carbA.unit.elements[ringA[0]];
      return theme.size.size(location) * linkSizeFactor;
    }
  };
  const { mesh: m, boundingSphere } = createLinkCylinderMesh(ctx, builderProps, props, mesh);
  if (boundingSphere) {
    m.setBoundingSphere(boundingSphere);
  } else if (m.triangleCount > 0) {
    const sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, 1 * linkSizeFactor);
    m.setBoundingSphere(sphere);
  }
  return m;
}
var CarbohydrateLinkParams = {
  ...UnitsMeshParams,
  ...LinkCylinderParams,
  linkSizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 3, step: 0.01 })
};
function CarbohydrateLinkVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(CarbohydrateLinkParams),
    createGeometry: createCarbohydrateLinkCylinderMesh,
    createLocationIterator: CarbohydrateLinkIterator,
    getLoci: getLinkLoci,
    eachLocation: eachCarbohydrateLink,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.linkSizeFactor !== currentProps.linkSizeFactor || newProps.radialSegments !== currentProps.radialSegments || newProps.linkCap !== currentProps.linkCap;
    }
  }, materialId);
}
function CarbohydrateLinkIterator(structure) {
  const { elements, links } = structure.carbohydrates;
  const groupCount = links.length;
  const instanceCount = 1;
  const location = element_exports.Location.create(structure);
  const getLocation = (groupIndex) => {
    const link2 = links[groupIndex];
    const carbA = elements[link2.carbohydrateIndexA];
    const ringA = carbA.unit.rings.all[carbA.ringIndex];
    location.unit = carbA.unit;
    location.element = carbA.unit.elements[ringA[0]];
    return location;
  };
  return LocationIterator(groupCount, instanceCount, 1, getLocation, true);
}
function getLinkLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const { links, elements } = structure.carbohydrates;
    const l = links[groupId];
    const carbA = elements[l.carbohydrateIndexA];
    const carbB = elements[l.carbohydrateIndexB];
    return element_exports.Loci.union(getAltResidueLociFromId(structure, carbA.unit, carbA.residueIndex, carbA.altId), getAltResidueLociFromId(structure, carbB.unit, carbB.residueIndex, carbB.altId));
  }
  return EmptyLoci;
}
var __linkIndicesSet = /* @__PURE__ */ new Set();
function eachCarbohydrateLink(loci, structure, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const { getLinkIndices } = structure.carbohydrates;
  for (const { unit, indices } of loci.elements) {
    if (!Unit.isAtomic(unit))
      continue;
    __linkIndicesSet.clear();
    OrderedSet.forEach(indices, (v2) => {
      const linkIndices = getLinkIndices(unit, unit.elements[v2]);
      for (let i = 0, il = linkIndices.length; i < il; ++i) {
        if (!__linkIndicesSet.has(linkIndices[i])) {
          __linkIndicesSet.add(linkIndices[i]);
          if (apply(Interval.ofSingleton(linkIndices[i])))
            changed = true;
        }
      }
    });
  }
  return changed;
}

// node_modules/molstar/lib/mol-geo/primitive/pyramid.js
var on = Vec3.create(0, 0, -0.5);
var op = Vec3.create(0, 0, 0.5);
var a = Vec3();
var b = Vec3();
var c = Vec3();
var d = Vec3();
function Pyramid(points2) {
  const sideCount = points2.length / 3;
  const baseCount = sideCount === 3 ? 1 : sideCount === 4 ? 2 : sideCount;
  const triangleCount = baseCount + sideCount;
  const vertexCount = sideCount === 4 ? sideCount * 3 + 4 : triangleCount * 3;
  const builder = PrimitiveBuilder(triangleCount, vertexCount);
  for (let i = 0; i < sideCount; ++i) {
    const ni = (i + 1) % sideCount;
    Vec3.set(a, points2[i * 3], points2[i * 3 + 1], -0.5);
    Vec3.set(b, points2[ni * 3], points2[ni * 3 + 1], -0.5);
    builder.add(a, b, op);
  }
  if (sideCount === 3) {
    Vec3.set(a, points2[0], points2[1], -0.5);
    Vec3.set(b, points2[3], points2[4], -0.5);
    Vec3.set(c, points2[6], points2[7], -0.5);
    builder.add(c, b, a);
  } else if (sideCount === 4) {
    Vec3.set(a, points2[0], points2[1], -0.5);
    Vec3.set(b, points2[3], points2[4], -0.5);
    Vec3.set(c, points2[6], points2[7], -0.5);
    Vec3.set(d, points2[9], points2[10], -0.5);
    builder.addQuad(d, c, b, a);
  } else {
    for (let i = 0; i < sideCount; ++i) {
      const ni = (i + 1) % sideCount;
      Vec3.set(a, points2[i * 3], points2[i * 3 + 1], -0.5);
      Vec3.set(b, points2[ni * 3], points2[ni * 3 + 1], -0.5);
      builder.add(on, b, a);
    }
  }
  return builder.getPrimitive();
}
var octagonalPyramid;
function OctagonalPyramid() {
  if (!octagonalPyramid)
    octagonalPyramid = Pyramid(polygon(8, true));
  return octagonalPyramid;
}
var perforatedOctagonalPyramid;
function PerforatedOctagonalPyramid() {
  if (!perforatedOctagonalPyramid) {
    const points2 = polygon(8, true);
    const vertices = new Float32Array(8 * 3 + 6);
    for (let i = 0; i < 8; ++i) {
      vertices[i * 3] = points2[i * 3];
      vertices[i * 3 + 1] = points2[i * 3 + 1];
      vertices[i * 3 + 2] = -0.5;
    }
    vertices[8 * 3] = 0;
    vertices[8 * 3 + 1] = 0;
    vertices[8 * 3 + 2] = -0.5;
    vertices[8 * 3 + 3] = 0;
    vertices[8 * 3 + 4] = 0;
    vertices[8 * 3 + 5] = 0.5;
    const indices = [
      0,
      1,
      8,
      1,
      2,
      8,
      4,
      5,
      8,
      5,
      6,
      8,
      2,
      3,
      9,
      3,
      4,
      9,
      6,
      7,
      9,
      7,
      0,
      9
    ];
    perforatedOctagonalPyramid = createPrimitive(vertices, indices);
  }
  return perforatedOctagonalPyramid;
}

// node_modules/molstar/lib/mol-geo/primitive/star.js
var DefaultStarProps = {
  pointCount: 5,
  outerRadius: 1,
  innerRadius: 0.5,
  thickness: 0.3
};
var op2 = Vec3.zero();
var on2 = Vec3.zero();
var a2 = Vec3.zero();
var b2 = Vec3.zero();
var c2 = Vec3.zero();
function Star(props) {
  const { outerRadius, innerRadius, thickness, pointCount } = { ...DefaultStarProps, ...props };
  const triangleCount = pointCount * 2 * 2;
  const builder = PrimitiveBuilder(triangleCount);
  const innerPoints = new Float32Array(pointCount * 2);
  const outerPoints = new Float32Array(pointCount * 2);
  for (let i = 0; i < pointCount; ++i) {
    const io = i * 2, ii = i * 2 + 1;
    const co = (io + 1) / pointCount * Math.PI, ci = (ii + 1) / pointCount * Math.PI;
    outerPoints[io] = Math.cos(co) * outerRadius;
    outerPoints[ii] = Math.sin(co) * outerRadius;
    innerPoints[io] = Math.cos(ci) * innerRadius;
    innerPoints[ii] = Math.sin(ci) * innerRadius;
  }
  Vec3.set(op2, 0, 0, thickness / 2);
  Vec3.set(on2, 0, 0, -thickness / 2);
  for (let i = 0; i < pointCount; ++i) {
    const ni = (i + 1) % pointCount;
    Vec3.set(a2, outerPoints[i * 2], outerPoints[i * 2 + 1], 0);
    Vec3.set(b2, innerPoints[i * 2], innerPoints[i * 2 + 1], 0);
    Vec3.set(c2, outerPoints[ni * 2], outerPoints[ni * 2 + 1], 0);
    builder.add(op2, a2, b2);
    builder.add(b2, a2, on2);
    builder.add(op2, b2, c2);
    builder.add(c2, b2, on2);
  }
  return builder.getPrimitive();
}

// node_modules/molstar/lib/mol-geo/primitive/octahedron.js
var octahedronVertices = [
  0.5,
  0,
  0,
  -0.5,
  0,
  0,
  0,
  0.5,
  0,
  0,
  -0.5,
  0,
  0,
  0,
  0.5,
  0,
  0,
  -0.5
];
var octahedronIndices = [
  0,
  2,
  4,
  0,
  4,
  3,
  0,
  3,
  5,
  0,
  5,
  2,
  1,
  2,
  5,
  1,
  5,
  3,
  1,
  3,
  4,
  1,
  4,
  2
];
var perforatedOctahedronIndices = [
  0,
  2,
  4,
  0,
  4,
  3,
  // 0, 3, 5,   0, 5, 2,
  1,
  2,
  5,
  1,
  5,
  3
  // 1, 3, 4,   1, 4, 2
];
var octahedronEdges = [
  0,
  2,
  1,
  3,
  2,
  1,
  3,
  0,
  0,
  4,
  1,
  4,
  2,
  4,
  3,
  4,
  0,
  5,
  1,
  5,
  2,
  5,
  3,
  5
];
var octahedron;
function Octahedron() {
  if (!octahedron)
    octahedron = createPrimitive(octahedronVertices, octahedronIndices);
  return octahedron;
}
var perforatedOctahedron;
function PerforatedOctahedron() {
  if (!perforatedOctahedron)
    perforatedOctahedron = createPrimitive(octahedronVertices, perforatedOctahedronIndices);
  return perforatedOctahedron;
}
var octahedronCage = createCage(octahedronVertices, octahedronEdges);

// node_modules/molstar/lib/mol-repr/structure/visual/carbohydrate-symbol-mesh.js
var t = Mat4.identity();
var sVec = Vec3();
var pd = Vec3();
var SideFactor = 2 * 0.806;
var box = Box();
var perforatedBox = PerforatedBox();
var octagonalPyramid2 = OctagonalPyramid();
var perforatedOctagonalPyramid2 = PerforatedOctagonalPyramid();
var star = Star({ outerRadius: 1, innerRadius: 0.5, thickness: 0.5, pointCount: 5 });
var octahedron2 = Octahedron();
var perforatedOctahedron2 = PerforatedOctahedron();
var diamondPrism = DiamondPrism();
var pentagonalPrism = PentagonalPrism();
var hexagonalPrism = HexagonalPrism();
var shiftedHexagonalPrism = ShiftedHexagonalPrism();
var heptagonalPrism = HeptagonalPrism();
function createCarbohydrateSymbolMesh(ctx, structure, theme, props, mesh) {
  const builderState = MeshBuilder.createState(256, 128, mesh);
  const { detail, sizeFactor } = props;
  const carbohydrates = structure.carbohydrates;
  const n = carbohydrates.elements.length;
  const l = element_exports.Location.create(structure);
  for (let i = 0; i < n; ++i) {
    const c4 = carbohydrates.elements[i];
    const ring = c4.unit.rings.all[c4.ringIndex];
    const shapeType = getSaccharideShape(c4.component.type, ring.length);
    l.unit = c4.unit;
    l.element = c4.unit.elements[ring[0]];
    const size = theme.size.size(l);
    const radius = size * sizeFactor;
    const side = size * sizeFactor * SideFactor;
    const { center: center2, normal: normal3, direction } = c4.geometry;
    Vec3.add(pd, center2, direction);
    Mat4.targetTo(t, center2, pd, normal3);
    Mat4.setTranslation(t, center2);
    builderState.currentGroup = i * 2;
    switch (shapeType) {
      case SaccharideShape.FilledSphere:
        addSphere(builderState, center2, radius, detail);
        break;
      case SaccharideShape.FilledCube:
        Mat4.scaleUniformly(t, t, side);
        MeshBuilder.addPrimitive(builderState, t, box);
        break;
      case SaccharideShape.CrossedCube:
        Mat4.scaleUniformly(t, t, side);
        MeshBuilder.addPrimitive(builderState, t, perforatedBox);
        Mat4.mul(t, t, Mat4.rotZ90X180);
        builderState.currentGroup += 1;
        MeshBuilder.addPrimitive(builderState, t, perforatedBox);
        break;
      case SaccharideShape.FilledCone:
        Mat4.scaleUniformly(t, t, side * 1.2);
        MeshBuilder.addPrimitive(builderState, t, octagonalPyramid2);
        break;
      case SaccharideShape.DevidedCone:
        Mat4.scaleUniformly(t, t, side * 1.2);
        MeshBuilder.addPrimitive(builderState, t, perforatedOctagonalPyramid2);
        Mat4.mul(t, t, Mat4.rotZ90);
        builderState.currentGroup += 1;
        MeshBuilder.addPrimitive(builderState, t, perforatedOctagonalPyramid2);
        break;
      case SaccharideShape.FlatBox:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, box);
        break;
      case SaccharideShape.FilledStar:
        Mat4.scaleUniformly(t, t, side);
        Mat4.mul(t, t, Mat4.rotZY90);
        MeshBuilder.addPrimitive(builderState, t, star);
        break;
      case SaccharideShape.FilledDiamond:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side * 1.4, side * 1.4, side * 1.4));
        MeshBuilder.addPrimitive(builderState, t, octahedron2);
        break;
      case SaccharideShape.DividedDiamond:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side * 1.4, side * 1.4, side * 1.4));
        MeshBuilder.addPrimitive(builderState, t, perforatedOctahedron2);
        Mat4.mul(t, t, Mat4.rotY90);
        builderState.currentGroup += 1;
        MeshBuilder.addPrimitive(builderState, t, perforatedOctahedron2);
        break;
      case SaccharideShape.FlatDiamond:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side / 2, side / 2));
        MeshBuilder.addPrimitive(builderState, t, diamondPrism);
        break;
      case SaccharideShape.DiamondPrism:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, diamondPrism);
        break;
      case SaccharideShape.PentagonalPrism:
      case SaccharideShape.Pentagon:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, pentagonalPrism);
        break;
      case SaccharideShape.HexagonalPrism:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, hexagonalPrism);
        break;
      case SaccharideShape.HeptagonalPrism:
        Mat4.mul(t, t, Mat4.rotZY90);
        Mat4.scale(t, t, Vec3.set(sVec, side, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, heptagonalPrism);
        break;
      case SaccharideShape.FlatHexagon:
      default:
        Mat4.mul(t, t, Mat4.rotZYZ90);
        Mat4.scale(t, t, Vec3.set(sVec, side / 1.5, side, side / 2));
        MeshBuilder.addPrimitive(builderState, t, shiftedHexagonalPrism);
        break;
    }
  }
  return MeshBuilder.getMesh(builderState);
}
var CarbohydrateSymbolParams = {
  ...ComplexMeshParams,
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  sizeFactor: ParamDefinition.Numeric(1.75, { min: 0, max: 10, step: 0.01 })
};
function CarbohydrateSymbolVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(CarbohydrateSymbolParams),
    createGeometry: createCarbohydrateSymbolMesh,
    createLocationIterator: CarbohydrateElementIterator,
    getLoci: getCarbohydrateLoci,
    eachLocation: eachCarbohydrate,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail;
    }
  }, materialId);
}
function CarbohydrateElementIterator(structure) {
  const carbElements = structure.carbohydrates.elements;
  const groupCount = carbElements.length * 2;
  const instanceCount = 1;
  const location = element_exports.Location.create(structure);
  function getLocation(groupIndex, instanceIndex) {
    const carb = carbElements[Math.floor(groupIndex / 2)];
    const ring = carb.unit.rings.all[carb.ringIndex];
    location.unit = carb.unit;
    location.element = carb.unit.elements[ring[0]];
    return location;
  }
  function isSecondary(elementIndex, instanceIndex) {
    return elementIndex % 2 === 1;
  }
  return LocationIterator(groupCount, instanceCount, 1, getLocation, true, isSecondary);
}
function getCarbohydrateLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const carb = structure.carbohydrates.elements[Math.floor(groupId / 2)];
    return getAltResidueLociFromId(structure, carb.unit, carb.residueIndex, carb.altId);
  }
  return EmptyLoci;
}
var __elementIndicesSet = /* @__PURE__ */ new Set();
function eachCarbohydrate(loci, structure, apply) {
  const { getElementIndices } = structure.carbohydrates;
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  for (const { unit, indices } of loci.elements) {
    if (!Unit.isAtomic(unit))
      continue;
    __elementIndicesSet.clear();
    OrderedSet.forEach(indices, (v2) => {
      const elementIndices = getElementIndices(unit, unit.elements[v2]);
      for (let i = 0, il = elementIndices.length; i < il; ++i) {
        if (!__elementIndicesSet.has(elementIndices[i])) {
          __elementIndicesSet.add(elementIndices[i]);
          if (apply(Interval.ofSingleton(elementIndices[i] * 2)))
            changed = true;
        }
      }
    });
  }
  return changed;
}

// node_modules/molstar/lib/mol-repr/structure/visual/carbohydrate-terminal-link-cylinder.js
function createCarbohydrateTerminalLinkCylinderMesh(ctx, structure, theme, props, mesh) {
  const { terminalLinks, elements } = structure.carbohydrates;
  const { terminalLinkSizeFactor } = props;
  const location = element_exports.Location.create(structure);
  const builderProps = {
    linkCount: terminalLinks.length,
    position: (posA, posB, edgeIndex) => {
      const l = terminalLinks[edgeIndex];
      if (l.fromCarbohydrate) {
        Vec3.copy(posA, elements[l.carbohydrateIndex].geometry.center);
        l.elementUnit.conformation.position(l.elementUnit.elements[l.elementIndex], posB);
      } else {
        l.elementUnit.conformation.position(l.elementUnit.elements[l.elementIndex], posA);
        Vec3.copy(posB, elements[l.carbohydrateIndex].geometry.center);
      }
    },
    radius: (edgeIndex) => {
      const l = terminalLinks[edgeIndex];
      if (l.fromCarbohydrate) {
        const carb = elements[l.carbohydrateIndex];
        const ring = carb.unit.rings.all[carb.ringIndex];
        location.unit = carb.unit;
        location.element = carb.unit.elements[ring[0]];
      } else {
        location.unit = l.elementUnit;
        location.element = l.elementUnit.elements[l.elementIndex];
      }
      return theme.size.size(location) * terminalLinkSizeFactor;
    },
    style: (edgeIndex) => {
      const l = terminalLinks[edgeIndex];
      const eI = l.elementUnit.elements[l.elementIndex];
      const beI = getElementIdx(l.elementUnit.model.atomicHierarchy.atoms.type_symbol.value(eI));
      return MetalsSet.has(beI) ? LinkStyle.Dashed : LinkStyle.Solid;
    }
  };
  const { mesh: m, boundingSphere } = createLinkCylinderMesh(ctx, builderProps, props, mesh);
  if (boundingSphere) {
    m.setBoundingSphere(boundingSphere);
  } else if (m.triangleCount > 0) {
    const sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, 1 * terminalLinkSizeFactor);
    m.setBoundingSphere(sphere);
  }
  return m;
}
var CarbohydrateTerminalLinkParams = {
  ...UnitsMeshParams,
  ...LinkCylinderParams,
  terminalLinkSizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 3, step: 0.01 })
};
function CarbohydrateTerminalLinkVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(CarbohydrateTerminalLinkParams),
    createGeometry: createCarbohydrateTerminalLinkCylinderMesh,
    createLocationIterator: CarbohydrateTerminalLinkIterator,
    getLoci: getTerminalLinkLoci,
    eachLocation: eachTerminalLink,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.terminalLinkSizeFactor !== currentProps.terminalLinkSizeFactor || newProps.radialSegments !== currentProps.radialSegments || newProps.linkCap !== currentProps.linkCap;
    }
  }, materialId);
}
function CarbohydrateTerminalLinkIterator(structure) {
  const { elements, terminalLinks } = structure.carbohydrates;
  const groupCount = terminalLinks.length;
  const instanceCount = 1;
  const location = element_exports.Location.create(structure);
  const getLocation = (groupIndex) => {
    const terminalLink = terminalLinks[groupIndex];
    if (terminalLink.fromCarbohydrate) {
      const carb = elements[terminalLink.carbohydrateIndex];
      const ring = carb.unit.rings.all[carb.ringIndex];
      location.unit = carb.unit;
      location.element = carb.unit.elements[ring[0]];
    } else {
      location.unit = terminalLink.elementUnit;
      location.element = terminalLink.elementUnit.elements[terminalLink.elementIndex];
    }
    return location;
  };
  return LocationIterator(groupCount, instanceCount, 1, getLocation, true);
}
function getTerminalLinkLoci(pickingId, structure, id) {
  const { objectId, groupId } = pickingId;
  if (id === objectId) {
    const { terminalLinks, elements } = structure.carbohydrates;
    const l = terminalLinks[groupId];
    const carb = elements[l.carbohydrateIndex];
    return element_exports.Loci.union(getAltResidueLociFromId(structure, carb.unit, carb.residueIndex, carb.altId), getAltResidueLoci(structure, l.elementUnit, l.elementUnit.elements[l.elementIndex]));
  }
  return EmptyLoci;
}
var __linkIndicesSet2 = /* @__PURE__ */ new Set();
function eachTerminalLink(loci, structure, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const { getTerminalLinkIndices } = structure.carbohydrates;
  for (const { unit, indices } of loci.elements) {
    if (!Unit.isAtomic(unit))
      continue;
    __linkIndicesSet2.clear();
    OrderedSet.forEach(indices, (v2) => {
      const linkIndices = getTerminalLinkIndices(unit, unit.elements[v2]);
      for (let i = 0, il = linkIndices.length; i < il; ++i) {
        if (!__linkIndicesSet2.has(linkIndices[i])) {
          __linkIndicesSet2.add(linkIndices[i]);
          if (apply(Interval.ofSingleton(linkIndices[i])))
            changed = true;
        }
      }
    });
  }
  return changed;
}

// node_modules/molstar/lib/mol-repr/structure/representation/carbohydrate.js
var CarbohydrateVisuals = {
  "carbohydrate-symbol": (ctx, getParams) => ComplexRepresentation("Carbohydrate symbol mesh", ctx, getParams, CarbohydrateSymbolVisual),
  "carbohydrate-link": (ctx, getParams) => ComplexRepresentation("Carbohydrate link cylinder", ctx, getParams, CarbohydrateLinkVisual),
  "carbohydrate-terminal-link": (ctx, getParams) => ComplexRepresentation("Carbohydrate terminal link cylinder", ctx, getParams, CarbohydrateTerminalLinkVisual)
};
var CarbohydrateParams = {
  ...CarbohydrateSymbolParams,
  ...CarbohydrateLinkParams,
  ...CarbohydrateTerminalLinkParams,
  visuals: ParamDefinition.MultiSelect(["carbohydrate-symbol", "carbohydrate-link", "carbohydrate-terminal-link"], ParamDefinition.objectToOptions(CarbohydrateVisuals)),
  bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.2, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getCarbohydrateParams(ctx, structure) {
  return CarbohydrateParams;
}
function CarbohydrateRepresentation(ctx, getParams) {
  return Representation.createMulti("Carbohydrate", ctx, getParams, StructureRepresentationStateBuilder, CarbohydrateVisuals);
}
var CarbohydrateRepresentationProvider = StructureRepresentationProvider({
  name: "carbohydrate",
  label: "Carbohydrate",
  description: "Displays carbohydrate symbols (3D SNFG).",
  factory: CarbohydrateRepresentation,
  getParams: getCarbohydrateParams,
  defaultValues: ParamDefinition.getDefaultValues(CarbohydrateParams),
  defaultColorTheme: { name: "carbohydrate-symbol" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => {
    return structure.models.some((m) => Model.hasCarbohydrate(m));
  }
});

// node_modules/molstar/lib/mol-repr/structure/visual/util/polymer/backbone.js
function eachPolymerBackboneLink(unit, callback) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return eachAtomicPolymerBackboneLink(unit, callback);
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return eachCoarsePolymerBackboneLink(unit, callback);
  }
}
function eachAtomicPolymerBackboneLink(unit, callback) {
  const cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;
  const polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
  const residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);
  const traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
  const { moleculeType } = unit.model.atomicHierarchy.derived.residue;
  let indexA = -1;
  let indexB = -1;
  let isFirst = true;
  let firstGroup = -1;
  let i = 0;
  while (polymerIt.hasNext) {
    isFirst = true;
    firstGroup = i;
    residueIt.setSegment(polymerIt.move());
    while (residueIt.hasNext) {
      if (isFirst) {
        const index_1 = residueIt.move().index;
        ++i;
        if (!residueIt.hasNext)
          continue;
        isFirst = false;
        indexB = index_1;
      }
      const index2 = residueIt.move().index;
      indexA = indexB;
      indexB = index2;
      callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, i, moleculeType[indexA]);
      ++i;
    }
    if (cyclicPolymerMap.has(indexB)) {
      indexA = indexB;
      indexB = cyclicPolymerMap.get(indexA);
      callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, firstGroup, moleculeType[indexA]);
    }
  }
}
function eachCoarsePolymerBackboneLink(unit, callback) {
  const polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
  const { elements } = unit;
  let isFirst = true;
  let i = 0;
  while (polymerIt.hasNext) {
    isFirst = true;
    const _a = polymerIt.move(), start2 = _a.start, end = _a.end;
    for (let j = start2, jl = end; j < jl; ++j) {
      if (isFirst) {
        ++j;
        ++i;
        if (j > jl)
          continue;
        isFirst = false;
      }
      callback(
        elements[j - 1],
        elements[j],
        i - 1,
        i,
        0
        /* Unknown */
      );
      ++i;
    }
  }
}
function eachPolymerBackboneElement(unit, callback) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return eachAtomicPolymerBackboneElement(unit, callback);
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return eachCoarsePolymerBackboneElement(unit, callback);
  }
}
function eachAtomicPolymerBackboneElement(unit, callback) {
  const polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
  const residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);
  const traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
  let i = 0;
  while (polymerIt.hasNext) {
    residueIt.setSegment(polymerIt.move());
    while (residueIt.hasNext) {
      const index2 = residueIt.move().index;
      callback(traceElementIndex[index2], i);
      ++i;
    }
  }
}
function eachCoarsePolymerBackboneElement(unit, callback) {
  const polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
  const { elements } = unit;
  let i = 0;
  while (polymerIt.hasNext) {
    const _a = polymerIt.move(), start2 = _a.start, end = _a.end;
    for (let j = start2, jl = end; j < jl; ++j) {
      callback(elements[j], i);
      ++i;
    }
  }
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/polymer/gap-iterator.js
function PolymerGapIterator(structure, unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return new AtomicPolymerGapIterator(structure, unit);
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return new CoarsePolymerGapIterator(structure, unit);
  }
}
function createPolymerGapPair(structure, unit) {
  return {
    centerA: element_exports.Location.create(structure, unit),
    centerB: element_exports.Location.create(structure, unit)
  };
}
var AtomicPolymerGapIterator = class {
  move() {
    const { elements, residueIndex } = this.unit;
    const gapSegment = this.gapIt.move();
    this.value.centerA.element = this.traceElementIndex[residueIndex[elements[gapSegment.start]]];
    this.value.centerB.element = this.traceElementIndex[residueIndex[elements[gapSegment.end - 1]]];
    this.hasNext = this.gapIt.hasNext;
    return this.value;
  }
  constructor(structure, unit) {
    this.unit = unit;
    this.hasNext = false;
    this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
    this.gapIt = SortedRanges.transientSegments(getGapRanges(unit), unit.elements);
    this.value = createPolymerGapPair(structure, unit);
    this.hasNext = this.gapIt.hasNext;
  }
};
var CoarsePolymerGapIterator = class {
  move() {
    const gapSegment = this.gapIt.move();
    this.value.centerA.element = this.unit.elements[gapSegment.start];
    this.value.centerB.element = this.unit.elements[gapSegment.end - 1];
    this.hasNext = this.gapIt.hasNext;
    return this.value;
  }
  constructor(structure, unit) {
    this.unit = unit;
    this.hasNext = false;
    this.gapIt = SortedRanges.transientSegments(getGapRanges(unit), unit.elements);
    this.value = createPolymerGapPair(structure, unit);
    this.hasNext = this.gapIt.hasNext;
  }
};

// node_modules/molstar/lib/mol-model-props/computed/helix-orientation/helix-orientation.js
function calcHelixOrientation(model) {
  const { x, y, z } = model.atomicConformation;
  const { polymerType, traceElementIndex } = model.atomicHierarchy.derived.residue;
  const n = polymerType.length;
  const elements = OrderedSet.ofBounds(0, model.atomicConformation.atomId.rowCount);
  const polymerIt = SortedRanges.transientSegments(model.atomicRanges.polymerRanges, elements);
  const residueIt = Segmentation.transientSegments(model.atomicHierarchy.residueAtomSegments, elements);
  const centers = new Float32Array(n * 3);
  const axes = new Float32Array(n * 3);
  let i = 0;
  let j = -1;
  let s = -1;
  const a1 = Vec3();
  const a22 = Vec3();
  const a32 = Vec3();
  const a4 = Vec3();
  const r12 = Vec3();
  const r23 = Vec3();
  const r34 = Vec3();
  const v1 = Vec3();
  const v2 = Vec3();
  const vt = Vec3();
  const diff13 = Vec3();
  const diff24 = Vec3();
  const axis = Vec3();
  const prevAxis = Vec3();
  while (polymerIt.hasNext) {
    const ps = polymerIt.move();
    residueIt.setSegment(ps);
    i = -1;
    s = -1;
    while (residueIt.hasNext) {
      i += 1;
      const { index: index2 } = residueIt.move();
      if (i === 0)
        s = index2;
      j = index2 - 2;
      const j3 = j * 3;
      Vec3.copy(a1, a22);
      Vec3.copy(a22, a32);
      Vec3.copy(a32, a4);
      const eI2 = traceElementIndex[index2];
      Vec3.set(a4, x[eI2], y[eI2], z[eI2]);
      if (i < 3)
        continue;
      Vec3.sub(r12, a22, a1);
      Vec3.sub(r23, a32, a22);
      Vec3.sub(r34, a4, a32);
      Vec3.sub(diff13, r12, r23);
      Vec3.sub(diff24, r23, r34);
      Vec3.cross(axis, diff13, diff24);
      Vec3.normalize(axis, axis);
      Vec3.toArray(axis, axes, j3);
      const tmp = Math.cos(Vec3.angle(diff13, diff24));
      const diff13Length = Vec3.magnitude(diff13);
      const diff24Length = Vec3.magnitude(diff24);
      const r = Math.sqrt(diff24Length * diff13Length) / // clamp, to avoid numerical instabilities for when
      // angle between diff13 and diff24 is close to 0
      Math.max(2, 2 * (1 - tmp));
      Vec3.scale(v1, diff13, r / diff13Length);
      Vec3.sub(v1, a22, v1);
      Vec3.toArray(v1, centers, j3);
      Vec3.scale(v2, diff24, r / diff24Length);
      Vec3.sub(v2, a32, v2);
      Vec3.toArray(v2, centers, j3 + 3);
      Vec3.copy(prevAxis, axis);
    }
    const s3 = s * 3;
    Vec3.fromArray(v1, centers, s3 + 3);
    Vec3.fromArray(v2, centers, s3 + 6);
    Vec3.normalize(axis, Vec3.sub(axis, v1, v2));
    const sI = traceElementIndex[s];
    Vec3.set(a1, x[sI], y[sI], z[sI]);
    Vec3.copy(vt, a1);
    Vec3.projectPointOnVector(vt, vt, axis, v1);
    Vec3.toArray(vt, centers, s3);
    const e = j + 2;
    const e3 = e * 3;
    Vec3.fromArray(v1, centers, e3 - 3);
    Vec3.fromArray(v2, centers, e3 - 6);
    Vec3.normalize(axis, Vec3.sub(axis, v1, v2));
    const eI = traceElementIndex[e];
    Vec3.set(a1, x[eI], y[eI], z[eI]);
    Vec3.copy(vt, a1);
    Vec3.projectPointOnVector(vt, vt, axis, v1);
    Vec3.toArray(vt, centers, e3);
  }
  return {
    centers
  };
}

// node_modules/molstar/lib/mol-model-props/computed/helix-orientation.js
var HelixOrientationProvider = CustomModelProperty.createProvider({
  label: "Helix Orientation",
  descriptor: CustomPropertyDescriptor({
    name: "molstar_helix_orientation"
  }),
  type: "dynamic",
  defaultParams: {},
  getParams: () => ({}),
  isApplicable: (data) => true,
  obtain: async (ctx, data) => {
    return { value: calcHelixOrientation(data) };
  }
});

// node_modules/molstar/lib/mol-repr/structure/visual/util/polymer/trace-iterator.js
function isHelixSS(ss) {
  return SecondaryStructureType.is(ss, SecondaryStructureType.Flag.Helix);
}
function isSheetSS(ss) {
  return SecondaryStructureType.is(ss, SecondaryStructureType.Flag.Beta);
}
function PolymerTraceIterator(unit, structure, options = {}) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return new AtomicPolymerTraceIterator(unit, structure, options);
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return new CoarsePolymerTraceIterator(unit, structure);
  }
}
var SecStrucTypeNA = SecondaryStructureType.create(SecondaryStructureType.Flag.NA);
function createPolymerTraceElement(structure, unit) {
  return {
    center: element_exports.Location.create(structure, unit),
    centerPrev: element_exports.Location.create(structure, unit),
    centerNext: element_exports.Location.create(structure, unit),
    first: false,
    last: false,
    initial: false,
    final: false,
    secStrucFirst: false,
    secStrucLast: false,
    secStrucType: SecStrucTypeNA,
    moleculeType: MoleculeType.Unknown,
    coarseBackboneFirst: false,
    coarseBackboneLast: false,
    p0: Vec3(),
    p1: Vec3(),
    p2: Vec3(),
    p3: Vec3(),
    p4: Vec3(),
    d12: Vec3(),
    d23: Vec3()
  };
}
var AtomicPolymerTraceIteratorState;
(function(AtomicPolymerTraceIteratorState2) {
  AtomicPolymerTraceIteratorState2[AtomicPolymerTraceIteratorState2["nextPolymer"] = 0] = "nextPolymer";
  AtomicPolymerTraceIteratorState2[AtomicPolymerTraceIteratorState2["nextResidue"] = 1] = "nextResidue";
})(AtomicPolymerTraceIteratorState || (AtomicPolymerTraceIteratorState = {}));
var tmpDir = Vec3();
var tmpVecA = Vec3();
var tmpVecB = Vec3();
var AtomicPolymerTraceIterator = class {
  atomicPos(target, index2) {
    if (index2 !== -1) {
      target[0] = this.atomicConformation.x[index2];
      target[1] = this.atomicConformation.y[index2];
      target[2] = this.atomicConformation.z[index2];
    }
  }
  pos(target, residueIndex, ss) {
    const index2 = this.traceElementIndex[residueIndex];
    if (this.helixOrientationCenters && isHelixSS(ss)) {
      Vec3.fromArray(target, this.helixOrientationCenters, residueIndex * 3);
    } else {
      this.atomicPos(target, index2);
    }
  }
  updateResidueSegmentRange(polymerSegment) {
    const { index: index2 } = this.residueAtomSegments;
    this.residueSegmentMin = index2[this.polymerRanges[polymerSegment.index * 2]];
    this.residueSegmentMax = index2[this.polymerRanges[polymerSegment.index * 2 + 1]];
  }
  getResidueIndex(residueIndex) {
    if (residueIndex < this.residueSegmentMin) {
      const cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMin);
      if (cyclicIndex !== void 0) {
        residueIndex = cyclicIndex - (this.residueSegmentMin - residueIndex - 1);
      } else {
        residueIndex = this.residueSegmentMin;
      }
    } else if (residueIndex > this.residueSegmentMax) {
      const cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMax);
      if (cyclicIndex !== void 0) {
        residueIndex = cyclicIndex + (residueIndex - this.residueSegmentMax - 1);
      } else {
        residueIndex = this.residueSegmentMax;
      }
    }
    return residueIndex;
  }
  getSecStruc(residueIndex) {
    if (this.secondaryStructure) {
      const { type, getIndex } = this.secondaryStructure;
      const ss = type[getIndex(residueIndex)];
      return isHelixSS(ss) ? SecondaryStructureType.Flag.Helix : ss;
    } else {
      return SecStrucTypeNA;
    }
  }
  setControlPoint(out, p13, p23, p33, ss) {
    if (isSheetSS(ss) || this.helixOrientationCenters && isHelixSS(ss)) {
      Vec3.scale(out, Vec3.add(out, p13, Vec3.add(out, p33, Vec3.add(out, p23, p23))), 1 / 4);
    } else {
      Vec3.copy(out, p23);
    }
  }
  setFromToVector(out, residueIndex, ss) {
    if (this.helixOrientationCenters && isHelixSS(ss)) {
      Vec3.set(out, 1, 0, 0);
    } else {
      this.atomicPos(tmpVecA, this.directionFromElementIndex[residueIndex]);
      this.atomicPos(tmpVecB, this.directionToElementIndex[residueIndex]);
      Vec3.sub(out, tmpVecB, tmpVecA);
    }
  }
  setDirection(out, v1, v2, v3) {
    Vec3.matchDirection(tmpVecA, v1, v2);
    Vec3.matchDirection(tmpVecB, v3, v2);
    Vec3.scale(out, Vec3.add(out, tmpVecA, Vec3.add(out, tmpVecB, Vec3.add(out, v2, v2))), 1 / 4);
  }
  move() {
    const { residueIt, polymerIt, value } = this;
    if (this.state === AtomicPolymerTraceIteratorState.nextPolymer) {
      while (polymerIt.hasNext) {
        this.polymerSegment = polymerIt.move();
        residueIt.setSegment(this.polymerSegment);
        this.updateResidueSegmentRange(this.polymerSegment);
        if (residueIt.hasNext) {
          this.state = AtomicPolymerTraceIteratorState.nextResidue;
          const residueIndexBeg = this.residueAtomSegments.index[this.unit.elements[this.polymerSegment.start]];
          const residueIndexBegPrev = this.getResidueIndex(residueIndexBeg - 1);
          this.currSecStrucType = residueIndexBeg === residueIndexBegPrev ? SecStrucTypeNA : this.getSecStruc(residueIndexBegPrev);
          this.nextSecStrucType = this.getSecStruc(residueIndexBeg);
          this.currCoarseBackbone = this.directionFromElementIndex[residueIndexBegPrev] === -1 || this.directionToElementIndex[residueIndexBegPrev] === -1;
          this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexBeg] === -1 || this.directionToElementIndex[residueIndexBeg] === -1;
          break;
        }
      }
    }
    if (this.state === AtomicPolymerTraceIteratorState.nextResidue) {
      const { index: residueIndex } = residueIt.move();
      const residueIndexPrev3 = this.getResidueIndex(residueIndex - 3);
      const residueIndexPrev2 = this.getResidueIndex(residueIndex - 2);
      const residueIndexPrev1 = this.getResidueIndex(residueIndex - 1);
      const residueIndexNext1 = this.getResidueIndex(residueIndex + 1);
      const residueIndexNext2 = this.getResidueIndex(residueIndex + 2);
      const residueIndexNext3 = this.getResidueIndex(residueIndex + 3);
      this.prevSecStrucType = this.getSecStruc(residueIndexPrev1);
      this.currSecStrucType = this.getSecStruc(residueIndex);
      this.nextSecStrucType = residueIndex === residueIndexNext1 ? SecStrucTypeNA : this.getSecStruc(residueIndexNext1);
      this.prevCoarseBackbone = this.currCoarseBackbone;
      this.currCoarseBackbone = this.nextCoarseBackbone;
      this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexNext1] === -1 || this.directionToElementIndex[residueIndexNext1] === -1;
      value.secStrucType = this.currSecStrucType;
      value.secStrucFirst = this.prevSecStrucType !== this.currSecStrucType;
      value.secStrucLast = this.currSecStrucType !== this.nextSecStrucType;
      value.coarseBackboneFirst = this.prevCoarseBackbone !== this.currCoarseBackbone;
      value.coarseBackboneLast = this.currCoarseBackbone !== this.nextCoarseBackbone;
      value.first = residueIndex === this.residueSegmentMin;
      value.last = residueIndex === this.residueSegmentMax;
      value.moleculeType = this.moleculeType[residueIndex];
      value.initial = residueIndex === residueIndexPrev1;
      value.final = residueIndex === residueIndexNext1;
      value.centerPrev.element = this.traceElementIndex[residueIndexPrev1];
      value.center.element = this.traceElementIndex[residueIndex];
      value.centerNext.element = this.traceElementIndex[residueIndexNext1];
      const ssPrev3 = this.getSecStruc(residueIndexPrev3);
      const ssPrev2 = this.getSecStruc(residueIndexPrev2);
      const ssPrev1 = this.getSecStruc(residueIndexPrev1);
      const ss = this.getSecStruc(residueIndex);
      const ssNext1 = this.getSecStruc(residueIndexNext1);
      const ssNext2 = this.getSecStruc(residueIndexNext2);
      const ssNext3 = this.getSecStruc(residueIndexNext3);
      this.pos(this.p0, residueIndexPrev3, ssPrev3);
      this.pos(this.p1, residueIndexPrev2, ssPrev2);
      this.pos(this.p2, residueIndexPrev1, ssPrev1);
      this.pos(this.p3, residueIndex, ss);
      this.pos(this.p4, residueIndexNext1, ssNext1);
      this.pos(this.p5, residueIndexNext2, ssNext2);
      this.pos(this.p6, residueIndexNext3, ssNext3);
      const isHelixPrev3 = isHelixSS(ssPrev3);
      const isHelixPrev2 = isHelixSS(ssPrev2);
      const isHelixPrev1 = isHelixSS(ssPrev1);
      const isHelix = isHelixSS(ss);
      const isHelixNext1 = isHelixSS(ssNext1);
      const isHelixNext2 = isHelixSS(ssNext2);
      const isHelixNext3 = isHelixSS(ssNext3);
      if (this.helixOrientationCenters && !(isHelix && value.secStrucFirst && value.secStrucLast)) {
        if (isHelix !== isHelixPrev1) {
          if (isHelix) {
            Vec3.copy(this.p0, this.p3);
            Vec3.copy(this.p1, this.p3);
            Vec3.copy(this.p2, this.p3);
          } else if (isHelixPrev1) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), 2);
            Vec3.add(this.p2, this.p3, tmpDir);
            Vec3.add(this.p1, this.p2, tmpDir);
            Vec3.add(this.p0, this.p1, tmpDir);
          }
        } else if (isHelix !== isHelixPrev2) {
          if (isHelix) {
            Vec3.copy(this.p0, this.p2);
            Vec3.copy(this.p1, this.p2);
          } else if (isHelixPrev2) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), 2);
            Vec3.add(this.p1, this.p2, tmpDir);
            Vec3.add(this.p0, this.p1, tmpDir);
          }
        } else if (isHelix !== isHelixPrev3) {
          if (isHelix) {
            Vec3.copy(this.p0, this.p1);
          } else if (isHelixPrev3) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p0, this.p1), 2);
            Vec3.add(this.p0, this.p1, tmpDir);
          }
        }
        if (isHelix !== isHelixNext1) {
          if (isHelix) {
            Vec3.copy(this.p4, this.p3);
            Vec3.copy(this.p5, this.p3);
            Vec3.copy(this.p6, this.p3);
          } else if (isHelixNext1) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), 2);
            Vec3.add(this.p4, this.p3, tmpDir);
            Vec3.add(this.p5, this.p4, tmpDir);
            Vec3.add(this.p6, this.p5, tmpDir);
          }
        } else if (isHelix !== isHelixNext2) {
          if (isHelix) {
            Vec3.copy(this.p5, this.p4);
            Vec3.copy(this.p6, this.p4);
          } else if (isHelixNext2) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), 2);
            Vec3.add(this.p5, this.p4, tmpDir);
            Vec3.add(this.p6, this.p5, tmpDir);
          }
        } else if (isHelix !== isHelixNext3) {
          if (isHelix) {
            Vec3.copy(this.p6, this.p5);
          } else if (isHelixNext3) {
            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p6, this.p5), 2);
            Vec3.add(this.p6, this.p5, tmpDir);
          }
        }
      }
      if (this.currCoarseBackbone) {
        Vec3.triangleNormal(this.d01, this.p1, this.p2, this.p3);
        Vec3.triangleNormal(this.d12, this.p2, this.p3, this.p4);
        Vec3.triangleNormal(this.d23, this.p3, this.p4, this.p5);
        Vec3.triangleNormal(this.d34, this.p4, this.p5, this.p6);
      } else {
        this.setFromToVector(this.d01, residueIndexPrev1, ssPrev1);
        this.setFromToVector(this.d12, residueIndex, ss);
        this.setFromToVector(this.d23, residueIndexNext1, ssNext1);
        this.setFromToVector(this.d34, residueIndexNext2, ssNext2);
      }
      const helixFlag = isHelix && this.helixOrientationCenters;
      const f = 1.5;
      if (residueIndex === residueIndexPrev1 || ss !== ssPrev1 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p4), f);
        Vec3.add(this.p2, this.p3, tmpDir);
        Vec3.add(this.p1, this.p2, tmpDir);
        Vec3.add(this.p0, this.p1, tmpDir);
      } else if (residueIndexPrev1 === residueIndexPrev2 || ss !== ssPrev2 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), f);
        Vec3.add(this.p1, this.p2, tmpDir);
        Vec3.add(this.p0, this.p1, tmpDir);
      } else if (residueIndexPrev2 === residueIndexPrev3 || ss !== ssPrev3 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), f);
        Vec3.add(this.p0, this.p1, tmpDir);
      }
      if (residueIndex === residueIndexNext1 || ss !== ssNext1 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p2), f);
        Vec3.add(this.p4, this.p3, tmpDir);
        Vec3.add(this.p5, this.p4, tmpDir);
        Vec3.add(this.p6, this.p5, tmpDir);
      } else if (residueIndexNext1 === residueIndexNext2 || ss !== ssNext2 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), f);
        Vec3.add(this.p5, this.p4, tmpDir);
        Vec3.add(this.p6, this.p5, tmpDir);
      } else if (residueIndexNext2 === residueIndexNext3 || ss !== ssNext3 && helixFlag) {
        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), f);
        Vec3.add(this.p6, this.p5, tmpDir);
      }
      this.setControlPoint(value.p0, this.p0, this.p1, this.p2, ssPrev2);
      this.setControlPoint(value.p1, this.p1, this.p2, this.p3, ssPrev1);
      this.setControlPoint(value.p2, this.p2, this.p3, this.p4, ss);
      this.setControlPoint(value.p3, this.p3, this.p4, this.p5, ssNext1);
      this.setControlPoint(value.p4, this.p4, this.p5, this.p6, ssNext2);
      this.setDirection(value.d12, this.d01, this.d12, this.d23);
      this.setDirection(value.d23, this.d12, this.d23, this.d34);
      if (!residueIt.hasNext) {
        this.state = AtomicPolymerTraceIteratorState.nextPolymer;
      }
    }
    this.hasNext = residueIt.hasNext || polymerIt.hasNext;
    return this.value;
  }
  constructor(unit, structure, options = {}) {
    var _a;
    this.unit = unit;
    this.state = AtomicPolymerTraceIteratorState.nextPolymer;
    this.p0 = Vec3();
    this.p1 = Vec3();
    this.p2 = Vec3();
    this.p3 = Vec3();
    this.p4 = Vec3();
    this.p5 = Vec3();
    this.p6 = Vec3();
    this.d01 = Vec3();
    this.d12 = Vec3();
    this.d23 = Vec3();
    this.d34 = Vec3();
    this.hasNext = false;
    this.atomicConformation = unit.model.atomicConformation;
    this.residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;
    this.polymerRanges = unit.model.atomicRanges.polymerRanges;
    this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
    this.directionFromElementIndex = unit.model.atomicHierarchy.derived.residue.directionFromElementIndex;
    this.directionToElementIndex = unit.model.atomicHierarchy.derived.residue.directionToElementIndex;
    this.moleculeType = unit.model.atomicHierarchy.derived.residue.moleculeType;
    this.cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;
    this.polymerIt = SortedRanges.transientSegments(this.polymerRanges, unit.elements);
    this.residueIt = Segmentation.transientSegments(this.residueAtomSegments, unit.elements);
    this.value = createPolymerTraceElement(structure, unit);
    this.hasNext = this.residueIt.hasNext && this.polymerIt.hasNext;
    if (!options.ignoreSecondaryStructure) {
      this.secondaryStructure = (_a = SecondaryStructureProvider.get(structure).value) === null || _a === void 0 ? void 0 : _a.get(unit.invariantId);
    }
    if (options.useHelixOrientation) {
      const helixOrientation = HelixOrientationProvider.get(unit.model).value;
      if (!helixOrientation)
        throw new Error("missing helix-orientation");
      this.helixOrientationCenters = helixOrientation.centers;
    }
  }
};
var CoarsePolymerTraceIteratorState;
(function(CoarsePolymerTraceIteratorState2) {
  CoarsePolymerTraceIteratorState2[CoarsePolymerTraceIteratorState2["nextPolymer"] = 0] = "nextPolymer";
  CoarsePolymerTraceIteratorState2[CoarsePolymerTraceIteratorState2["nextElement"] = 1] = "nextElement";
})(CoarsePolymerTraceIteratorState || (CoarsePolymerTraceIteratorState = {}));
var CoarsePolymerTraceIterator = class {
  getElementIndex(elementIndex) {
    return Math.min(Math.max(this.polymerSegment.start, elementIndex), this.polymerSegment.end - 1);
  }
  pos(target, elementIndex) {
    const index2 = this.unit.elements[elementIndex];
    target[0] = this.conformation.x[index2];
    target[1] = this.conformation.y[index2];
    target[2] = this.conformation.z[index2];
  }
  move() {
    if (this.state === CoarsePolymerTraceIteratorState.nextPolymer) {
      while (this.polymerIt.hasNext) {
        this.polymerSegment = this.polymerIt.move();
        this.elementIndex = this.polymerSegment.start;
        if (this.elementIndex < this.polymerSegment.end) {
          this.state = CoarsePolymerTraceIteratorState.nextElement;
          break;
        }
      }
    }
    if (this.state === CoarsePolymerTraceIteratorState.nextElement) {
      const elementIndexPrev2 = this.getElementIndex(this.elementIndex - 2);
      const elementIndexPrev1 = this.getElementIndex(this.elementIndex - 1);
      const elementIndexNext1 = this.getElementIndex(this.elementIndex + 1);
      const elementIndexNext2 = this.getElementIndex(this.elementIndex + 2);
      this.value.centerPrev.element = this.value.center.unit.elements[elementIndexPrev1];
      this.value.center.element = this.value.center.unit.elements[this.elementIndex];
      this.value.centerNext.element = this.value.center.unit.elements[elementIndexNext1];
      this.pos(this.value.p0, elementIndexPrev2);
      this.pos(this.value.p1, elementIndexPrev1);
      this.pos(this.value.p2, this.elementIndex);
      this.pos(this.value.p3, elementIndexNext1);
      this.pos(this.value.p4, elementIndexNext2);
      const f = 0.5;
      if (this.elementIndex === elementIndexPrev1) {
        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p3), f);
        Vec3.add(this.value.p1, this.value.p2, tmpDir);
        Vec3.add(this.value.p0, this.value.p1, tmpDir);
      } else if (elementIndexPrev1 === elementIndexPrev2) {
        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p1, this.value.p2), f);
        Vec3.add(this.value.p0, this.value.p1, tmpDir);
      }
      if (this.elementIndex === elementIndexNext1) {
        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p1), f);
        Vec3.add(this.value.p3, this.value.p2, tmpDir);
        Vec3.add(this.value.p4, this.value.p3, tmpDir);
      } else if (elementIndexNext1 === elementIndexNext2) {
        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p3, this.value.p2), f);
        Vec3.add(this.value.p4, this.value.p3, tmpDir);
      }
      this.value.first = this.elementIndex === this.polymerSegment.start;
      this.value.last = this.elementIndex === this.polymerSegment.end - 1;
      if (this.elementIndex + 1 >= this.polymerSegment.end) {
        this.state = CoarsePolymerTraceIteratorState.nextPolymer;
      }
    }
    this.hasNext = this.elementIndex + 1 < this.polymerSegment.end || this.polymerIt.hasNext;
    this.elementIndex += 1;
    return this.value;
  }
  constructor(unit, structure) {
    this.unit = unit;
    this.state = CoarsePolymerTraceIteratorState.nextPolymer;
    this.hasNext = false;
    this.polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
    this.value = createPolymerTraceElement(structure, unit);
    Vec3.set(this.value.d12, 1, 0, 0);
    Vec3.set(this.value.d23, 1, 0, 0);
    switch (unit.kind) {
      case Unit.Kind.Spheres:
        this.conformation = unit.model.coarseConformation.spheres;
        break;
      case Unit.Kind.Gaussians:
        this.conformation = unit.model.coarseConformation.gaussians;
        break;
    }
    this.hasNext = this.polymerIt.hasNext;
  }
};

// node_modules/molstar/lib/mol-repr/structure/visual/util/polymer/curve-segment.js
var v3fromArray = Vec3.fromArray;
var v3toArray = Vec3.toArray;
var v3normalize = Vec3.normalize;
var v3sub = Vec3.sub;
var v3spline = Vec3.spline;
var v3slerp = Vec3.slerp;
var v3copy = Vec3.copy;
var v3cross = Vec3.cross;
var v3orthogonalize = Vec3.orthogonalize;
var v3matchDirection = Vec3.matchDirection;
var v3scale = Vec3.scale;
var v3add2 = Vec3.add;
function createCurveSegmentState(linearSegments) {
  const n = linearSegments + 1;
  const pn = n * 3;
  return {
    curvePoints: new Float32Array(pn),
    tangentVectors: new Float32Array(pn),
    normalVectors: new Float32Array(pn),
    binormalVectors: new Float32Array(pn),
    widthValues: new Float32Array(n),
    heightValues: new Float32Array(n),
    linearSegments
  };
}
function interpolateCurveSegment(state, controls, tension, shift2) {
  interpolatePointsAndTangents(state, controls, tension, shift2);
  interpolateNormals(state, controls);
}
var tanA = Vec3();
var tanB = Vec3();
var curvePoint = Vec3();
function interpolatePointsAndTangents(state, controls, tension, shift2) {
  const { curvePoints, tangentVectors, linearSegments } = state;
  const { p0, p1: p13, p2: p23, p3: p33, p4: p43, secStrucFirst, secStrucLast } = controls;
  const shift1 = 1 - shift2;
  const tensionBeg = secStrucFirst ? 0.5 : tension;
  const tensionEnd = secStrucLast ? 0.5 : tension;
  for (let j = 0; j <= linearSegments; ++j) {
    const t4 = j * 1 / linearSegments;
    if (t4 < shift1) {
      const te = lerp(tensionBeg, tension, t4);
      v3spline(curvePoint, p0, p13, p23, p33, t4 + shift2, te);
      v3spline(tanA, p0, p13, p23, p33, t4 + shift2 + 0.01, tensionBeg);
      v3spline(tanB, p0, p13, p23, p33, t4 + shift2 - 0.01, tensionBeg);
    } else {
      const te = lerp(tension, tensionEnd, t4);
      v3spline(curvePoint, p13, p23, p33, p43, t4 - shift1, te);
      v3spline(tanA, p13, p23, p33, p43, t4 - shift1 + 0.01, te);
      v3spline(tanB, p13, p23, p33, p43, t4 - shift1 - 0.01, te);
    }
    v3toArray(curvePoint, curvePoints, j * 3);
    v3normalize(tangentVec, v3sub(tangentVec, tanA, tanB));
    v3toArray(tangentVec, tangentVectors, j * 3);
  }
}
var tmpNormal = Vec3();
var tangentVec = Vec3();
var normalVec = Vec3();
var binormalVec = Vec3();
var prevNormal = Vec3();
var nextNormal = Vec3();
var firstTangentVec = Vec3();
var lastTangentVec = Vec3();
var firstNormalVec = Vec3();
var lastNormalVec = Vec3();
function interpolateNormals(state, controls) {
  const { curvePoints, tangentVectors, normalVectors, binormalVectors } = state;
  const { d12: firstDirection, d23: lastDirection } = controls;
  const n = curvePoints.length / 3;
  v3fromArray(firstTangentVec, tangentVectors, 0);
  v3fromArray(lastTangentVec, tangentVectors, (n - 1) * 3);
  v3orthogonalize(firstNormalVec, firstTangentVec, firstDirection);
  v3orthogonalize(lastNormalVec, lastTangentVec, lastDirection);
  v3matchDirection(lastNormalVec, lastNormalVec, firstNormalVec);
  v3copy(prevNormal, firstNormalVec);
  const n12 = n - 1;
  for (let i = 0; i < n; ++i) {
    const j = smoothstep(0, n12, i) * n12;
    const t4 = i === 0 ? 0 : 1 / (n - j);
    v3fromArray(tangentVec, tangentVectors, i * 3);
    v3orthogonalize(normalVec, tangentVec, v3slerp(tmpNormal, prevNormal, lastNormalVec, t4));
    v3toArray(normalVec, normalVectors, i * 3);
    v3copy(prevNormal, normalVec);
    v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));
    v3toArray(binormalVec, binormalVectors, i * 3);
  }
  for (let i = 1; i < n12; ++i) {
    v3fromArray(prevNormal, normalVectors, (i - 1) * 3);
    v3fromArray(normalVec, normalVectors, i * 3);
    v3fromArray(nextNormal, normalVectors, (i + 1) * 3);
    v3scale(normalVec, v3add2(normalVec, prevNormal, v3add2(normalVec, nextNormal, normalVec)), 1 / 3);
    v3toArray(normalVec, normalVectors, i * 3);
    v3fromArray(tangentVec, tangentVectors, i * 3);
    v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));
    v3toArray(binormalVec, binormalVectors, i * 3);
  }
}
function interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift2) {
  const { widthValues, heightValues, linearSegments } = state;
  const shift1 = 1 - shift2;
  for (let i = 0; i <= linearSegments; ++i) {
    const t4 = i * 1 / linearSegments;
    if (t4 < shift1) {
      widthValues[i] = lerp(w0, w1, t4 + shift2);
      heightValues[i] = lerp(h0, h1, t4 + shift2);
    } else {
      widthValues[i] = lerp(w1, w2, t4 - shift1);
      heightValues[i] = lerp(h1, h2, t4 - shift1);
    }
  }
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/polymer.js
var StandardTension = 0.5;
var HelixTension = 0.9;
var StandardShift = 0.5;
var NucleicShift = 0.3;
var OverhangFactor = 2;
function getPolymerRanges(unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return unit.model.atomicRanges.polymerRanges;
    case Unit.Kind.Spheres:
      return unit.model.coarseHierarchy.spheres.polymerRanges;
    case Unit.Kind.Gaussians:
      return unit.model.coarseHierarchy.gaussians.polymerRanges;
  }
}
function getGapRanges(unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return unit.model.atomicRanges.gapRanges;
    case Unit.Kind.Spheres:
      return unit.model.coarseHierarchy.spheres.gapRanges;
    case Unit.Kind.Gaussians:
      return unit.model.coarseHierarchy.gaussians.gapRanges;
  }
}
var PolymerLocationIterator;
(function(PolymerLocationIterator2) {
  function fromGroup(structureGroup, options) {
    const { group, structure } = structureGroup;
    const polymerElements = group.units[0].polymerElements;
    const groupCount = polymerElements.length;
    const instanceCount = group.units.length;
    const location = element_exports.Location.create(structure);
    const getLocation = (groupIndex, instanceIndex) => {
      const unit = group.units[instanceIndex];
      location.unit = unit;
      location.element = polymerElements[groupIndex];
      return location;
    };
    const asSecondary = !!(options === null || options === void 0 ? void 0 : options.asSecondary);
    function isSecondary(elementIndex, instanceIndex) {
      return asSecondary;
    }
    return LocationIterator(groupCount, instanceCount, 1, getLocation, false, isSecondary);
  }
  PolymerLocationIterator2.fromGroup = fromGroup;
})(PolymerLocationIterator || (PolymerLocationIterator = {}));
var PolymerGapLocationIterator;
(function(PolymerGapLocationIterator2) {
  function fromGroup(structureGroup, options) {
    const { group, structure } = structureGroup;
    const gapElements = group.units[0].gapElements;
    const groupCount = gapElements.length;
    const instanceCount = group.units.length;
    const location = element_exports.Location.create(structure);
    const getLocation = (groupIndex, instanceIndex) => {
      const unit = group.units[instanceIndex];
      location.unit = unit;
      location.element = gapElements[groupIndex];
      return location;
    };
    const asSecondary = !!(options === null || options === void 0 ? void 0 : options.asSecondary);
    function isSecondary(elementIndex, instanceIndex) {
      return asSecondary;
    }
    return LocationIterator(groupCount, instanceCount, 1, getLocation, false, isSecondary);
  }
  PolymerGapLocationIterator2.fromGroup = fromGroup;
})(PolymerGapLocationIterator || (PolymerGapLocationIterator = {}));
function getPolymerElementLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId, groupId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    if (Unit.isAtomic(unit)) {
      return getResidueLoci(structure, unit, unit.polymerElements[groupId]);
    } else {
      const { elements } = unit;
      const elementIndex = unit.polymerElements[groupId];
      const unitIndex = OrderedSet.indexOf(elements, elementIndex);
      if (unitIndex !== -1) {
        const indices = OrderedSet.ofSingleton(unitIndex);
        return element_exports.Loci(structure, [{ unit, indices }]);
      }
    }
  }
  return EmptyLoci;
}
function tryApplyResidueInterval(offset, elements, traceElementIndex, apply, r1, r2) {
  let start2 = -1, startIdx = -1;
  for (let rI = r1; rI <= r2; rI++) {
    const eI = traceElementIndex[rI];
    if (eI < 0)
      continue;
    start2 = OrderedSet.indexOf(elements, eI);
    if (start2 >= 0) {
      startIdx = rI;
      break;
    }
  }
  if (start2 < 0) {
    return false;
  }
  let end = start2;
  for (let rI = r2; rI > startIdx; rI--) {
    const eI = traceElementIndex[rI];
    if (eI < 0)
      continue;
    const e = OrderedSet.indexOf(elements, eI);
    if (e >= 0) {
      end = e;
      break;
    }
  }
  return apply(Interval.ofRange(offset + start2, offset + end));
}
function eachAtomicUnitTracedElement(offset, groupSize, elementsSelector, apply, e) {
  let changed = false;
  const { elements } = e.unit;
  const { traceElementIndex } = e.unit.model.atomicHierarchy.derived.residue;
  const { index: resIndex } = e.unit.model.atomicHierarchy.residueAtomSegments;
  const tracedElements = elementsSelector(e.unit);
  if (Interval.is(e.indices)) {
    if (Interval.start(e.indices) === 0 && Interval.end(e.indices) === e.unit.elements.length) {
      changed = apply(Interval.ofBounds(offset, offset + groupSize)) || changed;
    } else {
      const r1 = resIndex[elements[Interval.min(e.indices)]];
      const r2 = resIndex[elements[Interval.max(e.indices)]];
      changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;
    }
  } else {
    const { indices } = e;
    for (let i = 0, _i = indices.length; i < _i; i++) {
      const r1 = resIndex[elements[indices[i]]];
      let r2 = r1;
      let endI = i + 1;
      while (endI < _i) {
        const _r = resIndex[elements[indices[endI]]];
        if (_r - r2 > 1)
          break;
        r2 = _r;
        endI++;
      }
      i = endI - 1;
      changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;
    }
  }
  return changed;
}
function selectPolymerElements(u2) {
  return u2.polymerElements;
}
function eachPolymerElement(loci, structureGroup, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  const { structure, group } = structureGroup;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const groupCount = group.units[0].polymerElements.length;
  for (const e of loci.elements) {
    if (!group.unitIndexMap.has(e.unit.id))
      continue;
    const offset = group.unitIndexMap.get(e.unit.id) * groupCount;
    if (Unit.isAtomic(e.unit)) {
      changed = eachAtomicUnitTracedElement(offset, groupCount, selectPolymerElements, apply, e) || changed;
    } else {
      if (Interval.is(e.indices)) {
        const start2 = offset + Interval.start(e.indices);
        const end = offset + Interval.end(e.indices);
        changed = apply(Interval.ofBounds(start2, end)) || changed;
      } else {
        for (let i = 0, _i = e.indices.length; i < _i; i++) {
          const start2 = e.indices[i];
          let endI = i + 1;
          while (endI < _i && e.indices[endI] === start2)
            endI++;
          i = endI - 1;
          const end = e.indices[i];
          changed = apply(Interval.ofRange(offset + start2, offset + end)) || changed;
        }
      }
    }
  }
  return changed;
}
function getPolymerGapElementLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId, groupId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    const unitIndexA = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId]);
    const unitIndexB = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId % 2 ? groupId - 1 : groupId + 1]);
    if (unitIndexA !== -1 && unitIndexB !== -1) {
      return Bond.Loci(structure, [
        Bond.Location(structure, unit, unitIndexA, structure, unit, unitIndexB),
        Bond.Location(structure, unit, unitIndexB, structure, unit, unitIndexA)
      ]);
    }
  }
  return EmptyLoci;
}
function eachPolymerGapElement(loci, structureGroup, apply) {
  let changed = false;
  if (Bond.isLoci(loci)) {
    const { structure, group } = structureGroup;
    if (!Structure.areRootsEquivalent(loci.structure, structure))
      return false;
    loci = Bond.remapLoci(loci, structure);
    const groupCount = group.units[0].gapElements.length;
    for (const b4 of loci.bonds) {
      const unitIdx = group.unitIndexMap.get(b4.aUnit.id);
      if (unitIdx !== void 0) {
        const idxA = OrderedSet.indexOf(b4.aUnit.gapElements, b4.aUnit.elements[b4.aIndex]);
        const idxB = OrderedSet.indexOf(b4.bUnit.gapElements, b4.bUnit.elements[b4.bIndex]);
        if (idxA !== -1 && idxB !== -1) {
          if (apply(Interval.ofSingleton(unitIdx * groupCount + idxA)))
            changed = true;
        }
      }
    }
  } else if (element_exports.Loci.is(loci)) {
    const { structure, group } = structureGroup;
    if (!Structure.areRootsEquivalent(loci.structure, structure))
      return false;
    loci = element_exports.Loci.remap(loci, structure);
    const groupCount = group.units[0].gapElements.length;
    for (const e of loci.elements) {
      const unitIdx = group.unitIndexMap.get(e.unit.id);
      if (unitIdx !== void 0) {
        OrderedSet.forEach(e.indices, (v2) => {
          const idx = OrderedSet.indexOf(e.unit.gapElements, e.unit.elements[v2]);
          if (idx !== -1) {
            if (apply(Interval.ofSingleton(unitIdx * groupCount + idx)))
              changed = true;
            if (OrderedSet.getAt(e.unit.gapElements, idx + 1) === e.unit.elements[v2]) {
              if (apply(Interval.ofSingleton(unitIdx * groupCount + idx + 1)))
                changed = true;
            }
          }
        });
      }
    }
  }
  return changed;
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/nucleotide.js
var NucleotideLocationIterator;
(function(NucleotideLocationIterator2) {
  function fromGroup(structureGroup) {
    const { group, structure } = structureGroup;
    const u2 = group.units[0];
    const nucleotideElementIndices = Unit.isAtomic(u2) ? u2.nucleotideElements : [];
    const groupCount = nucleotideElementIndices.length;
    const instanceCount = group.units.length;
    const location = element_exports.Location.create(structure);
    const getLocation = (groupIndex, instanceIndex) => {
      const unit = group.units[instanceIndex];
      location.unit = unit;
      location.element = nucleotideElementIndices[groupIndex];
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  NucleotideLocationIterator2.fromGroup = fromGroup;
})(NucleotideLocationIterator || (NucleotideLocationIterator = {}));
function getNucleotideElementLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId, groupId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    if (Unit.isAtomic(unit)) {
      return getResidueLoci(structure, unit, unit.nucleotideElements[groupId]);
    }
  }
  return EmptyLoci;
}
function selectNuclotideElements(u2) {
  return u2.nucleotideElements;
}
function eachNucleotideElement(loci, structureGroup, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  const { structure, group } = structureGroup;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const unit = group.units[0];
  if (!Unit.isAtomic(unit))
    return false;
  const { nucleotideElements } = unit;
  const groupCount = nucleotideElements.length;
  for (const e of loci.elements) {
    if (!Unit.isAtomic(e.unit))
      continue;
    if (!group.unitIndexMap.has(e.unit.id))
      continue;
    const intervalOffset = group.unitIndexMap.get(e.unit.id) * groupCount;
    if (Unit.isAtomic(e.unit)) {
      changed = eachAtomicUnitTracedElement(intervalOffset, groupCount, selectNuclotideElements, apply, e) || changed;
    }
  }
  return changed;
}
var pC4 = Vec3();
var pN9 = Vec3();
function getNucleotideBaseType(unit, residueIndex) {
  const { model, conformation: c4 } = unit;
  const { residueAtomSegments, atoms, index: atomicIndex } = model.atomicHierarchy;
  const { label_comp_id } = atoms;
  const compId = label_comp_id.value(residueAtomSegments.offsets[residueIndex]);
  let isPurine = isPurineBase(compId);
  let isPyrimidine = isPyrimidineBase(compId);
  if (!isPurine && !isPyrimidine) {
    const idxC4 = atomicIndex.findAtomOnResidue(residueIndex, "C4");
    const idxN9 = atomicIndex.findAtomOnResidue(residueIndex, "N9");
    if (idxC4 !== -1 && idxN9 !== -1 && Vec3.distance(c4.invariantPosition(idxC4, pC4), c4.invariantPosition(idxN9, pN9)) < 1.6) {
      isPurine = true;
    } else {
      isPyrimidine = true;
    }
  }
  return { isPurine, isPyrimidine };
}
function createNucleicIndices() {
  return {
    trace: -1,
    N1: -1,
    C2: -1,
    N3: -1,
    C4: -1,
    C5: -1,
    C6: -1,
    N7: -1,
    C8: -1,
    N9: -1,
    C1_1: -1,
    C2_1: -1,
    C3_1: -1,
    C4_1: -1,
    O4_1: -1
  };
}
function setPurinIndices(idx, unit, residueIndex) {
  const atomicIndex = unit.model.atomicHierarchy.index;
  const { traceElementIndex } = unit.model.atomicHierarchy.derived.residue;
  idx.trace = traceElementIndex[residueIndex];
  idx.N1 = atomicIndex.findAtomOnResidue(residueIndex, "N1");
  idx.C2 = atomicIndex.findAtomOnResidue(residueIndex, "C2");
  idx.N3 = atomicIndex.findAtomOnResidue(residueIndex, "N3");
  idx.C4 = atomicIndex.findAtomOnResidue(residueIndex, "C4");
  idx.C5 = atomicIndex.findAtomOnResidue(residueIndex, "C5");
  if (idx.C5 === -1) {
    idx.C5 = atomicIndex.findAtomOnResidue(residueIndex, "N5");
  }
  idx.C6 = atomicIndex.findAtomOnResidue(residueIndex, "C6");
  idx.N7 = atomicIndex.findAtomOnResidue(residueIndex, "N7");
  if (idx.N7 === -1) {
    idx.N7 = atomicIndex.findAtomOnResidue(residueIndex, "C7");
  }
  idx.C8 = atomicIndex.findAtomOnResidue(residueIndex, "C8");
  idx.N9 = atomicIndex.findAtomOnResidue(residueIndex, "N9");
  return idx;
}
function hasPurinIndices(idx) {
  return idx.trace !== -1 && idx.N1 !== -1 && idx.C2 !== -1 && idx.N3 !== -1 && idx.C4 !== -1 && idx.C5 !== -1 && idx.C6 !== -1 && idx.N7 !== -1 && idx.C8 !== -1 && idx.N9 !== -1;
}
function setPyrimidineIndices(idx, unit, residueIndex) {
  const atomicIndex = unit.model.atomicHierarchy.index;
  const { traceElementIndex } = unit.model.atomicHierarchy.derived.residue;
  idx.trace = traceElementIndex[residueIndex];
  idx.N1 = atomicIndex.findAtomOnResidue(residueIndex, "N1");
  if (idx.N1 === -1) {
    idx.N1 = atomicIndex.findAtomOnResidue(residueIndex, "C1");
  }
  idx.C2 = atomicIndex.findAtomOnResidue(residueIndex, "C2");
  idx.N3 = atomicIndex.findAtomOnResidue(residueIndex, "N3");
  idx.C4 = atomicIndex.findAtomOnResidue(residueIndex, "C4");
  idx.C5 = atomicIndex.findAtomOnResidue(residueIndex, "C5");
  idx.C6 = atomicIndex.findAtomOnResidue(residueIndex, "C6");
  return idx;
}
function hasPyrimidineIndices(idx) {
  return idx.trace !== -1 && idx.N1 !== -1 && idx.C2 !== -1 && idx.N3 !== -1 && idx.C4 !== -1 && idx.C5 !== -1 && idx.C6 !== -1;
}
function setSugarIndices(idx, unit, residueIndex) {
  const atomicIndex = unit.model.atomicHierarchy.index;
  const { traceElementIndex } = unit.model.atomicHierarchy.derived.residue;
  idx.trace = traceElementIndex[residueIndex];
  idx.C1_1 = atomicIndex.findAtomOnResidue(residueIndex, "C1'");
  idx.C2_1 = atomicIndex.findAtomOnResidue(residueIndex, "C2'");
  idx.C3_1 = atomicIndex.findAtomOnResidue(residueIndex, "C3'");
  idx.C4_1 = atomicIndex.findAtomOnResidue(residueIndex, "C4'");
  idx.O4_1 = atomicIndex.findAtomOnResidue(residueIndex, "O4'");
  return idx;
}
function hasSugarIndices(idx) {
  return idx.trace !== -1 && idx.C1_1 !== -1 && idx.C2_1 !== -1 && idx.C3_1 !== -1 && idx.C4_1 !== -1 && idx.O4_1 !== -1;
}

// node_modules/molstar/lib/mol-repr/structure/visual/nucleotide-block-mesh.js
var p1 = Vec3();
var p2 = Vec3();
var p3 = Vec3();
var p4 = Vec3();
var p5 = Vec3();
var pt = Vec3();
var v12 = Vec3();
var v34 = Vec3();
var vC = Vec3();
var center = Vec3();
var t2 = Mat4.identity();
var sVec2 = Vec3();
var box2 = Box();
var NucleotideBlockMeshParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  thicknessFactor: ParamDefinition.Numeric(1, { min: 0, max: 2, step: 0.01 }),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo)
};
var DefaultNucleotideBlockMeshProps = ParamDefinition.getDefaultValues(NucleotideBlockMeshParams);
function createNucleotideBlockMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, thicknessFactor, radialSegments } = props;
  const vertexCount = nucleotideElementCount * (box2.vertices.length / 3 + radialSegments * 2);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 4, mesh);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  const radius = 1 * sizeFactor;
  const width = 4.5;
  const depth = thicknessFactor * sizeFactor * 2;
  const cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments, bottomCap: true };
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        let idx1 = -1, idx2 = -1, idx3 = -1, idx4 = -1, idx5 = -1;
        let height = 4.5;
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          height = 4.5;
          setPurinIndices(idx, unit, residueIndex);
          idx1 = idx.N1;
          idx2 = idx.C4;
          idx3 = idx.C6;
          idx4 = idx.C2;
          idx5 = idx.N9;
        } else if (isPyrimidine) {
          height = 3;
          setPyrimidineIndices(idx, unit, residueIndex);
          idx1 = idx.N3;
          idx2 = idx.C6;
          idx3 = idx.C4;
          idx4 = idx.C2;
          idx5 = idx.N1;
        }
        if (idx5 !== -1 && idx.trace !== -1) {
          c4.invariantPosition(idx5, p5);
          c4.invariantPosition(idx.trace, pt);
          builderState.currentGroup = i;
          addCylinder(builderState, p5, pt, 1, cylinderProps);
          if (idx1 !== -1 && idx2 !== -1 && idx3 !== -1 && idx4 !== -1) {
            c4.invariantPosition(idx1, p1);
            c4.invariantPosition(idx2, p2);
            c4.invariantPosition(idx3, p3);
            c4.invariantPosition(idx4, p4);
            Vec3.normalize(v12, Vec3.sub(v12, p2, p1));
            Vec3.normalize(v34, Vec3.sub(v34, p4, p3));
            Vec3.normalize(vC, Vec3.cross(vC, v12, v34));
            Mat4.targetTo(t2, p1, p2, vC);
            Vec3.scaleAndAdd(center, p1, v12, height / 2 - 0.2);
            Mat4.scale(t2, t2, Vec3.set(sVec2, width, depth, height));
            Mat4.setTranslation(t2, center);
            MeshBuilder.addPrimitive(builderState, t2, box2);
          }
        }
        ++i;
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, radius);
  m.setBoundingSphere(sphere);
  return m;
}
var NucleotideBlockParams = {
  ...UnitsMeshParams,
  ...NucleotideBlockMeshParams
};
function NucleotideBlockVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideBlockParams),
    createGeometry: createNucleotideBlockMesh,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.thicknessFactor !== currentProps.thicknessFactor || newProps.radialSegments !== currentProps.radialSegments;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/nucleotide-ring-mesh.js
var pTrace = Vec3();
var pN1 = Vec3();
var pC2 = Vec3();
var pN3 = Vec3();
var pC42 = Vec3();
var pC5 = Vec3();
var pC6 = Vec3();
var pN7 = Vec3();
var pC8 = Vec3();
var pN92 = Vec3();
var normal = Vec3();
var NucleotideRingMeshParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  thicknessFactor: ParamDefinition.Numeric(1, { min: 0, max: 2, step: 0.01 }),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo)
};
var DefaultNucleotideRingMeshProps = ParamDefinition.getDefaultValues(NucleotideRingMeshParams);
var positionsRing5_6 = new Float32Array(2 * 9 * 3);
var stripIndicesRing5_6 = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 14, 15, 12, 13, 8, 9, 10, 11, 0, 1]);
var fanIndicesTopRing5_6 = new Uint32Array([8, 12, 14, 16, 6, 4, 2, 0, 10]);
var fanIndicesBottomRing5_6 = new Uint32Array([9, 11, 1, 3, 5, 7, 17, 15, 13]);
var positionsRing6 = new Float32Array(2 * 6 * 3);
var stripIndicesRing6 = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1]);
var fanIndicesTopRing6 = new Uint32Array([0, 10, 8, 6, 4, 2]);
var fanIndicesBottomRing6 = new Uint32Array([1, 3, 5, 7, 9, 11]);
var tmpShiftV = Vec3();
function shiftPositions(out, dir, ...positions) {
  for (let i = 0, il = positions.length; i < il; ++i) {
    const v2 = positions[i];
    Vec3.toArray(Vec3.add(tmpShiftV, v2, dir), out, i * 2 * 3);
    Vec3.toArray(Vec3.sub(tmpShiftV, v2, dir), out, (i * 2 + 1) * 3);
  }
}
function createNucleotideRingMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, thicknessFactor, radialSegments, detail } = props;
  const vertexCount = nucleotideElementCount * (26 + radialSegments * 2);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 4, mesh);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  const radius = 1 * sizeFactor;
  const thickness = thicknessFactor * sizeFactor;
  const cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments };
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        builderState.currentGroup = i;
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (idx.N9 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N9, pN92);
            c4.invariantPosition(idx.trace, pTrace);
            builderState.currentGroup = i;
            addCylinder(builderState, pN92, pTrace, 1, cylinderProps);
            addSphere(builderState, pN92, radius, detail);
          }
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN1);
            c4.invariantPosition(idx.C2, pC2);
            c4.invariantPosition(idx.N3, pN3);
            c4.invariantPosition(idx.C4, pC42);
            c4.invariantPosition(idx.C5, pC5);
            c4.invariantPosition(idx.C6, pC6);
            c4.invariantPosition(idx.N7, pN7);
            c4.invariantPosition(idx.C8, pC8);
            Vec3.triangleNormal(normal, pN1, pC42, pC5);
            Vec3.scale(normal, normal, thickness);
            shiftPositions(positionsRing5_6, normal, pN1, pC2, pN3, pC42, pC5, pC6, pN7, pC8, pN92);
            MeshBuilder.addTriangleStrip(builderState, positionsRing5_6, stripIndicesRing5_6);
            MeshBuilder.addTriangleFan(builderState, positionsRing5_6, fanIndicesTopRing5_6);
            MeshBuilder.addTriangleFan(builderState, positionsRing5_6, fanIndicesBottomRing5_6);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (idx.N1 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N1, pN1);
            c4.invariantPosition(idx.trace, pTrace);
            builderState.currentGroup = i;
            addCylinder(builderState, pN1, pTrace, 1, cylinderProps);
            addSphere(builderState, pN1, radius, detail);
          }
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.C2, pC2);
            c4.invariantPosition(idx.N3, pN3);
            c4.invariantPosition(idx.C4, pC42);
            c4.invariantPosition(idx.C5, pC5);
            c4.invariantPosition(idx.C6, pC6);
            Vec3.triangleNormal(normal, pN1, pC42, pC5);
            Vec3.scale(normal, normal, thickness);
            shiftPositions(positionsRing6, normal, pN1, pC2, pN3, pC42, pC5, pC6);
            MeshBuilder.addTriangleStrip(builderState, positionsRing6, stripIndicesRing6);
            MeshBuilder.addTriangleFan(builderState, positionsRing6, fanIndicesTopRing6);
            MeshBuilder.addTriangleFan(builderState, positionsRing6, fanIndicesBottomRing6);
          }
        }
        ++i;
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, radius);
  m.setBoundingSphere(sphere);
  return m;
}
var NucleotideRingParams = {
  ...UnitsMeshParams,
  ...NucleotideRingMeshParams
};
function NucleotideRingVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideRingParams),
    createGeometry: createNucleotideRingMesh,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.thicknessFactor !== currentProps.thicknessFactor || newProps.radialSegments !== currentProps.radialSegments;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/nucleotide-atomic-ring-fill.js
var pN12 = Vec3();
var pC22 = Vec3();
var pN32 = Vec3();
var pC43 = Vec3();
var pC52 = Vec3();
var pC62 = Vec3();
var pN72 = Vec3();
var pC82 = Vec3();
var pN93 = Vec3();
var pC1_1 = Vec3();
var pC2_1 = Vec3();
var pC3_1 = Vec3();
var pC4_1 = Vec3();
var pO4_1 = Vec3();
var mid = Vec3();
var normal2 = Vec3();
var shift = Vec3();
var NucleotideAtomicRingFillMeshParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  thicknessFactor: ParamDefinition.Numeric(1, { min: 0, max: 2, step: 0.01 })
};
var DefaultNucleotideAtomicRingFillMeshProps = ParamDefinition.getDefaultValues(NucleotideAtomicRingFillMeshParams);
var positionsRing5_62 = new Float32Array(2 * 9 * 3);
var stripIndicesRing5_62 = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 14, 15, 12, 13, 8, 9, 10, 11, 0, 1]);
var fanIndicesTopRing5_62 = new Uint32Array([8, 12, 14, 16, 6, 4, 2, 0, 10]);
var fanIndicesBottomRing5_62 = new Uint32Array([9, 11, 1, 3, 5, 7, 17, 15, 13]);
var positionsRing5 = new Float32Array(2 * 6 * 3);
var stripIndicesRing5 = new Uint32Array([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 2, 3]);
var fanIndicesTopRing5 = new Uint32Array([0, 10, 8, 6, 4, 2, 10]);
var fanIndicesBottomRing5 = new Uint32Array([1, 3, 5, 7, 9, 11, 3]);
var positionsRing62 = new Float32Array(2 * 6 * 3);
var stripIndicesRing62 = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1]);
var fanIndicesTopRing62 = new Uint32Array([0, 10, 8, 6, 4, 2]);
var fanIndicesBottomRing62 = new Uint32Array([1, 3, 5, 7, 9, 11]);
var tmpShiftV2 = Vec3();
function shiftPositions2(out, dir, ...positions) {
  for (let i = 0, il = positions.length; i < il; ++i) {
    const v2 = positions[i];
    Vec3.toArray(Vec3.add(tmpShiftV2, v2, dir), out, i * 2 * 3);
    Vec3.toArray(Vec3.sub(tmpShiftV2, v2, dir), out, (i * 2 + 1) * 3);
  }
}
function createNucleotideAtomicRingFillMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, thicknessFactor } = props;
  const vertexCount = nucleotideElementCount * 25;
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 4, mesh);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  const thickness = sizeFactor * thicknessFactor;
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        builderState.currentGroup = i;
        setSugarIndices(idx, unit, residueIndex);
        if (hasSugarIndices(idx)) {
          c4.invariantPosition(idx.C1_1, pC1_1);
          c4.invariantPosition(idx.C2_1, pC2_1);
          c4.invariantPosition(idx.C3_1, pC3_1);
          c4.invariantPosition(idx.C4_1, pC4_1);
          c4.invariantPosition(idx.O4_1, pO4_1);
          Vec3.triangleNormal(normal2, pC3_1, pC4_1, pC1_1);
          Vec3.scale(
            mid,
            Vec3.add(mid, pO4_1, Vec3.add(mid, pC4_1, Vec3.add(mid, pC3_1, Vec3.add(mid, pC1_1, pC2_1)))),
            0.2
            /* 1 / 5 */
          );
          Vec3.scale(shift, normal2, thickness);
          shiftPositions2(positionsRing5, shift, mid, pC3_1, pC4_1, pO4_1, pC1_1, pC2_1);
          MeshBuilder.addTriangleStrip(builderState, positionsRing5, stripIndicesRing5);
          MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing5, fanIndicesTopRing5, normal2);
          Vec3.negate(normal2, normal2);
          MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing5, fanIndicesBottomRing5, normal2);
        }
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN12);
            c4.invariantPosition(idx.C2, pC22);
            c4.invariantPosition(idx.N3, pN32);
            c4.invariantPosition(idx.C4, pC43);
            c4.invariantPosition(idx.C5, pC52);
            c4.invariantPosition(idx.C6, pC62);
            c4.invariantPosition(idx.N7, pN72);
            c4.invariantPosition(idx.C8, pC82), c4.invariantPosition(idx.N9, pN93);
            Vec3.triangleNormal(normal2, pN12, pC43, pC52);
            Vec3.scale(shift, normal2, thickness);
            shiftPositions2(positionsRing5_62, shift, pN12, pC22, pN32, pC43, pC52, pC62, pN72, pC82, pN93);
            MeshBuilder.addTriangleStrip(builderState, positionsRing5_62, stripIndicesRing5_62);
            MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing5_62, fanIndicesTopRing5_62, normal2);
            Vec3.negate(normal2, normal2);
            MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing5_62, fanIndicesBottomRing5_62, normal2);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.N1, pN12);
            c4.invariantPosition(idx.C2, pC22);
            c4.invariantPosition(idx.N3, pN32);
            c4.invariantPosition(idx.C4, pC43);
            c4.invariantPosition(idx.C5, pC52);
            c4.invariantPosition(idx.C6, pC62);
            Vec3.triangleNormal(normal2, pN12, pC43, pC52);
            Vec3.scale(shift, normal2, thickness);
            shiftPositions2(positionsRing62, shift, pN12, pC22, pN32, pC43, pC52, pC62);
            MeshBuilder.addTriangleStrip(builderState, positionsRing62, stripIndicesRing62);
            MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing62, fanIndicesTopRing62, normal2);
            Vec3.negate(normal2, normal2);
            MeshBuilder.addTriangleFanWithNormal(builderState, positionsRing62, fanIndicesBottomRing62, normal2);
          }
        }
        ++i;
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, thickness);
  m.setBoundingSphere(sphere);
  return m;
}
var NucleotideAtomicRingFillParams = {
  ...UnitsMeshParams,
  ...NucleotideAtomicRingFillMeshParams
};
function NucleotideAtomicRingFillVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideAtomicRingFillParams),
    createGeometry: createNucleotideAtomicRingFillMesh,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.thicknessFactor !== currentProps.thicknessFactor;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/nucleotide-atomic-bond.js
var pTrace2 = Vec3();
var pN13 = Vec3();
var pC23 = Vec3();
var pN33 = Vec3();
var pC44 = Vec3();
var pC53 = Vec3();
var pC63 = Vec3();
var pN73 = Vec3();
var pC83 = Vec3();
var pN94 = Vec3();
var pC1_12 = Vec3();
var pC2_12 = Vec3();
var pC3_12 = Vec3();
var pC4_12 = Vec3();
var pO4_12 = Vec3();
var NucleotideAtomicBondParams = {
  ...UnitsMeshParams,
  ...UnitsCylindersParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo),
  tryUseImpostor: ParamDefinition.Boolean(true)
};
function NucleotideAtomicBondVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? NucleotideAtomicBondImpostorVisual(materialId) : NucleotideAtomicBondMeshVisual(materialId);
}
function createNucleotideAtomicBondImpostor(ctx, unit, structure, theme, props, cylinders) {
  if (!Unit.isAtomic(unit))
    return Cylinders.createEmpty(cylinders);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Cylinders.createEmpty(cylinders);
  const cylindersCountEstimate = nucleotideElementCount * 15;
  const builder = CylindersBuilder.create(cylindersCountEstimate, cylindersCountEstimate / 4, cylinders);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  let i = 0;
  const colorModeFlag = 2;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        setSugarIndices(idx, unit, residueIndex);
        if (hasSugarIndices(idx)) {
          c4.invariantPosition(idx.C1_1, pC1_12);
          c4.invariantPosition(idx.C2_1, pC2_12);
          c4.invariantPosition(idx.C3_1, pC3_12);
          c4.invariantPosition(idx.C4_1, pC4_12);
          c4.invariantPosition(idx.O4_1, pO4_12);
          c4.invariantPosition(idx.trace, pTrace2);
          builder.add(pC3_12[0], pC3_12[1], pC3_12[2], pTrace2[0], pTrace2[1], pTrace2[2], 1, true, true, colorModeFlag, i);
          builder.add(pC3_12[0], pC3_12[1], pC3_12[2], pC4_12[0], pC4_12[1], pC4_12[2], 1, true, true, colorModeFlag, i);
          builder.add(pC4_12[0], pC4_12[1], pC4_12[2], pO4_12[0], pO4_12[1], pO4_12[2], 1, true, true, colorModeFlag, i);
          builder.add(pO4_12[0], pO4_12[1], pO4_12[2], pC1_12[0], pC1_12[1], pC1_12[2], 1, true, true, colorModeFlag, i);
          builder.add(pC1_12[0], pC1_12[1], pC1_12[2], pC2_12[0], pC2_12[1], pC2_12[2], 1, true, true, colorModeFlag, i);
          builder.add(pC2_12[0], pC2_12[1], pC2_12[2], pC3_12[0], pC3_12[1], pC3_12[2], 1, true, true, colorModeFlag, i);
        }
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (idx.C1_1 !== -1 && idx.N9 !== -1) {
            c4.invariantPosition(idx.C1_1, pC1_12);
            c4.invariantPosition(idx.N9, pN94);
            builder.add(pN94[0], pN94[1], pN94[2], pC1_12[0], pC1_12[1], pC1_12[2], 1, true, true, colorModeFlag, i);
          } else if (idx.N9 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N9, pN94);
            c4.invariantPosition(idx.trace, pTrace2);
            builder.add(pN94[0], pN94[1], pN94[2], pTrace2[0], pTrace2[1], pTrace2[2], 1, true, true, colorModeFlag, i);
          }
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C2, pC23);
            c4.invariantPosition(idx.N3, pN33);
            c4.invariantPosition(idx.C4, pC44);
            c4.invariantPosition(idx.C5, pC53);
            c4.invariantPosition(idx.C6, pC63);
            c4.invariantPosition(idx.N7, pN73);
            c4.invariantPosition(idx.C8, pC83);
            c4.invariantPosition(idx.N9, pN94);
            builder.add(pN94[0], pN94[1], pN94[2], pC83[0], pC83[1], pC83[2], 1, true, true, colorModeFlag, i);
            builder.add(pC83[0], pC83[1], pC83[2], pN73[0], pN73[1], pN73[2], 1, true, true, colorModeFlag, i);
            builder.add(pN73[0], pN73[1], pN73[2], pC53[0], pC53[1], pC53[2], 1, true, true, colorModeFlag, i);
            builder.add(pC53[0], pC53[1], pC53[2], pC63[0], pC63[1], pC63[2], 1, true, true, colorModeFlag, i);
            builder.add(pC63[0], pC63[1], pC63[2], pN13[0], pN13[1], pN13[2], 1, true, true, colorModeFlag, i);
            builder.add(pN13[0], pN13[1], pN13[2], pC23[0], pC23[1], pC23[2], 1, true, true, colorModeFlag, i);
            builder.add(pC23[0], pC23[1], pC23[2], pN33[0], pN33[1], pN33[2], 1, true, true, colorModeFlag, i);
            builder.add(pN33[0], pN33[1], pN33[2], pC44[0], pC44[1], pC44[2], 1, true, true, colorModeFlag, i);
            builder.add(pC44[0], pC44[1], pC44[2], pC53[0], pC53[1], pC53[2], 1, true, true, colorModeFlag, i);
            builder.add(pC44[0], pC44[1], pC44[2], pN94[0], pN94[1], pN94[2], 1, true, true, colorModeFlag, i);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (idx.C1_1 !== -1 && idx.N1 !== -1) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C1_1, pC1_12);
            builder.add(pN13[0], pN13[1], pN13[2], pC1_12[0], pC1_12[1], pC1_12[2], 1, true, true, colorModeFlag, i);
          } else if (idx.N1 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.trace, pTrace2);
            builder.add(pN13[0], pN13[1], pN13[2], pTrace2[0], pTrace2[1], pTrace2[2], 1, true, true, colorModeFlag, i);
          }
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C2, pC23);
            c4.invariantPosition(idx.N3, pN33);
            c4.invariantPosition(idx.C4, pC44);
            c4.invariantPosition(idx.C5, pC53);
            c4.invariantPosition(idx.C6, pC63);
            builder.add(pN13[0], pN13[1], pN13[2], pC63[0], pC63[1], pC63[2], 1, true, true, colorModeFlag, i);
            builder.add(pC63[0], pC63[1], pC63[2], pC53[0], pC53[1], pC53[2], 1, true, true, colorModeFlag, i);
            builder.add(pC53[0], pC53[1], pC53[2], pC44[0], pC44[1], pC44[2], 1, true, true, colorModeFlag, i);
            builder.add(pC44[0], pC44[1], pC44[2], pN33[0], pN33[1], pN33[2], 1, true, true, colorModeFlag, i);
            builder.add(pN33[0], pN33[1], pN33[2], pC23[0], pC23[1], pC23[2], 1, true, true, colorModeFlag, i);
            builder.add(pC23[0], pC23[1], pC23[2], pN13[0], pN13[1], pN13[2], 1, true, true, colorModeFlag, i);
          }
        }
        ++i;
      }
    }
  }
  const cy = builder.getCylinders();
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  cy.setBoundingSphere(sphere);
  return cy;
}
function NucleotideAtomicBondImpostorVisual(materialId) {
  return UnitsCylindersVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideAtomicBondParams),
    createGeometry: createNucleotideAtomicBondImpostor,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function createNucleotideAtomicBondMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, radialSegments } = props;
  const vertexCount = nucleotideElementCount * (radialSegments * 15);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 4, mesh);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  const cylinderProps = { radiusTop: 1 * sizeFactor, radiusBottom: 1 * sizeFactor, radialSegments };
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        builderState.currentGroup = i;
        setSugarIndices(idx, unit, residueIndex);
        if (hasSugarIndices(idx)) {
          c4.invariantPosition(idx.C1_1, pC1_12);
          c4.invariantPosition(idx.C2_1, pC2_12);
          c4.invariantPosition(idx.C3_1, pC3_12);
          c4.invariantPosition(idx.C4_1, pC4_12);
          c4.invariantPosition(idx.O4_1, pO4_12);
          c4.invariantPosition(idx.trace, pTrace2);
          addCylinder(builderState, pC3_12, pTrace2, 1, cylinderProps);
          addCylinder(builderState, pC3_12, pC4_12, 1, cylinderProps);
          addCylinder(builderState, pC4_12, pO4_12, 1, cylinderProps);
          addCylinder(builderState, pO4_12, pC1_12, 1, cylinderProps);
          addCylinder(builderState, pC1_12, pC2_12, 1, cylinderProps);
          addCylinder(builderState, pC2_12, pC3_12, 1, cylinderProps);
        }
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (idx.C1_1 !== -1 && idx.N9 !== -1) {
            c4.invariantPosition(idx.C1_1, pC1_12);
            c4.invariantPosition(idx.N9, pN94);
            addCylinder(builderState, pN94, pC1_12, 1, cylinderProps);
          } else if (idx.N9 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N9, pN94);
            c4.invariantPosition(idx.trace, pTrace2);
            addCylinder(builderState, pN94, pTrace2, 1, cylinderProps);
          }
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C2, pC23);
            c4.invariantPosition(idx.N3, pN33);
            c4.invariantPosition(idx.C4, pC44);
            c4.invariantPosition(idx.C5, pC53);
            c4.invariantPosition(idx.C6, pC63);
            c4.invariantPosition(idx.N7, pN73);
            c4.invariantPosition(idx.C8, pC83);
            c4.invariantPosition(idx.N9, pN94);
            addCylinder(builderState, pN94, pC83, 1, cylinderProps);
            addCylinder(builderState, pC83, pN73, 1, cylinderProps);
            addCylinder(builderState, pN73, pC53, 1, cylinderProps);
            addCylinder(builderState, pC53, pC63, 1, cylinderProps);
            addCylinder(builderState, pC63, pN13, 1, cylinderProps);
            addCylinder(builderState, pN13, pC23, 1, cylinderProps);
            addCylinder(builderState, pC23, pN33, 1, cylinderProps);
            addCylinder(builderState, pN33, pC44, 1, cylinderProps);
            addCylinder(builderState, pC44, pC53, 1, cylinderProps);
            addCylinder(builderState, pC44, pN94, 1, cylinderProps);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (idx.C1_1 !== -1 && idx.N1 !== -1) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C1_1, pC1_12);
            addCylinder(builderState, pN13, pC1_12, 1, cylinderProps);
          } else if (idx.N1 !== -1 && idx.trace !== -1) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.trace, pTrace2);
            addCylinder(builderState, pN13, pTrace2, 1, cylinderProps);
          }
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.N1, pN13);
            c4.invariantPosition(idx.C2, pC23);
            c4.invariantPosition(idx.N3, pN33);
            c4.invariantPosition(idx.C4, pC44);
            c4.invariantPosition(idx.C5, pC53);
            c4.invariantPosition(idx.C6, pC63);
            addCylinder(builderState, pN13, pC63, 1, cylinderProps);
            addCylinder(builderState, pC63, pC53, 1, cylinderProps);
            addCylinder(builderState, pC53, pC44, 1, cylinderProps);
            addCylinder(builderState, pC44, pN33, 1, cylinderProps);
            addCylinder(builderState, pN33, pC23, 1, cylinderProps);
            addCylinder(builderState, pC23, pN13, 1, cylinderProps);
          }
        }
        ++i;
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
function NucleotideAtomicBondMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideAtomicBondParams),
    createGeometry: createNucleotideAtomicBondMesh,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.radialSegments !== currentProps.radialSegments;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/nucleotide-atomic-element.js
var pTrace3 = Vec3();
var pN14 = Vec3();
var pC24 = Vec3();
var pN34 = Vec3();
var pC45 = Vec3();
var pC54 = Vec3();
var pC64 = Vec3();
var pN74 = Vec3();
var pC84 = Vec3();
var pN95 = Vec3();
var pC1_13 = Vec3();
var pC2_13 = Vec3();
var pC3_13 = Vec3();
var pC4_13 = Vec3();
var pO4_13 = Vec3();
var NucleotideAtomicElementParams = {
  ...UnitsMeshParams,
  ...UnitsSpheresParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  tryUseImpostor: ParamDefinition.Boolean(true)
};
function NucleotideAtomicElementVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? NucleotideAtomicElementImpostorVisual(materialId) : NucleotideAtomicElementMeshVisual(materialId);
}
function createNucleotideAtomicElementImpostor(ctx, unit, structure, theme, props, spheres) {
  if (!Unit.isAtomic(unit))
    return Spheres.createEmpty(spheres);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Spheres.createEmpty(spheres);
  const spheresCountEstimate = nucleotideElementCount * 15;
  const builder = SpheresBuilder.create(spheresCountEstimate, spheresCountEstimate / 4, spheres);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        setSugarIndices(idx, unit, residueIndex);
        if (hasSugarIndices(idx)) {
          c4.invariantPosition(idx.C1_1, pC1_13);
          c4.invariantPosition(idx.C2_1, pC2_13);
          c4.invariantPosition(idx.C3_1, pC3_13);
          c4.invariantPosition(idx.C4_1, pC4_13);
          c4.invariantPosition(idx.O4_1, pO4_13);
          c4.invariantPosition(idx.trace, pTrace3);
          builder.add(pTrace3[0], pTrace3[1], pTrace3[2], i);
          builder.add(pC3_13[0], pC3_13[1], pC3_13[2], i);
          builder.add(pC4_13[0], pC4_13[1], pC4_13[2], i);
          builder.add(pO4_13[0], pO4_13[1], pO4_13[2], i);
          builder.add(pC1_13[0], pC1_13[1], pC1_13[2], i);
          builder.add(pC2_13[0], pC2_13[1], pC2_13[2], i);
        }
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN14);
            c4.invariantPosition(idx.C2, pC24);
            c4.invariantPosition(idx.N3, pN34);
            c4.invariantPosition(idx.C4, pC45);
            c4.invariantPosition(idx.C5, pC54);
            c4.invariantPosition(idx.C6, pC64);
            c4.invariantPosition(idx.N7, pN74);
            c4.invariantPosition(idx.C8, pC84);
            c4.invariantPosition(idx.N9, pN95);
            builder.add(pN95[0], pN95[1], pN95[2], i);
            builder.add(pC84[0], pC84[1], pC84[2], i);
            builder.add(pN74[0], pN74[1], pN74[2], i);
            builder.add(pC54[0], pC54[1], pC54[2], i);
            builder.add(pC64[0], pC64[1], pC64[2], i);
            builder.add(pN14[0], pN14[1], pN14[2], i);
            builder.add(pC24[0], pC24[1], pC24[2], i);
            builder.add(pN34[0], pN34[1], pN34[2], i);
            builder.add(pC45[0], pC45[1], pC45[2], i);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.N1, pN14);
            c4.invariantPosition(idx.C2, pC24);
            c4.invariantPosition(idx.N3, pN34);
            c4.invariantPosition(idx.C4, pC45);
            c4.invariantPosition(idx.C5, pC54);
            c4.invariantPosition(idx.C6, pC64);
            builder.add(pN14[0], pN14[1], pN14[2], i);
            builder.add(pC64[0], pC64[1], pC64[2], i);
            builder.add(pC54[0], pC54[1], pC54[2], i);
            builder.add(pC45[0], pC45[1], pC45[2], i);
            builder.add(pN34[0], pN34[1], pN34[2], i);
            builder.add(pC24[0], pC24[1], pC24[2], i);
          }
        }
        ++i;
      }
    }
  }
  const s = builder.getSpheres();
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  s.setBoundingSphere(sphere);
  return s;
}
function NucleotideAtomicElementImpostorVisual(materialId) {
  return UnitsSpheresVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideAtomicElementParams),
    createGeometry: createNucleotideAtomicElementImpostor,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function createNucleotideAtomicElementMesh(ctx, unit, structure, theme, props, mesh) {
  if (!Unit.isAtomic(unit))
    return Mesh.createEmpty(mesh);
  const nucleotideElementCount = unit.nucleotideElements.length;
  if (!nucleotideElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, detail } = props;
  const vertexCount = nucleotideElementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const { elements, model, conformation: c4 } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  const radius = 1 * sizeFactor;
  let i = 0;
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index: residueIndex } = residueIt.move();
      if (isNucleic(moleculeType[residueIndex])) {
        const idx = createNucleicIndices();
        builderState.currentGroup = i;
        setSugarIndices(idx, unit, residueIndex);
        if (hasSugarIndices(idx)) {
          c4.invariantPosition(idx.C1_1, pC1_13);
          c4.invariantPosition(idx.C2_1, pC2_13);
          c4.invariantPosition(idx.C3_1, pC3_13);
          c4.invariantPosition(idx.C4_1, pC4_13);
          c4.invariantPosition(idx.O4_1, pO4_13);
          c4.invariantPosition(idx.trace, pTrace3);
          addSphere(builderState, pTrace3, radius, detail);
          addSphere(builderState, pC4_13, radius, detail);
          addSphere(builderState, pO4_13, radius, detail);
          addSphere(builderState, pC1_13, radius, detail);
          addSphere(builderState, pC2_13, radius, detail);
          addSphere(builderState, pC3_13, radius, detail);
        }
        const { isPurine, isPyrimidine } = getNucleotideBaseType(unit, residueIndex);
        if (isPurine) {
          setPurinIndices(idx, unit, residueIndex);
          if (hasPurinIndices(idx)) {
            c4.invariantPosition(idx.N1, pN14);
            c4.invariantPosition(idx.C2, pC24);
            c4.invariantPosition(idx.N3, pN34);
            c4.invariantPosition(idx.C4, pC45);
            c4.invariantPosition(idx.C5, pC54);
            c4.invariantPosition(idx.C6, pC64);
            c4.invariantPosition(idx.N7, pN74);
            c4.invariantPosition(idx.C8, pC84);
            c4.invariantPosition(idx.N9, pN95);
            addSphere(builderState, pC84, radius, detail);
            addSphere(builderState, pN74, radius, detail);
            addSphere(builderState, pC54, radius, detail);
            addSphere(builderState, pC64, radius, detail);
            addSphere(builderState, pN14, radius, detail);
            addSphere(builderState, pC24, radius, detail);
            addSphere(builderState, pN34, radius, detail);
            addSphere(builderState, pC45, radius, detail);
            addSphere(builderState, pC54, radius, detail);
            addSphere(builderState, pN95, radius, detail);
          }
        } else if (isPyrimidine) {
          setPyrimidineIndices(idx, unit, residueIndex);
          if (hasPyrimidineIndices(idx)) {
            c4.invariantPosition(idx.N1, pN14);
            c4.invariantPosition(idx.C2, pC24);
            c4.invariantPosition(idx.N3, pN34);
            c4.invariantPosition(idx.C4, pC45);
            c4.invariantPosition(idx.C5, pC54);
            c4.invariantPosition(idx.C6, pC64);
            addSphere(builderState, pC64, radius, detail);
            addSphere(builderState, pC54, radius, detail);
            addSphere(builderState, pC45, radius, detail);
            addSphere(builderState, pN34, radius, detail);
            addSphere(builderState, pC24, radius, detail);
            addSphere(builderState, pN14, radius, detail);
          }
        }
        ++i;
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
function NucleotideAtomicElementMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(NucleotideAtomicElementParams),
    createGeometry: createNucleotideAtomicElementMesh,
    createLocationIterator: NucleotideLocationIterator.fromGroup,
    getLoci: getNucleotideElementLoci,
    eachLocation: eachNucleotideElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-geo/primitive/wedge.js
var a3 = Vec3.zero();
var b3 = Vec3.zero();
var c3 = Vec3.zero();
var d2 = Vec3.zero();
var points = polygon(3, false);
function createWedge() {
  const builder = PrimitiveBuilder(8);
  for (let i = 0; i < 3; ++i) {
    const ni = (i + 1) % 3;
    Vec3.set(a3, points[i * 3], points[i * 3 + 1], -0.5);
    Vec3.set(b3, points[ni * 3], points[ni * 3 + 1], -0.5);
    Vec3.set(c3, points[ni * 3], points[ni * 3 + 1], 0.5);
    Vec3.set(d2, points[i * 3], points[i * 3 + 1], 0.5);
    builder.add(a3, b3, c3);
    builder.add(c3, d2, a3);
  }
  Vec3.set(a3, points[0], points[1], -0.5);
  Vec3.set(b3, points[3], points[4], -0.5);
  Vec3.set(c3, points[6], points[7], -0.5);
  builder.add(c3, b3, a3);
  Vec3.set(a3, points[0], points[1], 0.5);
  Vec3.set(b3, points[3], points[4], 0.5);
  Vec3.set(c3, points[6], points[7], 0.5);
  builder.add(a3, b3, c3);
  return builder.getPrimitive();
}
var wedge;
function Wedge() {
  if (!wedge)
    wedge = createWedge();
  return wedge;
}

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-direction-wedge.js
var t3 = Mat4.identity();
var sVec3 = Vec3.zero();
var n0 = Vec3.zero();
var n1 = Vec3.zero();
var upVec = Vec3.zero();
var depthFactor = 4;
var widthFactor = 4;
var heightFactor = 6;
var wedge2 = Wedge();
var PolymerDirectionWedgeParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 })
};
var DefaultPolymerDirectionWedgeProps = ParamDefinition.getDefaultValues(PolymerDirectionWedgeParams);
function createPolymerDirectionWedgeMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor } = props;
  const vertexCount = polymerElementCount * 24;
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 10, mesh);
  const linearSegments = 1;
  const state = createCurveSegmentState(linearSegments);
  const { normalVectors, binormalVectors } = state;
  let i = 0;
  const polymerTraceIt = PolymerTraceIterator(unit, structure);
  while (polymerTraceIt.hasNext) {
    const v2 = polymerTraceIt.move();
    builderState.currentGroup = i;
    const isNucleicType = isNucleic(v2.moleculeType);
    const isSheet = SecondaryStructureType.is(v2.secStrucType, SecondaryStructureType.Flag.Beta);
    const tension = isNucleicType || isSheet ? 0.5 : 0.9;
    const shift2 = isNucleicType ? 0.3 : 0.5;
    interpolateCurveSegment(state, v2, tension, shift2);
    if (isSheet && !v2.secStrucLast || !isSheet) {
      const size = theme.size.size(v2.center) * sizeFactor;
      const depth = depthFactor * size;
      const width = widthFactor * size;
      const height = heightFactor * size;
      const vectors = isNucleicType ? binormalVectors : normalVectors;
      Vec3.fromArray(n0, vectors, 0);
      Vec3.fromArray(n1, vectors, 3);
      Vec3.normalize(upVec, Vec3.add(upVec, n0, n1));
      Mat4.targetTo(t3, v2.p3, v2.p1, upVec);
      Mat4.mul(t3, t3, Mat4.rotY90Z180);
      Mat4.scale(t3, t3, Vec3.set(sVec3, height, width, depth));
      Mat4.setTranslation(t3, v2.p2);
      MeshBuilder.addPrimitive(builderState, t3, wedge2);
    }
    ++i;
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
var PolymerDirectionParams = {
  ...UnitsMeshParams,
  ...PolymerDirectionWedgeParams
};
function PolymerDirectionVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerDirectionParams),
    createGeometry: createPolymerDirectionWedgeMesh,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-gap-cylinder.js
var segmentCount = 10;
var PolymerGapCylinderParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo)
};
var DefaultPolymerGapCylinderProps = ParamDefinition.getDefaultValues(PolymerGapCylinderParams);
function createPolymerGapCylinderMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerGapCount = unit.gapElements.length;
  if (!polymerGapCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, radialSegments } = props;
  const vertexCountEstimate = segmentCount * radialSegments * 2 * polymerGapCount * 2;
  const builderState = MeshBuilder.createState(vertexCountEstimate, vertexCountEstimate / 10, mesh);
  const pA = Vec3();
  const pB = Vec3();
  const cylinderProps = {
    radiusTop: 1,
    radiusBottom: 1,
    topCap: true,
    bottomCap: true,
    radialSegments
  };
  let i = 0;
  const polymerGapIt = PolymerGapIterator(structure, unit);
  while (polymerGapIt.hasNext) {
    const { centerA, centerB } = polymerGapIt.move();
    if (centerA.element === centerB.element) {
    } else {
      unit.conformation.invariantPosition(centerA.element, pA);
      unit.conformation.invariantPosition(centerB.element, pB);
      cylinderProps.radiusTop = cylinderProps.radiusBottom = theme.size.size(centerA) * sizeFactor;
      builderState.currentGroup = i;
      addFixedCountDashedCylinder(builderState, pA, pB, 0.5, segmentCount, false, cylinderProps);
      cylinderProps.radiusTop = cylinderProps.radiusBottom = theme.size.size(centerB) * sizeFactor;
      builderState.currentGroup = i + 1;
      addFixedCountDashedCylinder(builderState, pB, pA, 0.5, segmentCount, false, cylinderProps);
    }
    i += 2;
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
var PolymerGapParams = {
  ...UnitsMeshParams,
  ...PolymerGapCylinderParams
};
function PolymerGapVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerGapParams),
    createGeometry: createPolymerGapCylinderMesh,
    createLocationIterator: (structureGroup) => PolymerGapLocationIterator.fromGroup(structureGroup, { asSecondary: true }),
    getLoci: getPolymerGapElementLoci,
    eachLocation: eachPolymerGapElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.radialSegments !== currentProps.radialSegments;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-geo/geometry/mesh/builder/sheet.js
var tA = Vec3();
var tB = Vec3();
var tV = Vec3();
var horizontalVector = Vec3();
var verticalVector = Vec3();
var verticalRightVector = Vec3();
var verticalLeftVector = Vec3();
var normalOffset = Vec3();
var positionVector = Vec3();
var normalVector = Vec3();
var torsionVector = Vec3();
var p12 = Vec3();
var p22 = Vec3();
var p32 = Vec3();
var p42 = Vec3();
var v3fromArray2 = Vec3.fromArray;
var v3scale2 = Vec3.scale;
var v3add3 = Vec3.add;
var v3sub2 = Vec3.sub;
var v3magnitude = Vec3.magnitude;
var v3negate = Vec3.negate;
var v3copy2 = Vec3.copy;
var v3cross2 = Vec3.cross;
var v3set = Vec3.set;
var caAdd3 = ChunkedArray.add3;
var caAdd = ChunkedArray.add;
function addCap(offset, state, controlPoints, normalVectors, binormalVectors, width, leftHeight, rightHeight, flip) {
  const { vertices, normals, indices } = state;
  const vertexCount = vertices.elementCount;
  v3fromArray2(tA, normalVectors, offset);
  v3scale2(verticalLeftVector, tA, leftHeight);
  v3scale2(verticalRightVector, tA, rightHeight);
  v3fromArray2(tB, binormalVectors, offset);
  v3scale2(horizontalVector, tB, width);
  v3cross2(normalVector, tB, tA);
  v3fromArray2(positionVector, controlPoints, offset);
  v3add3(p12, v3add3(p12, positionVector, horizontalVector), verticalRightVector);
  v3sub2(p22, v3add3(p22, positionVector, horizontalVector), verticalLeftVector);
  v3sub2(p32, v3sub2(p32, positionVector, horizontalVector), verticalLeftVector);
  v3add3(p42, v3sub2(p42, positionVector, horizontalVector), verticalRightVector);
  if (leftHeight < rightHeight) {
    caAdd3(vertices, p42[0], p42[1], p42[2]);
    caAdd3(vertices, p32[0], p32[1], p32[2]);
    caAdd3(vertices, p22[0], p22[1], p22[2]);
    caAdd3(vertices, p12[0], p12[1], p12[2]);
    v3copy2(verticalVector, verticalRightVector);
  } else {
    caAdd3(vertices, p12[0], p12[1], p12[2]);
    caAdd3(vertices, p22[0], p22[1], p22[2]);
    caAdd3(vertices, p32[0], p32[1], p32[2]);
    caAdd3(vertices, p42[0], p42[1], p42[2]);
    v3copy2(verticalVector, verticalLeftVector);
  }
  if (flip) {
    for (let i = 0; i < 4; ++i) {
      caAdd3(normals, -normalVector[0], -normalVector[1], -normalVector[2]);
    }
    caAdd3(indices, vertexCount, vertexCount + 1, vertexCount + 2);
    caAdd3(indices, vertexCount + 2, vertexCount + 3, vertexCount);
  } else {
    for (let i = 0; i < 4; ++i) {
      caAdd3(normals, normalVector[0], normalVector[1], normalVector[2]);
    }
    caAdd3(indices, vertexCount + 2, vertexCount + 1, vertexCount);
    caAdd3(indices, vertexCount, vertexCount + 3, vertexCount + 2);
  }
}
function addSheet(state, controlPoints, normalVectors, binormalVectors, linearSegments, widthValues, heightValues, arrowHeight, startCap, endCap) {
  const { currentGroup, vertices, normals, indices, groups } = state;
  const vertexCount = vertices.elementCount;
  let offsetLength = 0;
  if (arrowHeight > 0) {
    v3fromArray2(tA, controlPoints, 0);
    v3fromArray2(tB, controlPoints, linearSegments * 3);
    offsetLength = arrowHeight / v3magnitude(v3sub2(tV, tB, tA));
  } else {
    v3set(normalOffset, 0, 0, 0);
  }
  for (let i = 0; i <= linearSegments; ++i) {
    const width = widthValues[i];
    const height = heightValues[i];
    const actualHeight = arrowHeight === 0 ? height : arrowHeight * (1 - i / linearSegments);
    const i3 = i * 3;
    v3fromArray2(verticalVector, normalVectors, i3);
    v3scale2(verticalVector, verticalVector, actualHeight);
    v3fromArray2(horizontalVector, binormalVectors, i3);
    v3scale2(horizontalVector, horizontalVector, width);
    if (arrowHeight > 0) {
      v3fromArray2(tA, normalVectors, i3);
      v3fromArray2(tB, binormalVectors, i3);
      v3scale2(normalOffset, v3cross2(normalOffset, tA, tB), offsetLength);
    }
    v3fromArray2(positionVector, controlPoints, i3);
    v3fromArray2(normalVector, normalVectors, i3);
    v3fromArray2(torsionVector, binormalVectors, i3);
    v3add3(tA, v3add3(tA, positionVector, horizontalVector), verticalVector);
    v3add3(tB, normalVector, normalOffset);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3add3(tA, v3sub2(tA, positionVector, horizontalVector), verticalVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3negate(tB, torsionVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3sub2(tA, v3sub2(tA, positionVector, horizontalVector), verticalVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3add3(tB, v3negate(tB, normalVector), normalOffset);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3sub2(tA, v3add3(tA, positionVector, horizontalVector), verticalVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3copy2(tB, torsionVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
    v3add3(tA, v3add3(tA, positionVector, horizontalVector), verticalVector);
    caAdd3(vertices, tA[0], tA[1], tA[2]);
    caAdd3(normals, tB[0], tB[1], tB[2]);
  }
  for (let i = 0; i < linearSegments; ++i) {
    for (let j = 0; j < 2; j++) {
      caAdd3(
        indices,
        vertexCount + i * 8 + 2 * j,
        // a
        vertexCount + (i + 1) * 8 + 2 * j + 1,
        // c
        vertexCount + i * 8 + 2 * j + 1
        // b
      );
      caAdd3(
        indices,
        vertexCount + i * 8 + 2 * j,
        // a
        vertexCount + (i + 1) * 8 + 2 * j,
        // d
        vertexCount + (i + 1) * 8 + 2 * j + 1
        // c
      );
    }
    for (let j = 2; j < 4; j++) {
      caAdd3(
        indices,
        vertexCount + i * 8 + 2 * j,
        // a
        vertexCount + (i + 1) * 8 + 2 * j,
        // d
        vertexCount + i * 8 + 2 * j + 1
      );
      caAdd3(
        indices,
        vertexCount + (i + 1) * 8 + 2 * j,
        // d
        vertexCount + (i + 1) * 8 + 2 * j + 1,
        // c
        vertexCount + i * 8 + 2 * j + 1
      );
    }
  }
  if (startCap) {
    const width = widthValues[0];
    const height = heightValues[0];
    const h = arrowHeight === 0 ? height : arrowHeight;
    addCap(0, state, controlPoints, normalVectors, binormalVectors, width, h, h, false);
  } else if (arrowHeight > 0) {
    const width = widthValues[0];
    const height = heightValues[0];
    addCap(0, state, controlPoints, normalVectors, binormalVectors, width, arrowHeight, -height, false);
    addCap(0, state, controlPoints, normalVectors, binormalVectors, width, -arrowHeight, height, false);
  }
  if (endCap && arrowHeight === 0) {
    const width = widthValues[linearSegments];
    const height = heightValues[linearSegments];
    addCap(linearSegments * 3, state, controlPoints, normalVectors, binormalVectors, width, height, height, true);
  }
  const addedVertexCount = (linearSegments + 1) * 8 + (startCap ? 4 : arrowHeight > 0 ? 8 : 0) + (endCap && arrowHeight === 0 ? 4 : 0);
  for (let i = 0, il = addedVertexCount; i < il; ++i)
    caAdd(groups, currentGroup);
}

// node_modules/molstar/lib/mol-geo/geometry/mesh/builder/tube.js
var normalVector2 = Vec3();
var capNormalSmoothingVector = Vec3();
var surfacePoint = Vec3();
var controlPoint = Vec3();
var u = Vec3();
var v = Vec3();
function add2AndScale2(out, a4, b4, sa, sb) {
  out[0] = a4[0] * sa + b4[0] * sb;
  out[1] = a4[1] * sa + b4[1] * sb;
  out[2] = a4[2] * sa + b4[2] * sb;
}
function add3AndScale2(out, a4, b4, c4, sa, sb) {
  out[0] = a4[0] * sa + b4[0] * sb + c4[0];
  out[1] = a4[1] * sa + b4[1] * sb + c4[1];
  out[2] = a4[2] * sa + b4[2] * sb + c4[2];
}
var v3fromArray3 = Vec3.fromArray;
var v3normalize2 = Vec3.normalize;
var v3scaleAndAdd = Vec3.scaleAndAdd;
var v3cross3 = Vec3.cross;
var v3slerp2 = Vec3.slerp;
var v3dot = Vec3.dot;
var v3unitX = Vec3.unitX;
var caAdd32 = ChunkedArray.add3;
var CosSinCache = /* @__PURE__ */ new Map();
function getCosSin(radialSegments, shift2) {
  const offset = shift2 ? 1 : 0;
  const hash = cantorPairing(radialSegments, offset);
  if (!CosSinCache.has(hash)) {
    const cos = [];
    const sin = [];
    for (let j = 0; j < radialSegments; ++j) {
      const t4 = (j * 2 + offset) / radialSegments * Math.PI;
      cos[j] = Math.cos(t4);
      sin[j] = Math.sin(t4);
    }
    CosSinCache.set(hash, { cos, sin });
  }
  return CosSinCache.get(hash);
}
function addTube(state, controlPoints, normalVectors, binormalVectors, linearSegments, radialSegments, widthValues, heightValues, startCap, endCap, crossSection, roundCap = false) {
  const { currentGroup, vertices, normals, indices, groups } = state;
  let vertexCount = vertices.elementCount;
  const { cos, sin } = getCosSin(radialSegments, crossSection === "rounded");
  const q1 = Math.round(radialSegments / 4);
  const q3 = q1 * 3;
  const roundCapFlag = roundCap && linearSegments && (startCap || endCap);
  let halfLinearSegments;
  const doubleRoundCap = roundCapFlag && startCap && endCap;
  if (doubleRoundCap)
    halfLinearSegments = linearSegments / 2;
  for (let i = 0; i <= linearSegments; ++i) {
    const i3 = i * 3;
    v3fromArray3(u, normalVectors, i3);
    v3fromArray3(v, binormalVectors, i3);
    v3fromArray3(controlPoint, controlPoints, i3);
    let width = widthValues[i];
    let height = heightValues[i];
    let capSmoothingFactor;
    if (roundCapFlag) {
      const sc = doubleRoundCap ? i <= halfLinearSegments : startCap;
      if (doubleRoundCap) {
        capSmoothingFactor = Math.max(Number.EPSILON, Math.sqrt(1 - Math.pow((sc ? halfLinearSegments - i : i - halfLinearSegments) / halfLinearSegments, 2)));
      } else {
        capSmoothingFactor = Math.max(Number.EPSILON, Math.sqrt(1 - Math.pow((sc ? linearSegments - i : i) / linearSegments, 2)));
      }
      width *= capSmoothingFactor;
      height *= capSmoothingFactor;
      v3cross3(capNormalSmoothingVector, sc ? v : u, sc ? u : v);
      v3normalize2(capNormalSmoothingVector, capNormalSmoothingVector);
    }
    const rounded = crossSection === "rounded" && height > width;
    for (let j = 0; j < radialSegments; ++j) {
      if (rounded) {
        add3AndScale2(surfacePoint, u, v, controlPoint, width * cos[j], width * sin[j]);
        const h = v3dot(v, v3unitX) < 0 ? j < q1 || j >= q3 ? height - width : -height + width : j >= q1 && j < q3 ? -height + width : height - width;
        v3scaleAndAdd(surfacePoint, surfacePoint, u, h);
        if (j === q1 || j === q1 - 1) {
          add2AndScale2(normalVector2, u, v, 0, 1);
        } else if (j === q3 || j === q3 - 1) {
          add2AndScale2(normalVector2, u, v, 0, -1);
        } else {
          add2AndScale2(normalVector2, u, v, cos[j], sin[j]);
        }
      } else {
        add3AndScale2(surfacePoint, u, v, controlPoint, height * cos[j], width * sin[j]);
        add2AndScale2(normalVector2, u, v, width * cos[j], height * sin[j]);
      }
      v3normalize2(normalVector2, normalVector2);
      caAdd32(vertices, surfacePoint[0], surfacePoint[1], surfacePoint[2]);
      if (roundCapFlag) {
        v3slerp2(normalVector2, capNormalSmoothingVector, normalVector2, capSmoothingFactor);
      }
      caAdd32(normals, normalVector2[0], normalVector2[1], normalVector2[2]);
    }
  }
  const radialSegmentsHalf = Math.round(radialSegments / 2);
  for (let i = 0; i < linearSegments; ++i) {
    for (let j = 0; j < radialSegmentsHalf; ++j) {
      caAdd32(
        indices,
        vertexCount + i * radialSegments + (j + 1) % radialSegments,
        // a
        vertexCount + (i + 1) * radialSegments + (j + 1) % radialSegments,
        // c
        vertexCount + i * radialSegments + j
        // b
      );
      caAdd32(
        indices,
        vertexCount + (i + 1) * radialSegments + (j + 1) % radialSegments,
        // c
        vertexCount + (i + 1) * radialSegments + j,
        // d
        vertexCount + i * radialSegments + j
        // b
      );
    }
    for (let j = radialSegmentsHalf; j < radialSegments; ++j) {
      caAdd32(
        indices,
        vertexCount + i * radialSegments + (j + 1) % radialSegments,
        // a
        vertexCount + (i + 1) * radialSegments + j,
        // d
        vertexCount + i * radialSegments + j
        // b
      );
      caAdd32(
        indices,
        vertexCount + (i + 1) * radialSegments + (j + 1) % radialSegments,
        // c
        vertexCount + (i + 1) * radialSegments + j,
        // d
        vertexCount + i * radialSegments + (j + 1) % radialSegments
      );
    }
  }
  if (startCap) {
    const offset = 0;
    const centerVertex = vertices.elementCount;
    v3fromArray3(u, normalVectors, offset);
    v3fromArray3(v, binormalVectors, offset);
    v3fromArray3(controlPoint, controlPoints, offset);
    v3cross3(normalVector2, v, u);
    caAdd32(vertices, controlPoint[0], controlPoint[1], controlPoint[2]);
    caAdd32(normals, normalVector2[0], normalVector2[1], normalVector2[2]);
    const width = roundCapFlag ? 0 : widthValues[0];
    let height = roundCapFlag ? 0 : heightValues[0];
    const rounded = crossSection === "rounded" && height > width;
    if (rounded)
      height -= width;
    vertexCount = vertices.elementCount;
    for (let i = 0; i < radialSegments; ++i) {
      if (rounded) {
        add3AndScale2(surfacePoint, u, v, controlPoint, width * cos[i], width * sin[i]);
        v3scaleAndAdd(surfacePoint, surfacePoint, u, i < q1 || i >= q3 ? height : -height);
      } else {
        add3AndScale2(surfacePoint, u, v, controlPoint, height * cos[i], width * sin[i]);
      }
      caAdd32(vertices, surfacePoint[0], surfacePoint[1], surfacePoint[2]);
      caAdd32(normals, normalVector2[0], normalVector2[1], normalVector2[2]);
      caAdd32(indices, vertexCount + (i + 1) % radialSegments, vertexCount + i, centerVertex);
    }
  }
  if (endCap) {
    const offset = linearSegments * 3;
    const centerVertex = vertices.elementCount;
    v3fromArray3(u, normalVectors, offset);
    v3fromArray3(v, binormalVectors, offset);
    v3fromArray3(controlPoint, controlPoints, offset);
    v3cross3(normalVector2, u, v);
    caAdd32(vertices, controlPoint[0], controlPoint[1], controlPoint[2]);
    caAdd32(normals, normalVector2[0], normalVector2[1], normalVector2[2]);
    const width = roundCapFlag ? 0 : widthValues[linearSegments];
    let height = roundCapFlag ? 0 : heightValues[linearSegments];
    const rounded = crossSection === "rounded" && height > width;
    if (rounded)
      height -= width;
    vertexCount = vertices.elementCount;
    for (let i = 0; i < radialSegments; ++i) {
      if (rounded) {
        add3AndScale2(surfacePoint, u, v, controlPoint, width * cos[i], width * sin[i]);
        v3scaleAndAdd(surfacePoint, surfacePoint, u, i < q1 || i >= q3 ? height : -height);
      } else {
        add3AndScale2(surfacePoint, u, v, controlPoint, height * cos[i], width * sin[i]);
      }
      caAdd32(vertices, surfacePoint[0], surfacePoint[1], surfacePoint[2]);
      caAdd32(normals, normalVector2[0], normalVector2[1], normalVector2[2]);
      caAdd32(indices, vertexCount + i, vertexCount + (i + 1) % radialSegments, centerVertex);
    }
  }
  const addedVertexCount = (linearSegments + 1) * radialSegments + (startCap ? radialSegments + 1 : 0) + (endCap ? radialSegments + 1 : 0);
  ChunkedArray.addRepeat(groups, addedVertexCount, currentGroup);
}

// node_modules/molstar/lib/mol-geo/geometry/mesh/builder/ribbon.js
var v3fromArray4 = Vec3.fromArray;
var v3magnitude2 = Vec3.magnitude;
var v3sub3 = Vec3.sub;
var v3add4 = Vec3.add;
var v3scale3 = Vec3.scale;
var v3negate2 = Vec3.negate;
var v3copy3 = Vec3.copy;
var v3cross4 = Vec3.cross;
var caAdd33 = ChunkedArray.add3;
var caAdd2 = ChunkedArray.add;
var tA2 = Vec3();
var tB2 = Vec3();
var tV2 = Vec3();
var horizontalVector2 = Vec3();
var verticalVector2 = Vec3();
var normalOffset2 = Vec3();
var positionVector2 = Vec3();
var normalVector3 = Vec3();
var torsionVector2 = Vec3();
function addRibbon(state, controlPoints, normalVectors, binormalVectors, linearSegments, widthValues, heightValues, arrowHeight) {
  const { currentGroup, vertices, normals, indices, groups } = state;
  const vertexCount = vertices.elementCount;
  let offsetLength = 0;
  if (arrowHeight > 0) {
    v3fromArray4(tA2, controlPoints, 0);
    v3fromArray4(tB2, controlPoints, linearSegments * 3);
    offsetLength = arrowHeight / v3magnitude2(v3sub3(tV2, tB2, tA2));
  }
  for (let i = 0; i <= linearSegments; ++i) {
    const width = widthValues[i];
    const height = heightValues[i];
    const actualHeight = arrowHeight === 0 ? height : arrowHeight * (1 - i / linearSegments);
    const i3 = i * 3;
    v3fromArray4(verticalVector2, normalVectors, i3);
    v3scale3(verticalVector2, verticalVector2, actualHeight);
    v3fromArray4(horizontalVector2, binormalVectors, i3);
    v3scale3(horizontalVector2, horizontalVector2, width);
    if (arrowHeight > 0) {
      v3fromArray4(tA2, normalVectors, i3);
      v3fromArray4(tB2, binormalVectors, i3);
      v3scale3(normalOffset2, v3cross4(normalOffset2, tA2, tB2), offsetLength);
    }
    v3fromArray4(positionVector2, controlPoints, i3);
    v3fromArray4(normalVector3, normalVectors, i3);
    v3fromArray4(torsionVector2, binormalVectors, i3);
    v3add4(tA2, positionVector2, verticalVector2);
    v3negate2(tB2, torsionVector2);
    caAdd33(vertices, tA2[0], tA2[1], tA2[2]);
    caAdd33(normals, tB2[0], tB2[1], tB2[2]);
    v3sub3(tA2, positionVector2, verticalVector2);
    caAdd33(vertices, tA2[0], tA2[1], tA2[2]);
    caAdd33(normals, tB2[0], tB2[1], tB2[2]);
    v3add4(tA2, positionVector2, verticalVector2);
    v3copy3(tB2, torsionVector2);
    caAdd33(vertices, tA2[0], tA2[1], tA2[2]);
    caAdd33(normals, tB2[0], tB2[1], tB2[2]);
    v3sub3(tA2, positionVector2, verticalVector2);
    caAdd33(vertices, tA2[0], tA2[1], tA2[2]);
    caAdd33(normals, tB2[0], tB2[1], tB2[2]);
  }
  for (let i = 0; i < linearSegments; ++i) {
    caAdd33(indices, vertexCount + i * 4, vertexCount + (i + 1) * 4 + 1, vertexCount + i * 4 + 1);
    caAdd33(indices, vertexCount + i * 4, vertexCount + (i + 1) * 4, vertexCount + (i + 1) * 4 + 1);
    caAdd33(indices, vertexCount + i * 4 + 2 + 1, vertexCount + (i + 1) * 4 + 2 + 1, vertexCount + i * 4 + 2);
    caAdd33(indices, vertexCount + i * 4 + 2, vertexCount + (i + 1) * 4 + 2 + 1, vertexCount + (i + 1) * 4 + 2);
  }
  const addedVertexCount = (linearSegments + 1) * 4;
  for (let i = 0, il = addedVertexCount; i < il; ++i)
    caAdd2(groups, currentGroup);
}

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-trace-mesh.js
var PolymerTraceMeshParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  aspectRatio: ParamDefinition.Numeric(5, { min: 0.1, max: 10, step: 0.1 }),
  arrowFactor: ParamDefinition.Numeric(1.5, { min: 0, max: 3, step: 0.1 }, { description: "Size factor for sheet arrows" }),
  tubularHelices: ParamDefinition.Boolean(false, { description: "Draw alpha helices as tubes" }),
  roundCap: ParamDefinition.Boolean(false, { description: "Draw round caps on tubular alpha helices" }),
  helixProfile: ParamDefinition.Select("elliptical", ParamDefinition.arrayToOptions(["elliptical", "rounded", "square"]), { description: "Protein helix trace profile" }),
  nucleicProfile: ParamDefinition.Select("square", ParamDefinition.arrayToOptions(["elliptical", "rounded", "square"]), { description: "Nucleic strand trace profile" }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  linearSegments: ParamDefinition.Numeric(8, { min: 1, max: 48, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo)
};
var DefaultPolymerTraceMeshProps = ParamDefinition.getDefaultValues(PolymerTraceMeshParams);
var tmpV1 = Vec3();
function createPolymerTraceMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, detail, linearSegments, radialSegments, aspectRatio, arrowFactor, tubularHelices, roundCap, helixProfile, nucleicProfile } = props;
  const vertexCount = linearSegments * radialSegments * polymerElementCount + (radialSegments + 1) * polymerElementCount * 2;
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 10, mesh);
  const isCoarse = Unit.isCoarse(unit);
  const state = createCurveSegmentState(linearSegments);
  const { curvePoints, normalVectors, binormalVectors, widthValues, heightValues } = state;
  let i = 0;
  const polymerTraceIt = PolymerTraceIterator(unit, structure, { ignoreSecondaryStructure: false, useHelixOrientation: tubularHelices });
  while (polymerTraceIt.hasNext) {
    const v2 = polymerTraceIt.move();
    builderState.currentGroup = i;
    const isNucleicType = isNucleic(v2.moleculeType);
    const isSheet = SecondaryStructureType.is(v2.secStrucType, SecondaryStructureType.Flag.Beta);
    const isHelix = SecondaryStructureType.is(v2.secStrucType, SecondaryStructureType.Flag.Helix);
    const tension = isHelix && !tubularHelices ? HelixTension : StandardTension;
    const shift2 = isNucleicType ? NucleicShift : StandardShift;
    interpolateCurveSegment(state, v2, tension, shift2);
    let w0 = theme.size.size(v2.centerPrev) * sizeFactor;
    let w1 = theme.size.size(v2.center) * sizeFactor;
    let w2 = theme.size.size(v2.centerNext) * sizeFactor;
    if (isCoarse) {
      w0 *= aspectRatio / 2;
      w1 *= aspectRatio / 2;
      w2 *= aspectRatio / 2;
    }
    const startCap = v2.secStrucFirst || v2.coarseBackboneFirst || v2.first;
    const endCap = v2.secStrucLast || v2.coarseBackboneLast || v2.last;
    const hasRoundCap = isHelix && tubularHelices && roundCap;
    let segmentCount2 = linearSegments;
    if (v2.initial) {
      segmentCount2 = Math.max(Math.round(linearSegments * shift2), 1);
      const offset = linearSegments - segmentCount2;
      curvePoints.copyWithin(0, offset * 3);
      binormalVectors.copyWithin(0, offset * 3);
      normalVectors.copyWithin(0, offset * 3);
      Vec3.fromArray(tmpV1, curvePoints, 3);
      Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v2.p2, tmpV1));
      Vec3.scaleAndAdd(tmpV1, v2.p2, tmpV1, w1 * OverhangFactor);
      Vec3.toArray(tmpV1, curvePoints, 0);
    } else if (v2.final) {
      segmentCount2 = Math.max(Math.round(linearSegments * (1 - shift2)), 1);
      Vec3.fromArray(tmpV1, curvePoints, segmentCount2 * 3 - 3);
      Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v2.p2, tmpV1));
      Vec3.scaleAndAdd(tmpV1, v2.p2, tmpV1, w1 * OverhangFactor);
      Vec3.toArray(tmpV1, curvePoints, segmentCount2 * 3);
    }
    if (v2.initial === true && v2.final === true) {
      addSphere(builderState, v2.p2, w1 * 2, detail);
    } else if (isSheet) {
      const h0 = w0 * aspectRatio;
      const h1 = w1 * aspectRatio;
      const h2 = w2 * aspectRatio;
      const arrowHeight = v2.secStrucLast ? h1 * arrowFactor : 0;
      interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift2);
      if (radialSegments === 2) {
        addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount2, widthValues, heightValues, arrowHeight);
      } else {
        addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount2, widthValues, heightValues, arrowHeight, startCap, endCap);
      }
    } else {
      let h0, h1, h2;
      if (isHelix) {
        if (tubularHelices) {
          w0 *= aspectRatio * 1.5;
          w1 *= aspectRatio * 1.5;
          w2 *= aspectRatio * 1.5;
          h0 = w0;
          h1 = w1;
          h2 = w2;
        } else {
          h0 = w0 * aspectRatio;
          h1 = w1 * aspectRatio;
          h2 = w2 * aspectRatio;
        }
      } else if (isNucleicType) {
        h0 = w0 * aspectRatio;
        h1 = w1 * aspectRatio;
        h2 = w2 * aspectRatio;
      } else {
        h0 = w0;
        h1 = w1;
        h2 = w2;
      }
      interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift2);
      const [normals, binormals] = isNucleicType ? [binormalVectors, normalVectors] : [normalVectors, binormalVectors];
      if (isNucleicType) {
        for (let i2 = 0, il = normals.length; i2 < il; i2++)
          normals[i2] *= -1;
      }
      const profile = isNucleicType ? nucleicProfile : helixProfile;
      if (radialSegments === 2) {
        if (isNucleicType) {
          addRibbon(builderState, curvePoints, normals, binormals, segmentCount2, heightValues, widthValues, 0);
        } else {
          addRibbon(builderState, curvePoints, normals, binormals, segmentCount2, widthValues, heightValues, 0);
        }
      } else if (radialSegments === 4) {
        addSheet(builderState, curvePoints, normals, binormals, segmentCount2, widthValues, heightValues, 0, startCap, endCap);
      } else if (h1 === w1) {
        addTube(builderState, curvePoints, normals, binormals, segmentCount2, radialSegments, widthValues, heightValues, startCap, endCap, "elliptical", hasRoundCap);
      } else if (profile === "square") {
        addSheet(builderState, curvePoints, normals, binormals, segmentCount2, widthValues, heightValues, 0, startCap, endCap);
      } else {
        addTube(builderState, curvePoints, normals, binormals, segmentCount2, radialSegments, widthValues, heightValues, startCap, endCap, profile);
      }
    }
    ++i;
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
var PolymerTraceParams = {
  ...UnitsMeshParams,
  ...PolymerTraceMeshParams
};
function PolymerTraceVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerTraceParams),
    createGeometry: createPolymerTraceMesh,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup, { asSecondary: true }),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.tubularHelices !== currentProps.tubularHelices || newProps.roundCap !== currentProps.roundCap || newProps.detail !== currentProps.detail || newProps.linearSegments !== currentProps.linearSegments || newProps.radialSegments !== currentProps.radialSegments || newProps.aspectRatio !== currentProps.aspectRatio || newProps.arrowFactor !== currentProps.arrowFactor || newProps.helixProfile !== currentProps.helixProfile || newProps.nucleicProfile !== currentProps.nucleicProfile;
      const secondaryStructureHash = SecondaryStructureProvider.get(newStructureGroup.structure).version;
      if (state.info.secondaryStructureHash !== secondaryStructureHash) {
        if (state.info.secondaryStructureHash !== void 0)
          state.createGeometry = true;
        state.info.secondaryStructureHash = secondaryStructureHash;
      }
    },
    initUpdateState: (state, newProps, newTheme, newStructureGroup) => {
      const secondaryStructureHash = SecondaryStructureProvider.get(newStructureGroup.structure).version;
      state.info.secondaryStructureHash = secondaryStructureHash;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/cartoon.js
var CartoonVisuals = {
  "polymer-trace": (ctx, getParams) => UnitsRepresentation("Polymer trace mesh", ctx, getParams, PolymerTraceVisual),
  "polymer-gap": (ctx, getParams) => UnitsRepresentation("Polymer gap cylinder", ctx, getParams, PolymerGapVisual),
  "nucleotide-block": (ctx, getParams) => UnitsRepresentation("Nucleotide block mesh", ctx, getParams, NucleotideBlockVisual),
  "nucleotide-ring": (ctx, getParams) => UnitsRepresentation("Nucleotide ring mesh", ctx, getParams, NucleotideRingVisual),
  "nucleotide-atomic-ring-fill": (ctx, getParams) => UnitsRepresentation("Nucleotide atomic ring fill", ctx, getParams, NucleotideAtomicRingFillVisual),
  "nucleotide-atomic-bond": (ctx, getParams) => UnitsRepresentation("Nucleotide atomic bond", ctx, getParams, NucleotideAtomicBondVisual),
  "nucleotide-atomic-element": (ctx, getParams) => UnitsRepresentation("Nucleotide atomic element", ctx, getParams, NucleotideAtomicElementVisual),
  "direction-wedge": (ctx, getParams) => UnitsRepresentation("Polymer direction wedge", ctx, getParams, PolymerDirectionVisual)
};
var CartoonParams = {
  ...PolymerTraceParams,
  ...PolymerGapParams,
  ...NucleotideBlockParams,
  ...NucleotideRingParams,
  ...NucleotideAtomicBondParams,
  ...NucleotideAtomicElementParams,
  ...NucleotideAtomicRingFillParams,
  ...PolymerDirectionParams,
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  visuals: ParamDefinition.MultiSelect(["polymer-trace", "polymer-gap", "nucleotide-ring", "nucleotide-atomic-ring-fill", "nucleotide-atomic-bond", "nucleotide-atomic-element"], ParamDefinition.objectToOptions(CartoonVisuals)),
  bumpFrequency: ParamDefinition.Numeric(2, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory),
  colorMode: ParamDefinition.Select("default", ParamDefinition.arrayToOptions(["default", "interpolate"]), { ...BaseGeometry.ShadingCategory, isHidden: true })
};
function getCartoonParams(ctx, structure) {
  const params = ParamDefinition.clone(CartoonParams);
  let hasNucleotides = false;
  let hasGaps = false;
  structure.units.forEach((u2) => {
    if (!hasNucleotides && Unit.isAtomic(u2) && u2.nucleotideElements.length)
      hasNucleotides = true;
    if (!hasGaps && u2.gapElements.length)
      hasGaps = true;
  });
  params.visuals.defaultValue = ["polymer-trace"];
  if (hasNucleotides)
    params.visuals.defaultValue.push("nucleotide-ring");
  if (hasGaps)
    params.visuals.defaultValue.push("polymer-gap");
  return params;
}
function CartoonRepresentation(ctx, getParams) {
  return Representation.createMulti("Cartoon", ctx, getParams, StructureRepresentationStateBuilder, CartoonVisuals);
}
var CartoonRepresentationProvider = StructureRepresentationProvider({
  name: "cartoon",
  label: "Cartoon",
  description: "Displays ribbons, planks, tubes smoothly following the trace atoms of polymers.",
  factory: CartoonRepresentation,
  getParams: getCartoonParams,
  defaultValues: ParamDefinition.getDefaultValues(CartoonParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.polymerResidueCount > 0,
  ensureCustomProperties: {
    attach: async (ctx, structure) => {
      await SecondaryStructureProvider.attach(ctx, structure, void 0, true);
      for (const m of structure.models) {
        await HelixOrientationProvider.attach(ctx, m, void 0, true);
      }
    },
    detach: (data) => {
      SecondaryStructureProvider.ref(data, false);
      for (const m of data.models) {
        HelixOrientationProvider.ref(m, false);
      }
    }
  }
});

// node_modules/molstar/lib/mol-repr/structure/visual/ellipsoid-mesh.js
var v3add5 = Vec3.add;
function createEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Mesh.createEmpty(mesh);
  const { detail, sizeFactor } = props;
  const { elements, model } = unit;
  const elementCount = elements.length;
  const vertexCount = elementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const atomSiteAnisotrop = AtomSiteAnisotrop.Provider.get(model);
  if (!atomSiteAnisotrop)
    return Mesh.createEmpty(mesh);
  const v2 = Vec3();
  const mat = Mat3();
  const eigvals = Vec3();
  const eigvec1 = Vec3();
  const eigvec2 = Vec3();
  const { elementToAnsiotrop, data } = atomSiteAnisotrop;
  const { U } = data;
  const space2 = data._schema.U.space;
  const c4 = unit.conformation;
  const l = element_exports.Location.create(structure);
  l.unit = unit;
  const ignore2 = makeElementIgnoreTest(structure, unit, props);
  const center2 = Vec3();
  let count2 = 0;
  for (let i = 0; i < elementCount; i++) {
    const ei = elements[i];
    const ai = elementToAnsiotrop[ei];
    if (ai === -1)
      continue;
    if (ignore2 && ignore2(elements[i]))
      continue;
    l.element = ei;
    c4.invariantPosition(ei, v2);
    v3add5(center2, center2, v2);
    count2 += 1;
    builderState.currentGroup = i;
    Tensor.toMat3(mat, space2, U.value(ai));
    Mat3.symmtricFromLower(mat, mat);
    Mat3.symmetricEigenvalues(eigvals, mat);
    Mat3.eigenvector(eigvec1, mat, eigvals[1]);
    Mat3.eigenvector(eigvec2, mat, eigvals[2]);
    for (let j = 0; j < 3; ++j) {
      eigvals[j] = sizeFactor * 1.5958 * Math.sqrt(Math.abs(eigvals[j]));
    }
    if (equalEps(eigvals[0], eigvals[1], EPSILON) && equalEps(eigvals[1], eigvals[2], EPSILON)) {
      addSphere(builderState, v2, eigvals[0], detail);
    } else {
      addEllipsoid(builderState, v2, eigvec2, eigvec1, eigvals, detail);
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  if (count2 === 0)
    return m;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, 1 * sizeFactor * 2);
  }
  m.setBoundingSphere(boundingSphere);
  return m;
}
var EllipsoidMeshParams = {
  ...UnitsMeshParams,
  sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false)
};
function EllipsoidMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(EllipsoidMeshParams),
    createGeometry: createEllipsoidMesh,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens;
    }
  }, materialId);
}
function createStructureEllipsoidMesh(ctx, structure, theme, props, mesh) {
  const { child } = structure;
  const { detail, sizeFactor } = props;
  const { getSerialIndex } = structure.serialMapping;
  const structureElementCount = structure.elementCount;
  const vertexCount = structureElementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const v2 = Vec3();
  const mat = Mat3();
  const eigvals = Vec3();
  const eigvec1 = Vec3();
  const eigvec2 = Vec3();
  const center2 = Vec3();
  let count2 = 0;
  for (const unit of structure.units) {
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
      return Mesh.createEmpty(mesh);
    const { elements, model } = unit;
    const elementCount = elements.length;
    const atomSiteAnisotrop = AtomSiteAnisotrop.Provider.get(model);
    if (!atomSiteAnisotrop)
      return Mesh.createEmpty(mesh);
    const ignore2 = makeElementIgnoreTest(structure, unit, props);
    const { elementToAnsiotrop, data } = atomSiteAnisotrop;
    const { U } = data;
    const space2 = data._schema.U.space;
    const c4 = unit.conformation;
    const l = element_exports.Location.create(structure);
    l.unit = unit;
    for (let i = 0; i < elementCount; i++) {
      const ei = elements[i];
      const ai = elementToAnsiotrop[ei];
      if (ai === -1)
        continue;
      if (ignore2 && ignore2(elements[i]))
        continue;
      l.element = ei;
      c4.position(ei, v2);
      v3add5(center2, center2, v2);
      count2 += 1;
      builderState.currentGroup = getSerialIndex(unit, elements[i]);
      Tensor.toMat3(mat, space2, U.value(ai));
      Mat3.symmtricFromLower(mat, mat);
      Mat3.symmetricEigenvalues(eigvals, mat);
      Mat3.eigenvector(eigvec1, mat, eigvals[1]);
      Mat3.eigenvector(eigvec2, mat, eigvals[2]);
      for (let j = 0; j < 3; ++j) {
        eigvals[j] = sizeFactor * 1.5958 * Math.sqrt(Math.abs(eigvals[j]));
      }
      if (equalEps(eigvals[0], eigvals[1], EPSILON) && equalEps(eigvals[1], eigvals[2], EPSILON)) {
        addSphere(builderState, v2, eigvals[0], detail);
      } else {
        addEllipsoid(builderState, v2, eigvec2, eigvec1, eigvals, detail);
      }
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  if (count2 === 0)
    return m;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * sizeFactor * 2);
  }
  m.setBoundingSphere(boundingSphere);
  return m;
}
var StructureEllipsoidMeshParams = {
  ...ComplexMeshParams,
  sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false)
};
function StructureEllipsoidMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureEllipsoidMeshParams),
    createGeometry: createStructureEllipsoidMesh,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/ellipsoid.js
var EllipsoidVisuals = {
  "ellipsoid-mesh": (ctx, getParams) => UnitsRepresentation("Ellipsoid Mesh", ctx, getParams, EllipsoidMeshVisual),
  "intra-bond": (ctx, getParams) => UnitsRepresentation("Intra-unit bond cylinder", ctx, getParams, IntraUnitBondCylinderVisual),
  "inter-bond": (ctx, getParams) => ComplexRepresentation("Inter-unit bond cylinder", ctx, getParams, InterUnitBondCylinderVisual),
  "structure-ellipsoid-mesh": (ctx, getParams) => ComplexRepresentation("Structure Ellipsoid Mesh", ctx, getParams, StructureEllipsoidMeshVisual),
  "structure-intra-bond": (ctx, getParams) => ComplexRepresentation("Structure intra-unit bond cylinder", ctx, getParams, StructureIntraUnitBondCylinderVisual)
};
var EllipsoidParams = {
  ...EllipsoidMeshParams,
  ...IntraUnitBondCylinderParams,
  ...InterUnitBondCylinderParams,
  includeParent: ParamDefinition.Boolean(false),
  adjustCylinderLength: ParamDefinition.Boolean(false, { isHidden: true }),
  // not useful here
  unitKinds: getUnitKindsParam(["atomic"]),
  sizeFactor: ParamDefinition.Numeric(1, { min: 0.01, max: 10, step: 0.01 }),
  sizeAspectRatio: ParamDefinition.Numeric(0.1, { min: 0.01, max: 3, step: 0.01 }),
  linkCap: ParamDefinition.Boolean(true),
  visuals: ParamDefinition.MultiSelect(["ellipsoid-mesh", "intra-bond", "inter-bond"], ParamDefinition.objectToOptions(EllipsoidVisuals)),
  bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory)
};
function getEllipsoidParams(ctx, structure) {
  let params = EllipsoidParams;
  const size = Structure.getSize(structure);
  if (size >= Structure.Size.Huge) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["ellipsoid-mesh", "intra-bond"];
  } else if (structure.unitSymmetryGroups.length > 5e3) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["structure-ellipsoid-mesh", "structure-intra-bond"];
  }
  return params;
}
function EllipsoidRepresentation(ctx, getParams) {
  return Representation.createMulti("Ellipsoid", ctx, getParams, StructureRepresentationStateBuilder, EllipsoidVisuals);
}
var EllipsoidRepresentationProvider = StructureRepresentationProvider({
  name: "ellipsoid",
  label: "Ellipsoid",
  description: "Displays anisotropic displacement ellipsoids of atomic elements plus bonds as cylinders.",
  factory: EllipsoidRepresentation,
  getParams: getEllipsoidParams,
  defaultValues: ParamDefinition.getDefaultValues(EllipsoidParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.elementCount > 0 && structure.models.some((m) => AtomSiteAnisotrop.Provider.isApplicable(m)),
  getData: (structure, props) => {
    return props.includeParent ? structure.asParent() : structure;
  },
  mustRecreate: (oldProps, newProps) => {
    return oldProps.includeParent !== newProps.includeParent;
  }
});

// node_modules/molstar/lib/mol-gl/shader/gaussian-density.vert.js
var gaussianDensity_vert = `
precision highp float;

attribute vec3 aPosition;
attribute float aRadius;

varying vec3 vPosition;
varying float vRadiusSqInv;

#if defined(dCalcType_groupId)
    attribute float aGroup;
    varying float vGroup;
#endif

uniform vec3 uBboxSize;
uniform vec3 uBboxMin;
uniform float uResolution;

void main() {
    vRadiusSqInv = 1.0 / (aRadius * aRadius);
    #if defined(dCalcType_groupId)
        vGroup = aGroup;
    #endif
    gl_PointSize = ceil(((aRadius * 3.0) / uResolution) + uResolution);
    vPosition = (aPosition - uBboxMin) / uResolution;
    gl_Position = vec4(((aPosition - uBboxMin) / uBboxSize) * 2.0 - 1.0, 1.0);
}
`;

// node_modules/molstar/lib/mol-gl/shader/gaussian-density.frag.js
var gaussianDensity_frag = `
precision highp float;

varying vec3 vPosition;
varying float vRadiusSqInv;
#if defined(dCalcType_groupId)
    #if defined(dGridTexType_2d)
        precision highp sampler2D;
        uniform sampler2D tMinDistanceTex;
        uniform vec3 uGridTexDim;
    #elif defined(dGridTexType_3d)
        precision highp sampler3D;
        uniform sampler3D tMinDistanceTex;
    #endif
    varying float vGroup;
#endif

#include common

uniform vec3 uGridDim;
uniform vec2 uGridTexScale;
uniform float uCurrentSlice;
uniform float uCurrentX;
uniform float uCurrentY;
uniform float uAlpha;
uniform float uResolution;
uniform float uRadiusFactorInv;

void main() {
    vec2 v = gl_FragCoord.xy - vec2(uCurrentX, uCurrentY) - 0.5;
    vec3 fragPos = vec3(v.x, v.y, uCurrentSlice);
    float dist = distance(fragPos, vPosition) * uResolution;

    #if defined(dCalcType_density)
        float density = exp(-uAlpha * ((dist * dist) * vRadiusSqInv));
        gl_FragColor.a = density * uRadiusFactorInv;
    #elif defined(dCalcType_minDistance)
        gl_FragColor.a = 1.0 - dist * uRadiusFactorInv;
    #elif defined(dCalcType_groupId)
        #if defined(dGridTexType_2d)
            float minDistance = 1.0 - texture2D(tMinDistanceTex, (gl_FragCoord.xy) / (uGridTexDim.xy / uGridTexScale)).a;
        #elif defined(dGridTexType_3d)
            float minDistance = 1.0 - texelFetch(tMinDistanceTex, ivec3(gl_FragCoord.xy, uCurrentSlice), 0).a;
        #endif
        if (dist * uRadiusFactorInv > minDistance + uResolution * 0.05)
            discard;
        gl_FragColor.rgb = packIntToRGB(vGroup);
    #endif
}
`;

// node_modules/molstar/lib/mol-math/geometry/gaussian-density/gpu.js
var GaussianDensitySchema = {
  drawCount: ValueSpec("number"),
  instanceCount: ValueSpec("number"),
  aRadius: AttributeSpec("float32", 1, 0),
  aPosition: AttributeSpec("float32", 3, 0),
  aGroup: AttributeSpec("float32", 1, 0),
  uCurrentSlice: UniformSpec("f"),
  uCurrentX: UniformSpec("f"),
  uCurrentY: UniformSpec("f"),
  uBboxMin: UniformSpec("v3", "material"),
  uBboxSize: UniformSpec("v3", "material"),
  uGridDim: UniformSpec("v3", "material"),
  uGridTexDim: UniformSpec("v3", "material"),
  uGridTexScale: UniformSpec("v2", "material"),
  uAlpha: UniformSpec("f", "material"),
  uResolution: UniformSpec("f", "material"),
  uRadiusFactorInv: UniformSpec("f", "material"),
  tMinDistanceTex: TextureSpec("texture", "rgba", "float", "nearest", "material"),
  dGridTexType: DefineSpec("string", ["2d", "3d"]),
  dCalcType: DefineSpec("string", ["density", "minDistance", "groupId"])
};
var GaussianDensityName = "gaussian-density";
function getFramebuffer(webgl) {
  if (!webgl.namedFramebuffers[GaussianDensityName]) {
    webgl.namedFramebuffers[GaussianDensityName] = webgl.resources.framebuffer();
  }
  return webgl.namedFramebuffers[GaussianDensityName];
}
function getTexture(name2, webgl, kind, format, type, filter2) {
  const _name = `${GaussianDensityName}-${name2}`;
  if (!webgl.namedTextures[_name]) {
    webgl.namedTextures[_name] = webgl.resources.texture(kind, format, type, filter2);
  }
  return webgl.namedTextures[_name];
}
function GaussianDensityTexture(webgl, position3, box3, radius, props, oldTexture) {
  return webgl.isWebGL2 ? GaussianDensityTexture3d(webgl, position3, box3, radius, props, oldTexture) : GaussianDensityTexture2d(webgl, position3, box3, radius, false, props, oldTexture);
}
function GaussianDensityTexture2d(webgl, position3, box3, radius, powerOfTwo, props, oldTexture) {
  if (isTimingMode)
    webgl.timer.mark("GaussianDensityTexture2d");
  const data = calcGaussianDensityTexture2d(webgl, position3, box3, radius, powerOfTwo, props, oldTexture);
  if (isTimingMode)
    webgl.timer.markEnd("GaussianDensityTexture2d");
  return finalizeGaussianDensityTexture(data);
}
function GaussianDensityTexture3d(webgl, position3, box3, radius, props, oldTexture) {
  if (isTimingMode)
    webgl.timer.mark("GaussianDensityTexture3d");
  const data = calcGaussianDensityTexture3d(webgl, position3, box3, radius, props, oldTexture);
  if (isTimingMode)
    webgl.timer.markEnd("GaussianDensityTexture3d");
  return finalizeGaussianDensityTexture(data);
}
function finalizeGaussianDensityTexture({ texture, scale, bbox, gridDim, gridTexDim, gridTexScale, radiusFactor, resolution, maxRadius }) {
  return { transform: getTransform(scale, bbox), texture, bbox, gridDim, gridTexDim, gridTexScale, radiusFactor, resolution, maxRadius };
}
function getTransform(scale, bbox) {
  const transform = Mat4.identity();
  Mat4.fromScaling(transform, scale);
  Mat4.setTranslation(transform, bbox.min);
  return transform;
}
function calcGaussianDensityTexture2d(webgl, position3, box3, radius, powerOfTwo, props, texture) {
  const { gl, resources, state, extensions: { colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, blendMinMax } } = webgl;
  const { smoothness, resolution } = props;
  const { drawCount, positions, radii, groups, scale, expandedBox, dim, maxRadius } = prepareGaussianDensityData(position3, box3, radius, props);
  const [dx, dy, dz] = dim;
  const { texDimX, texDimY, texCols, powerOfTwoSize } = getTexture2dSize(dim);
  const gridTexDim = Vec3.create(texDimX, texDimY, 0);
  const gridTexScale = Vec2.create(texDimX / powerOfTwoSize, texDimY / powerOfTwoSize);
  const radiusFactor = maxRadius * 2;
  const width = powerOfTwo ? powerOfTwoSize : texDimX;
  const height = powerOfTwo ? powerOfTwoSize : texDimY;
  const minDistTex = getTexture("min-dist-2d", webgl, "image-uint8", "rgba", "ubyte", "nearest");
  minDistTex.define(width, height);
  const renderable = getGaussianDensityRenderable(webgl, drawCount, positions, radii, groups, minDistTex, expandedBox, dim, gridTexDim, gridTexScale, smoothness, resolution, radiusFactor);
  const { uCurrentSlice, uCurrentX, uCurrentY } = renderable.values;
  const framebuffer = getFramebuffer(webgl);
  framebuffer.bind();
  setRenderingDefaults(webgl);
  if (!texture)
    texture = colorBufferHalfFloat && textureHalfFloat ? resources.texture("image-float16", "rgba", "fp16", "linear") : colorBufferFloat && textureFloat ? resources.texture("image-float32", "rgba", "float", "linear") : resources.texture("image-uint8", "rgba", "ubyte", "linear");
  texture.define(width, height);
  function render(fbTex, clear) {
    state.currentRenderItemId = -1;
    fbTex.attachFramebuffer(framebuffer, 0);
    if (clear) {
      state.viewport(0, 0, width, height);
      state.scissor(0, 0, width, height);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    ValueCell.update(uCurrentY, 0);
    let currCol = 0;
    let currY = 0;
    let currX = 0;
    for (let i = 0; i < dz; ++i) {
      if (currCol >= texCols) {
        currCol -= texCols;
        currY += dy;
        currX = 0;
        ValueCell.update(uCurrentY, currY);
      }
      ValueCell.update(uCurrentX, currX);
      ValueCell.update(uCurrentSlice, i);
      state.viewport(currX, currY, dx, dy);
      state.scissor(currX, currY, dx, dy);
      renderable.render();
      ++currCol;
      currX += dx;
    }
    gl.flush();
  }
  setupDensityRendering(webgl, renderable);
  render(texture, true);
  if (blendMinMax) {
    setupMinDistanceRendering(webgl, renderable);
    render(minDistTex, true);
    setupGroupIdRendering(webgl, renderable);
    render(texture, false);
  }
  return { texture, scale, bbox: expandedBox, gridDim: dim, gridTexDim, gridTexScale, radiusFactor, resolution, maxRadius };
}
function calcGaussianDensityTexture3d(webgl, position3, box3, radius, props, texture) {
  const { gl, resources, state, extensions: { colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat } } = webgl;
  const { smoothness, resolution } = props;
  const { drawCount, positions, radii, groups, scale, expandedBox, dim, maxRadius } = prepareGaussianDensityData(position3, box3, radius, props);
  const [dx, dy, dz] = dim;
  const minDistTex = getTexture("min-dist-3d", webgl, "volume-uint8", "rgba", "ubyte", "nearest");
  minDistTex.define(dx, dy, dz);
  const gridTexScale = Vec2.create(1, 1);
  const radiusFactor = maxRadius * 2;
  const renderable = getGaussianDensityRenderable(webgl, drawCount, positions, radii, groups, minDistTex, expandedBox, dim, dim, gridTexScale, smoothness, resolution, radiusFactor);
  const { uCurrentSlice } = renderable.values;
  const framebuffer = getFramebuffer(webgl);
  framebuffer.bind();
  setRenderingDefaults(webgl);
  state.viewport(0, 0, dx, dy);
  state.scissor(0, 0, dx, dy);
  if (!texture)
    texture = colorBufferHalfFloat && textureHalfFloat ? resources.texture("volume-float16", "rgba", "fp16", "linear") : colorBufferFloat && textureFloat ? resources.texture("volume-float32", "rgba", "float", "linear") : resources.texture("volume-uint8", "rgba", "ubyte", "linear");
  texture.define(dx, dy, dz);
  function render(fbTex, clear) {
    state.currentRenderItemId = -1;
    for (let i = 0; i < dz; ++i) {
      ValueCell.update(uCurrentSlice, i);
      fbTex.attachFramebuffer(framebuffer, 0, i);
      if (clear)
        gl.clear(gl.COLOR_BUFFER_BIT);
      renderable.render();
    }
    gl.flush();
  }
  setupDensityRendering(webgl, renderable);
  render(texture, true);
  setupMinDistanceRendering(webgl, renderable);
  render(minDistTex, true);
  setupGroupIdRendering(webgl, renderable);
  render(texture, false);
  return { texture, scale, bbox: expandedBox, gridDim: dim, gridTexDim: dim, gridTexScale, radiusFactor, resolution, maxRadius };
}
function prepareGaussianDensityData(position3, box3, radius, props) {
  const { resolution, radiusOffset } = props;
  const scaleFactor = 1 / resolution;
  const { indices, x, y, z, id } = position3;
  const n = OrderedSet.size(indices);
  const positions = new Float32Array(n * 3);
  const radii = new Float32Array(n);
  const groups = new Float32Array(n);
  let maxRadius = 0;
  for (let i = 0; i < n; ++i) {
    const j = OrderedSet.getAt(indices, i);
    positions[i * 3] = x[j];
    positions[i * 3 + 1] = y[j];
    positions[i * 3 + 2] = z[j];
    const r = radius(j) + radiusOffset;
    if (maxRadius < r)
      maxRadius = r;
    radii[i] = r;
    groups[i] = id ? id[i] : i;
  }
  const pad = maxRadius * 2 + resolution * 4;
  const expandedBox = Box3D.expand(Box3D(), box3, Vec3.create(pad, pad, pad));
  const scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);
  const dim = Box3D.size(Vec3(), scaledBox);
  Vec3.ceil(dim, dim);
  const scale = Vec3.create(resolution, resolution, resolution);
  return { drawCount: n, positions, radii, groups, scale, expandedBox, dim, maxRadius };
}
function getGaussianDensityRenderable(webgl, drawCount, positions, radii, groups, minDistanceTexture, box3, gridDim, gridTexDim, gridTexScale, smoothness, resolution, radiusFactor) {
  if (webgl.namedComputeRenderables[GaussianDensityName]) {
    const extent = Vec3.sub(Vec3(), box3.max, box3.min);
    const v2 = webgl.namedComputeRenderables[GaussianDensityName].values;
    ValueCell.updateIfChanged(v2.drawCount, drawCount);
    ValueCell.updateIfChanged(v2.instanceCount, 1);
    ValueCell.update(v2.aRadius, radii);
    ValueCell.update(v2.aPosition, positions);
    ValueCell.update(v2.aGroup, groups);
    ValueCell.updateIfChanged(v2.uCurrentSlice, 0);
    ValueCell.updateIfChanged(v2.uCurrentX, 0);
    ValueCell.updateIfChanged(v2.uCurrentY, 0);
    ValueCell.update(v2.uBboxMin, box3.min);
    ValueCell.update(v2.uBboxSize, extent);
    ValueCell.update(v2.uGridDim, gridDim);
    ValueCell.update(v2.uGridTexDim, gridTexDim);
    ValueCell.update(v2.uGridTexScale, gridTexScale);
    ValueCell.updateIfChanged(v2.uAlpha, smoothness);
    ValueCell.updateIfChanged(v2.uResolution, resolution);
    ValueCell.updateIfChanged(v2.uRadiusFactorInv, 1 / radiusFactor);
    ValueCell.update(v2.tMinDistanceTex, minDistanceTexture);
    ValueCell.updateIfChanged(v2.dGridTexType, minDistanceTexture.getDepth() > 0 ? "3d" : "2d");
    ValueCell.updateIfChanged(v2.dCalcType, "density");
    webgl.namedComputeRenderables[GaussianDensityName].update();
  } else {
    webgl.namedComputeRenderables[GaussianDensityName] = createGaussianDensityRenderable(webgl, drawCount, positions, radii, groups, minDistanceTexture, box3, gridDim, gridTexDim, gridTexScale, smoothness, resolution, radiusFactor);
  }
  return webgl.namedComputeRenderables[GaussianDensityName];
}
function createGaussianDensityRenderable(webgl, drawCount, positions, radii, groups, minDistanceTexture, box3, gridDim, gridTexDim, gridTexScale, smoothness, resolution, radiusFactor) {
  const extent = Vec3.sub(Vec3(), box3.max, box3.min);
  const values2 = {
    drawCount: ValueCell.create(drawCount),
    instanceCount: ValueCell.create(1),
    aRadius: ValueCell.create(radii),
    aPosition: ValueCell.create(positions),
    aGroup: ValueCell.create(groups),
    uCurrentSlice: ValueCell.create(0),
    uCurrentX: ValueCell.create(0),
    uCurrentY: ValueCell.create(0),
    uBboxMin: ValueCell.create(box3.min),
    uBboxSize: ValueCell.create(extent),
    uGridDim: ValueCell.create(gridDim),
    uGridTexDim: ValueCell.create(gridTexDim),
    uGridTexScale: ValueCell.create(gridTexScale),
    uAlpha: ValueCell.create(smoothness),
    uResolution: ValueCell.create(resolution),
    uRadiusFactorInv: ValueCell.create(1 / radiusFactor),
    tMinDistanceTex: ValueCell.create(minDistanceTexture),
    dGridTexType: ValueCell.create(minDistanceTexture.getDepth() > 0 ? "3d" : "2d"),
    dCalcType: ValueCell.create("density")
  };
  const schema = { ...GaussianDensitySchema };
  const shaderCode = ShaderCode(GaussianDensityName, gaussianDensity_vert, gaussianDensity_frag);
  const renderItem = createComputeRenderItem(webgl, "points", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function setRenderingDefaults(ctx) {
  const { gl, state } = ctx;
  state.disable(gl.CULL_FACE);
  state.enable(gl.BLEND);
  state.disable(gl.DEPTH_TEST);
  state.enable(gl.SCISSOR_TEST);
  state.depthMask(false);
  state.clearColor(0, 0, 0, 0);
}
function setupMinDistanceRendering(webgl, renderable) {
  const { gl, state } = webgl;
  ValueCell.update(renderable.values.dCalcType, "minDistance");
  renderable.update();
  state.colorMask(false, false, false, true);
  state.blendFunc(gl.ONE, gl.ONE);
  if (!webgl.extensions.blendMinMax) {
    throw new Error("GPU gaussian surface calculation requires EXT_blend_minmax");
  }
  state.blendEquation(webgl.extensions.blendMinMax.MAX);
}
function setupDensityRendering(webgl, renderable) {
  const { gl, state } = webgl;
  ValueCell.update(renderable.values.dCalcType, "density");
  renderable.update();
  state.colorMask(false, false, false, true);
  state.blendFunc(gl.ONE, gl.ONE);
  state.blendEquation(gl.FUNC_ADD);
}
function setupGroupIdRendering(webgl, renderable) {
  const { gl, state } = webgl;
  ValueCell.update(renderable.values.dCalcType, "groupId");
  renderable.update();
  state.colorMask(true, true, true, false);
  state.blendFunc(gl.ONE, gl.ZERO);
  state.blendEquation(gl.FUNC_ADD);
}
function getTexture2dSize(gridDim) {
  const area = gridDim[0] * gridDim[1] * gridDim[2];
  const squareDim = Math.sqrt(area);
  const powerOfTwoSize = Math.pow(2, Math.ceil(Math.log(squareDim) / Math.log(2)));
  let texDimX = 0;
  let texDimY = gridDim[1];
  let texRows = 1;
  let texCols = gridDim[2];
  if (powerOfTwoSize < gridDim[0] * gridDim[2]) {
    texCols = Math.floor(powerOfTwoSize / gridDim[0]);
    texRows = Math.ceil(gridDim[2] / texCols);
    texDimX = texCols * gridDim[0];
    texDimY *= texRows;
  } else {
    texDimX = gridDim[0] * gridDim[2];
  }
  return { texDimX, texDimY, texRows, texCols, powerOfTwoSize: texDimY < powerOfTwoSize ? powerOfTwoSize : powerOfTwoSize * 2 };
}

// node_modules/molstar/lib/mol-math/geometry/gaussian-density/cpu.js
async function GaussianDensityCPU(ctx, position3, box3, radius, props) {
  const { resolution, radiusOffset, smoothness } = props;
  const scaleFactor = 1 / resolution;
  const { indices, x, y, z, id } = position3;
  const n = OrderedSet.size(indices);
  const radii = new Float32Array(n);
  let maxRadius = 0;
  for (let i = 0; i < n; ++i) {
    const r = radius(OrderedSet.getAt(indices, i)) + radiusOffset;
    if (maxRadius < r)
      maxRadius = r;
    radii[i] = r;
  }
  const pad = maxRadius * 2 + resolution;
  const expandedBox = Box3D.expand(Box3D(), box3, Vec3.create(pad, pad, pad));
  const min2 = expandedBox.min;
  const scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);
  const dim = Box3D.size(Vec3(), scaledBox);
  Vec3.ceil(dim, dim);
  const space2 = Tensor.Space(dim, [0, 1, 2], Float32Array);
  const data = space2.create();
  const field = Tensor.create(space2, data);
  const idData = space2.create();
  idData.fill(-1);
  const idField = Tensor.create(space2, idData);
  const [dimX, dimY, dimZ] = dim;
  const iu = dimZ, iv = dimY, iuv = iu * iv;
  const gridx = fillGridDim(dim[0], min2[0], resolution);
  const gridy = fillGridDim(dim[1], min2[1], resolution);
  const gridz = fillGridDim(dim[2], min2[2], resolution);
  const densData = space2.create();
  const alpha = smoothness;
  const updateChunk = Math.ceil(1e5 / (Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor));
  function accumulateRange(begI, endI) {
    for (let i = begI; i < endI; ++i) {
      const j = OrderedSet.getAt(indices, i);
      const vx = x[j], vy = y[j], vz = z[j];
      const rad = radii[i];
      const rSq = rad * rad;
      const rSqInv = 1 / rSq;
      const r2 = rad * 2;
      const r2sq = r2 * r2;
      const ng = Math.ceil(r2 * scaleFactor);
      const iax = Math.floor(scaleFactor * (vx - min2[0]));
      const iay = Math.floor(scaleFactor * (vy - min2[1]));
      const iaz = Math.floor(scaleFactor * (vz - min2[2]));
      const begX = Math.max(0, iax - ng);
      const begY = Math.max(0, iay - ng);
      const begZ = Math.max(0, iaz - ng);
      const endX = Math.min(dimX, iax + ng + 2);
      const endY = Math.min(dimY, iay + ng + 2);
      const endZ = Math.min(dimZ, iaz + ng + 2);
      for (let xi = begX; xi < endX; ++xi) {
        const dx = gridx[xi] - vx;
        const xIdx = xi * iuv;
        for (let yi = begY; yi < endY; ++yi) {
          const dy = gridy[yi] - vy;
          const dxySq = dx * dx + dy * dy;
          const xyIdx = yi * iu + xIdx;
          for (let zi = begZ; zi < endZ; ++zi) {
            const dz = gridz[zi] - vz;
            const dSq = dxySq + dz * dz;
            if (dSq <= r2sq) {
              const dens = fasterExp(-alpha * (dSq * rSqInv));
              const idx = zi + xyIdx;
              data[idx] += dens;
              if (dens > densData[idx]) {
                densData[idx] = dens;
                idData[idx] = id ? id[i] : i;
              }
            }
          }
        }
      }
    }
  }
  async function accumulate() {
    for (let i = 0; i < n; i += updateChunk) {
      accumulateRange(i, Math.min(i + updateChunk, n));
      if (ctx.shouldUpdate) {
        await ctx.update({ message: "filling density grid", current: i, max: n });
      }
    }
  }
  await accumulate();
  const transform = Mat4.identity();
  Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));
  Mat4.setTranslation(transform, expandedBox.min);
  return { field, idField, transform, radiusFactor: 1, resolution, maxRadius };
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/gaussian.js
var GaussianDensityParams = {
  resolution: ParamDefinition.Numeric(1, { min: 0.1, max: 20, step: 0.1 }, { description: "Grid resolution/cell spacing.", ...BaseGeometry.CustomQualityParamInfo }),
  radiusOffset: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, { description: "Extra/offset radius added to the atoms/coarse elements for gaussian calculation. Useful to create coarse, low resolution surfaces." }),
  smoothness: ParamDefinition.Numeric(1.5, { min: 0.5, max: 2.5, step: 0.1 }, { description: "Smoothness of the gausian surface, lower is smoother." }),
  ...CommonSurfaceParams
};
var DefaultGaussianDensityProps = ParamDefinition.getDefaultValues(GaussianDensityParams);
function getTextureMaxCells(webgl, structure) {
  const d3 = webgl.maxTextureSize / 3;
  return d3 * d3 / Math.max(1, structure ? structure.units.length / 16 : 1);
}
function computeUnitGaussianDensity(structure, unit, sizeTheme, props) {
  const { position: position3, boundary, radius } = getUnitConformationAndRadius(structure, unit, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return Task.create("Gaussian Density", async (ctx) => {
    return await GaussianDensityCPU(ctx, position3, boundary.box, radius, p);
  });
}
function computeUnitGaussianDensityTexture(structure, unit, sizeTheme, props, webgl, texture) {
  const { position: position3, boundary, radius } = getUnitConformationAndRadius(structure, unit, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props, getTextureMaxCells(webgl, structure));
  return GaussianDensityTexture(webgl, position3, boundary.box, radius, p, texture);
}
function computeUnitGaussianDensityTexture2d(structure, unit, sizeTheme, powerOfTwo, props, webgl, texture) {
  const { position: position3, boundary, radius } = getUnitConformationAndRadius(structure, unit, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props, getTextureMaxCells(webgl, structure));
  return GaussianDensityTexture2d(webgl, position3, boundary.box, radius, powerOfTwo, p, texture);
}
function computeStructureGaussianDensity(structure, sizeTheme, props) {
  const { position: position3, boundary, radius } = getStructureConformationAndRadius(structure, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return Task.create("Gaussian Density", async (ctx) => {
    return await GaussianDensityCPU(ctx, position3, boundary.box, radius, p);
  });
}
function computeStructureGaussianDensityTexture(structure, sizeTheme, props, webgl, texture) {
  const { position: position3, boundary, radius } = getStructureConformationAndRadius(structure, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return GaussianDensityTexture(webgl, position3, boundary.box, radius, p, texture);
}
function computeStructureGaussianDensityTexture2d(structure, sizeTheme, powerOfTwo, props, webgl, texture) {
  const { box: box3 } = structure.lookup3d.boundary;
  const { position: position3, boundary, radius } = getStructureConformationAndRadius(structure, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return GaussianDensityTexture2d(webgl, position3, box3, radius, powerOfTwo, p, texture);
}

// node_modules/molstar/lib/mol-repr/structure/visual/gaussian-surface-mesh.js
var SharedParams = {
  ...GaussianDensityParams,
  ...ColorSmoothingParams,
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  tryUseGpu: ParamDefinition.Boolean(true),
  includeParent: ParamDefinition.Boolean(false, { isHidden: true })
};
var GaussianSurfaceMeshParams = {
  ...UnitsMeshParams,
  ...UnitsTextureMeshParams,
  ...SharedParams
};
var StructureGaussianSurfaceMeshParams = {
  ...ComplexMeshParams,
  ...ComplexTextureMeshParams,
  ...SharedParams
};
function gpuSupport(webgl) {
  return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.textureFloatLinear && webgl.extensions.blendMinMax && webgl.extensions.drawBuffers;
}
function suitableForGpu(structure, props, webgl) {
  if (props.resolution > 1)
    return false;
  const d3 = webgl.maxTextureSize / 3;
  const { areaCells, maxAreaCells } = getVolumeSliceInfo(structure.boundary.box, props.resolution, d3 * d3);
  return areaCells < maxAreaCells;
}
function GaussianSurfaceVisual(materialId, structure, props, webgl) {
  if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {
    return GaussianSurfaceTextureMeshVisual(materialId);
  }
  return GaussianSurfaceMeshVisual(materialId);
}
function StructureGaussianSurfaceVisual(materialId, structure, props, webgl) {
  if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {
    return StructureGaussianSurfaceTextureMeshVisual(materialId);
  }
  return StructureGaussianSurfaceMeshVisual(materialId);
}
async function createGaussianSurfaceMesh(ctx, unit, structure, theme, props, mesh) {
  const { smoothness } = props;
  const { transform, field, idField, radiusFactor, resolution, maxRadius } = await computeUnitGaussianDensity(structure, unit, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: Math.exp(-smoothness) / radiusFactor,
    scalarField: field,
    idField
  };
  const surface = await computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime);
  surface.meta.resolution = resolution;
  Mesh.transform(surface, transform);
  if (ctx.webgl && !ctx.webgl.isWebGL2) {
    Mesh.uniformTriangleGroup(surface);
    ValueCell.updateIfChanged(surface.varyingGroup, false);
  } else {
    ValueCell.updateIfChanged(surface.varyingGroup, true);
  }
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, maxRadius);
  surface.setBoundingSphere(sphere);
  return surface;
}
function GaussianSurfaceMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(GaussianSurfaceMeshParams),
    createGeometry: createGaussianSurfaceMesh,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseGpu && !!webgl && suitableForGpu(structureGroup.structure, props, webgl);
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp) {
        applyMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}
async function createStructureGaussianSurfaceMesh(ctx, structure, theme, props, mesh) {
  const { smoothness } = props;
  const { transform, field, idField, radiusFactor, resolution, maxRadius } = await computeStructureGaussianDensity(structure, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: Math.exp(-smoothness) / radiusFactor,
    scalarField: field,
    idField
  };
  const surface = await computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime);
  surface.meta.resolution = resolution;
  Mesh.transform(surface, transform);
  if (ctx.webgl && !ctx.webgl.isWebGL2) {
    Mesh.uniformTriangleGroup(surface);
    ValueCell.updateIfChanged(surface.varyingGroup, false);
  } else {
    ValueCell.updateIfChanged(surface.varyingGroup, true);
  }
  const sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, maxRadius);
  surface.setBoundingSphere(sphere);
  return surface;
}
function StructureGaussianSurfaceMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureGaussianSurfaceMeshParams),
    createGeometry: createStructureGaussianSurfaceMesh,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return props.tryUseGpu && !!webgl && suitableForGpu(structure, props, webgl);
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp) {
        applyMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}
var GaussianSurfaceName = "gaussian-surface";
function createGaussianSurfaceTextureMesh(ctx, unit, structure, theme, props, textureMesh) {
  const { webgl } = ctx;
  if (!webgl)
    throw new Error("webgl context required to create gaussian surface texture-mesh");
  const { namedTextures, resources, extensions: { colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat } } = webgl;
  if (!namedTextures[GaussianSurfaceName]) {
    namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat ? resources.texture("image-float16", "rgba", "fp16", "linear") : colorBufferFloat && textureFloat ? resources.texture("image-float32", "rgba", "float", "linear") : resources.texture("image-uint8", "rgba", "ubyte", "linear");
  }
  const axisOrder = Vec3.create(0, 1, 2);
  const groupCount = unit.elements.length;
  const create2 = (textureMesh2) => {
    if (isTimingMode)
      webgl.timer.mark("createGaussianSurfaceTextureMesh");
    const densityTextureData = computeUnitGaussianDensityTexture2d(structure, unit, theme.size, true, props, webgl, namedTextures[GaussianSurfaceName]);
    const isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;
    const buffer2 = textureMesh2 === null || textureMesh2 === void 0 ? void 0 : textureMesh2.doubleBuffer.get();
    const gv = extractIsosurface(webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, axisOrder, true, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.vertex, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.group, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.normal);
    if (isTimingMode)
      webgl.timer.markEnd("createGaussianSurfaceTextureMesh");
    const boundingSphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, densityTextureData.maxRadius);
    const surface2 = TextureMesh.create(gv.vertexCount, groupCount, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh2);
    surface2.meta.resolution = densityTextureData.resolution;
    return surface2;
  };
  const surface = create2(textureMesh);
  surface.meta.webgl = webgl;
  surface.meta.reset = () => {
    create2(surface);
  };
  return surface;
}
function GaussianSurfaceTextureMeshVisual(materialId) {
  return UnitsTextureMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(GaussianSurfaceMeshParams),
    createGeometry: createGaussianSurfaceTextureMesh,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseGpu || !webgl || !suitableForGpu(structureGroup.structure, props, webgl);
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp && webgl) {
        applyTextureMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      geometry.vertexTexture.ref.value.destroy();
      geometry.groupTexture.ref.value.destroy();
      geometry.normalTexture.ref.value.destroy();
      geometry.doubleBuffer.destroy();
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}
function createStructureGaussianSurfaceTextureMesh(ctx, structure, theme, props, textureMesh) {
  const { webgl } = ctx;
  if (!webgl)
    throw new Error("webgl context required to create structure gaussian surface texture-mesh");
  const { namedTextures, resources, extensions: { colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat } } = webgl;
  if (!namedTextures[GaussianSurfaceName]) {
    namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat ? resources.texture("image-float16", "rgba", "fp16", "linear") : colorBufferFloat && textureFloat ? resources.texture("image-float32", "rgba", "float", "linear") : resources.texture("image-uint8", "rgba", "ubyte", "linear");
  }
  const axisOrder = Vec3.create(0, 1, 2);
  const groupCount = structure.elementCount;
  const create2 = (textureMesh2) => {
    if (isTimingMode)
      webgl.timer.mark("createStructureGaussianSurfaceTextureMesh");
    const densityTextureData = computeStructureGaussianDensityTexture2d(structure, theme.size, true, props, webgl, namedTextures[GaussianSurfaceName]);
    const isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;
    const buffer2 = textureMesh2 === null || textureMesh2 === void 0 ? void 0 : textureMesh2.doubleBuffer.get();
    const gv = extractIsosurface(webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, axisOrder, true, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.vertex, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.group, buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.normal);
    if (isTimingMode)
      webgl.timer.markEnd("createStructureGaussianSurfaceTextureMesh");
    const boundingSphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, densityTextureData.maxRadius);
    const surface2 = TextureMesh.create(gv.vertexCount, groupCount, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh2);
    surface2.meta.resolution = densityTextureData.resolution;
    return surface2;
  };
  const surface = create2(textureMesh);
  surface.meta.webgl = webgl;
  surface.meta.reset = () => {
    create2(surface);
  };
  return surface;
}
function StructureGaussianSurfaceTextureMeshVisual(materialId) {
  return ComplexTextureMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureGaussianSurfaceMeshParams),
    createGeometry: createStructureGaussianSurfaceTextureMesh,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    mustRecreate: (structure, props, webgl) => {
      return !props.tryUseGpu || !webgl || !suitableForGpu(structure, props, webgl);
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp && webgl) {
        applyTextureMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      geometry.vertexTexture.ref.value.destroy();
      geometry.groupTexture.ref.value.destroy();
      geometry.normalTexture.ref.value.destroy();
      geometry.doubleBuffer.destroy();
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/gaussian-surface-wireframe.js
async function createGaussianWireframe(ctx, unit, structure, theme, props, lines) {
  const { smoothness } = props;
  const { transform, field, idField, maxRadius } = await computeUnitGaussianDensity(structure, unit, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: Math.exp(-smoothness),
    scalarField: field,
    idField
  };
  const wireframe = await computeMarchingCubesLines(params, lines).runAsChild(ctx.runtime);
  Lines.transform(wireframe, transform);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, maxRadius);
  wireframe.setBoundingSphere(sphere);
  return wireframe;
}
var GaussianWireframeParams = {
  ...UnitsLinesParams,
  ...GaussianDensityParams,
  sizeFactor: ParamDefinition.Numeric(3, { min: 0, max: 10, step: 0.1 }),
  lineSizeAttenuation: ParamDefinition.Boolean(false),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  includeParent: ParamDefinition.Boolean(false, { isHidden: true })
};
function GaussianWireframeVisual(materialId) {
  return UnitsLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(GaussianWireframeParams),
    createGeometry: createGaussianWireframe,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/gaussian-surface.js
var GaussianSurfaceVisuals = {
  "gaussian-surface-mesh": (ctx, getParams) => UnitsRepresentation("Gaussian surface mesh", ctx, getParams, GaussianSurfaceVisual),
  "structure-gaussian-surface-mesh": (ctx, getParams) => ComplexRepresentation("Structure-Gaussian surface mesh", ctx, getParams, StructureGaussianSurfaceVisual),
  "gaussian-surface-wireframe": (ctx, getParams) => UnitsRepresentation("Gaussian surface wireframe", ctx, getParams, GaussianWireframeVisual)
};
var GaussianSurfaceParams = {
  ...GaussianSurfaceMeshParams,
  ...GaussianWireframeParams,
  visuals: ParamDefinition.MultiSelect(["gaussian-surface-mesh"], ParamDefinition.objectToOptions(GaussianSurfaceVisuals)),
  bumpFrequency: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getGaussianSurfaceParams(ctx, structure) {
  return GaussianSurfaceParams;
}
function GaussianSurfaceRepresentation(ctx, getParams) {
  return Representation.createMulti("Gaussian Surface", ctx, getParams, StructureRepresentationStateBuilder, GaussianSurfaceVisuals);
}
var GaussianSurfaceRepresentationProvider = StructureRepresentationProvider({
  name: "gaussian-surface",
  label: "Gaussian Surface",
  description: "Displays a gaussian molecular surface.",
  factory: GaussianSurfaceRepresentation,
  getParams: getGaussianSurfaceParams,
  defaultValues: ParamDefinition.getDefaultValues(GaussianSurfaceParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/label-text.js
var LabelTextParams = {
  ...ComplexTextParams,
  background: ParamDefinition.Boolean(false),
  backgroundMargin: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }),
  backgroundColor: ParamDefinition.Color(ColorNames.black),
  backgroundOpacity: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),
  borderWidth: ParamDefinition.Numeric(0.25, { min: 0, max: 0.5, step: 0.01 }),
  level: ParamDefinition.Select("residue", [["chain", "Chain"], ["residue", "Residue"], ["element", "Element"]], { isEssential: true }),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  chainScale: ParamDefinition.Numeric(10, { min: 0, max: 20, step: 0.1 }),
  residueScale: ParamDefinition.Numeric(1, { min: 0, max: 20, step: 0.1 }),
  elementScale: ParamDefinition.Numeric(0.5, { min: 0, max: 20, step: 0.1 })
};
function LabelTextVisual(materialId) {
  return ComplexTextVisual({
    defaultProps: ParamDefinition.getDefaultValues(LabelTextParams),
    createGeometry: createLabelText,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.level !== currentProps.level || newProps.level === "chain" && newProps.chainScale !== currentProps.chainScale || newProps.level === "residue" && newProps.residueScale !== currentProps.residueScale || newProps.level === "element" && newProps.elementScale !== currentProps.elementScale || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant;
    }
  }, materialId);
}
function createLabelText(ctx, structure, theme, props, text5) {
  switch (props.level) {
    case "chain":
      return createChainText(ctx, structure, theme, props, text5);
    case "residue":
      return createResidueText(ctx, structure, theme, props, text5);
    case "element":
      return createElementText(ctx, structure, theme, props, text5);
  }
}
var tmpVec = Vec3();
var boundaryHelper3 = new BoundaryHelper("98");
function createChainText(ctx, structure, theme, props, text5) {
  const l = element_exports.Location.create(structure);
  const { units, serialMapping } = structure;
  const { auth_asym_id, label_asym_id } = StructureProperties.chain;
  const { cumulativeUnitElementCount } = serialMapping;
  const count2 = units.length;
  const { chainScale } = props;
  const builder = TextBuilder.create(props, count2, count2 / 2, text5);
  for (let i = 0, il = units.length; i < il; ++i) {
    const unit = units[i];
    l.unit = unit;
    l.element = unit.elements[0];
    const { center: center2, radius } = unit.lookup3d.boundary.sphere;
    Vec3.transformMat4(tmpVec, center2, unit.conformation.operator.matrix);
    const authId = auth_asym_id(l);
    const labelId = label_asym_id(l);
    const text6 = authId === labelId ? labelId : `${labelId} [${authId}]`;
    builder.add(text6, tmpVec[0], tmpVec[1], tmpVec[2], radius, chainScale, cumulativeUnitElementCount[i]);
  }
  return builder.getText();
}
function createResidueText(ctx, structure, theme, props, text5) {
  const l = element_exports.Location.create(structure);
  const { units, serialMapping } = structure;
  const { label_comp_id } = StructureProperties.atom;
  const { auth_seq_id } = StructureProperties.residue;
  const { cumulativeUnitElementCount } = serialMapping;
  const count2 = structure.polymerResidueCount * 2;
  const { residueScale } = props;
  const builder = TextBuilder.create(props, count2, count2 / 2, text5);
  for (let i = 0, il = units.length; i < il; ++i) {
    const unit = units[i];
    const c4 = unit.conformation;
    const { elements } = unit;
    l.unit = unit;
    l.element = unit.elements[0];
    const residueIndex = unit.model.atomicHierarchy.residueAtomSegments.index;
    const groupOffset = cumulativeUnitElementCount[i];
    let j = 0;
    const jl = elements.length;
    while (j < jl) {
      const start2 = j, rI = residueIndex[elements[j]];
      j++;
      while (j < jl && residueIndex[elements[j]] === rI)
        j++;
      boundaryHelper3.reset();
      for (let eI = start2; eI < j; eI++) {
        c4.position(elements[eI], tmpVec);
        boundaryHelper3.includePosition(tmpVec);
      }
      boundaryHelper3.finishedIncludeStep();
      for (let eI = start2; eI < j; eI++) {
        c4.position(elements[eI], tmpVec);
        boundaryHelper3.radiusPosition(tmpVec);
      }
      l.element = elements[start2];
      const { center: center2, radius } = boundaryHelper3.getSphere();
      const authSeqId = auth_seq_id(l);
      const compId = label_comp_id(l);
      const text6 = `${compId} ${authSeqId}`;
      builder.add(text6, center2[0], center2[1], center2[2], radius, residueScale, groupOffset + start2);
    }
  }
  return builder.getText();
}
function createElementText(ctx, structure, theme, props, text5) {
  const l = element_exports.Location.create(structure);
  const { units, serialMapping } = structure;
  const { label_atom_id, label_alt_id } = StructureProperties.atom;
  const { cumulativeUnitElementCount } = serialMapping;
  const sizeTheme = theme.size;
  const count2 = structure.elementCount;
  const { elementScale } = props;
  const builder = TextBuilder.create(props, count2, count2 / 2, text5);
  for (let i = 0, il = units.length; i < il; ++i) {
    const unit = units[i];
    const c4 = unit.conformation;
    const { elements } = unit;
    l.unit = unit;
    const groupOffset = cumulativeUnitElementCount[i];
    const ignore2 = makeElementIgnoreTest(structure, unit, { ...props, traceOnly: false });
    for (let j = 0, _j = elements.length; j < _j; j++) {
      if (ignore2 && ignore2(elements[j]))
        continue;
      l.element = elements[j];
      c4.position(l.element, tmpVec);
      const atomId = label_atom_id(l);
      const altId = label_alt_id(l);
      const text6 = altId ? `${atomId}%${altId}` : atomId;
      builder.add(text6, tmpVec[0], tmpVec[1], tmpVec[2], sizeTheme.size(l), elementScale, groupOffset + j);
    }
  }
  return builder.getText();
}

// node_modules/molstar/lib/mol-repr/structure/representation/label.js
var LabelVisuals = {
  "label-text": (ctx, getParams) => ComplexRepresentation("Label text", ctx, getParams, LabelTextVisual)
};
var LabelParams = {
  ...LabelTextParams,
  visuals: ParamDefinition.MultiSelect(["label-text"], ParamDefinition.objectToOptions(LabelVisuals))
};
function getLabelParams(ctx, structure) {
  return LabelParams;
}
function LabelRepresentation(ctx, getParams) {
  const repr = Representation.createMulti("Label", ctx, getParams, StructureRepresentationStateBuilder, LabelVisuals);
  repr.setState({ pickable: false, markerActions: MarkerAction.None });
  return repr;
}
var LabelRepresentationProvider = StructureRepresentationProvider({
  name: "label",
  label: "Label",
  description: "Displays labels.",
  factory: LabelRepresentation,
  getParams: getLabelParams,
  defaultValues: ParamDefinition.getDefaultValues(LabelParams),
  defaultColorTheme: { name: "uniform" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-math/geometry/molecular-surface.js
function normalToLine(out, p) {
  out[0] = out[1] = out[2] = 1;
  if (p[0] !== 0) {
    out[0] = (p[1] + p[2]) / -p[0];
  } else if (p[1] !== 0) {
    out[1] = (p[0] + p[2]) / -p[1];
  } else if (p[2] !== 0) {
    out[2] = (p[0] + p[1]) / -p[2];
  }
  return out;
}
function getAngleTables(probePositions) {
  let theta = 0;
  const step = 2 * Math.PI / probePositions;
  const cosTable = new Float32Array(probePositions);
  const sinTable = new Float32Array(probePositions);
  for (let i = 0; i < probePositions; i++) {
    cosTable[i] = Math.cos(theta);
    sinTable[i] = Math.sin(theta);
    theta += step;
  }
  return { cosTable, sinTable };
}
var MolecularSurfaceCalculationParams = {
  probeRadius: ParamDefinition.Numeric(1.4, { min: 0, max: 10, step: 0.1 }, { description: "Radius of the probe tracing the molecular surface." }),
  resolution: ParamDefinition.Numeric(0.5, { min: 0.01, max: 20, step: 0.01 }, { description: "Grid resolution/cell spacing.", ...BaseGeometry.CustomQualityParamInfo }),
  probePositions: ParamDefinition.Numeric(36, { min: 12, max: 90, step: 1 }, { description: "Number of positions tested for probe target intersection.", ...BaseGeometry.CustomQualityParamInfo })
};
var DefaultMolecularSurfaceCalculationProps = ParamDefinition.getDefaultValues(MolecularSurfaceCalculationParams);
async function calcMolecularSurface(ctx, position3, boundary, maxRadius, box3, props) {
  let lastClip = -1;
  function obscured(x, y, z, a4, b4) {
    if (lastClip !== -1) {
      const ai = lastClip;
      if (ai !== a4 && ai !== b4 && singleAtomObscures(ai, x, y, z)) {
        return ai;
      } else {
        lastClip = -1;
      }
    }
    for (let j = 0, jl = neighbours.count; j < jl; ++j) {
      const ai = OrderedSet.getAt(indices, neighbours.indices[j]);
      if (ai !== a4 && ai !== b4 && singleAtomObscures(ai, x, y, z)) {
        lastClip = ai;
        return ai;
      }
    }
    return -1;
  }
  function singleAtomObscures(ai, x, y, z) {
    const r = radius[ai];
    const dx = px[ai] - x;
    const dy = py[ai] - y;
    const dz = pz[ai] - z;
    const dSq = dx * dx + dy * dy + dz * dz;
    return dSq < r * r;
  }
  function projectPointsRange(begI, endI) {
    for (let i = begI; i < endI; ++i) {
      const j = OrderedSet.getAt(indices, i);
      const vx = px[j], vy = py[j], vz = pz[j];
      const rad = radius[j];
      const rSq = rad * rad;
      lookup3d.find(vx, vy, vz, rad);
      const ng = Math.ceil(rad * scaleFactor);
      const iax = Math.floor(scaleFactor * (vx - minX));
      const iay = Math.floor(scaleFactor * (vy - minY));
      const iaz = Math.floor(scaleFactor * (vz - minZ));
      const begX = Math.max(0, iax - ng);
      const begY = Math.max(0, iay - ng);
      const begZ = Math.max(0, iaz - ng);
      const endX = Math.min(dimX, iax + ng + 2);
      const endY = Math.min(dimY, iay + ng + 2);
      const endZ = Math.min(dimZ, iaz + ng + 2);
      for (let xi = begX; xi < endX; ++xi) {
        const dx = gridx[xi] - vx;
        const xIdx = xi * iuv;
        for (let yi = begY; yi < endY; ++yi) {
          const dy = gridy[yi] - vy;
          const dxySq = dx * dx + dy * dy;
          const xyIdx = yi * iu + xIdx;
          for (let zi = begZ; zi < endZ; ++zi) {
            const dz = gridz[zi] - vz;
            const dSq = dxySq + dz * dz;
            if (dSq < rSq) {
              const idx = zi + xyIdx;
              if (data[idx] < 0)
                data[idx] *= -1;
              const d3 = Math.sqrt(dSq);
              const ap = rad / d3;
              const spx = dx * ap + vx;
              const spy = dy * ap + vy;
              const spz = dz * ap + vz;
              if (obscured(spx, spy, spz, j, -1) === -1) {
                const dd = rad - d3;
                if (dd < data[idx]) {
                  data[idx] = dd;
                  idData[idx] = id[i];
                }
              }
            }
          }
        }
      }
    }
  }
  async function projectPoints() {
    for (let i = 0; i < n; i += updateChunk) {
      projectPointsRange(i, Math.min(i + updateChunk, n));
      if (ctx.shouldUpdate) {
        await ctx.update({ message: "projecting points", current: i, max: n });
      }
    }
  }
  const atob = Vec3();
  const mid2 = Vec3();
  const n12 = Vec3();
  const n2 = Vec3();
  function projectTorus(a4, b4) {
    const rA = radius[a4];
    const rB = radius[b4];
    const dx = atob[0] = px[b4] - px[a4];
    const dy = atob[1] = py[b4] - py[a4];
    const dz = atob[2] = pz[b4] - pz[a4];
    const dSq = dx * dx + dy * dy + dz * dz;
    const d3 = Math.sqrt(dSq);
    const cosA = (rA * rA + d3 * d3 - rB * rB) / (2 * rA * d3);
    const dmp = rA * cosA;
    Vec3.normalize(atob, atob);
    normalToLine(n12, atob);
    Vec3.normalize(n12, n12);
    Vec3.cross(n2, atob, n12);
    Vec3.normalize(n2, n2);
    const rInt = Math.sqrt(rA * rA - dmp * dmp);
    Vec3.scale(n12, n12, rInt);
    Vec3.scale(n2, n2, rInt);
    Vec3.scale(atob, atob, dmp);
    mid2[0] = atob[0] + px[a4];
    mid2[1] = atob[1] + py[a4];
    mid2[2] = atob[2] + pz[a4];
    lastClip = -1;
    for (let i = 0; i < probePositions; ++i) {
      const cost = cosTable[i];
      const sint = sinTable[i];
      const px2 = mid2[0] + cost * n12[0] + sint * n2[0];
      const py2 = mid2[1] + cost * n12[1] + sint * n2[1];
      const pz2 = mid2[2] + cost * n12[2] + sint * n2[2];
      if (obscured(px2, py2, pz2, a4, b4) === -1) {
        const iax = Math.floor(scaleFactor * (px2 - minX));
        const iay = Math.floor(scaleFactor * (py2 - minY));
        const iaz = Math.floor(scaleFactor * (pz2 - minZ));
        const begX = Math.max(0, iax - ngTorus);
        const begY = Math.max(0, iay - ngTorus);
        const begZ = Math.max(0, iaz - ngTorus);
        const endX = Math.min(dimX, iax + ngTorus + 2);
        const endY = Math.min(dimY, iay + ngTorus + 2);
        const endZ = Math.min(dimZ, iaz + ngTorus + 2);
        for (let xi = begX; xi < endX; ++xi) {
          const dx2 = px2 - gridx[xi];
          const xIdx = xi * iuv;
          for (let yi = begY; yi < endY; ++yi) {
            const dy2 = py2 - gridy[yi];
            const dxySq = dx2 * dx2 + dy2 * dy2;
            const xyIdx = yi * iu + xIdx;
            for (let zi = begZ; zi < endZ; ++zi) {
              const dz2 = pz2 - gridz[zi];
              const dSq2 = dxySq + dz2 * dz2;
              const idx = zi + xyIdx;
              const current = data[idx];
              if (current > 0 && dSq2 < current * current) {
                data[idx] = Math.sqrt(dSq2);
                const dp = dx2 * atob[0] + dy2 * atob[1] + dz2 * atob[2];
                idData[idx] = id[OrderedSet.indexOf(indices, dp < 0 ? b4 : a4)];
              }
            }
          }
        }
      }
    }
  }
  function projectToriiRange(begI, endI) {
    for (let i = begI; i < endI; ++i) {
      const k = OrderedSet.getAt(indices, i);
      lookup3d.find(px[k], py[k], pz[k], radius[k]);
      for (let j = 0, jl = neighbours.count; j < jl; ++j) {
        const l = OrderedSet.getAt(indices, neighbours.indices[j]);
        if (k < l)
          projectTorus(k, l);
      }
    }
  }
  async function projectTorii() {
    for (let i = 0; i < n; i += updateChunk) {
      projectToriiRange(i, Math.min(i + updateChunk, n));
      if (ctx.shouldUpdate) {
        await ctx.update({ message: "projecting torii", current: i, max: n });
      }
    }
  }
  const { resolution, probeRadius, probePositions } = props;
  const scaleFactor = 1 / resolution;
  const ngTorus = Math.max(5, 2 + Math.floor(probeRadius * scaleFactor));
  const cellSize = Vec3.create(maxRadius, maxRadius, maxRadius);
  Vec3.scale(cellSize, cellSize, 2);
  const lookup3d = GridLookup3D(position3, boundary, cellSize);
  const neighbours = lookup3d.result;
  if (box3 === null)
    box3 = lookup3d.boundary.box;
  const { indices, x: px, y: py, z: pz, id, radius } = position3;
  const n = OrderedSet.size(indices);
  const pad = maxRadius + resolution;
  const expandedBox = Box3D.expand(Box3D(), box3, Vec3.create(pad, pad, pad));
  const [minX, minY, minZ] = expandedBox.min;
  const scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);
  const dim = Box3D.size(Vec3(), scaledBox);
  Vec3.ceil(dim, dim);
  const [dimX, dimY, dimZ] = dim;
  const iu = dimZ, iv = dimY, iuv = iu * iv;
  const { cosTable, sinTable } = getAngleTables(probePositions);
  const space2 = Tensor.Space(dim, [0, 1, 2], Float32Array);
  const data = space2.create();
  const idData = space2.create();
  data.fill(-1001);
  idData.fill(-1);
  const gridx = fillGridDim(dimX, minX, resolution);
  const gridy = fillGridDim(dimY, minY, resolution);
  const gridz = fillGridDim(dimZ, minZ, resolution);
  const updateChunk = Math.ceil(1e5 / (Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor));
  await projectPoints();
  await projectTorii();
  const field = Tensor.create(space2, data);
  const idField = Tensor.create(space2, idData);
  const transform = Mat4.identity();
  Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));
  Mat4.setTranslation(transform, expandedBox.min);
  return { field, idField, transform, resolution, maxRadius };
}

// node_modules/molstar/lib/mol-repr/structure/visual/util/molecular-surface.js
function getUnitPositionDataAndMaxRadius(structure, unit, sizeTheme, props) {
  const { probeRadius } = props;
  const { position: position3, boundary, radius } = getUnitConformationAndRadius(structure, unit, sizeTheme, props);
  const { indices } = position3;
  const n = OrderedSet.size(indices);
  const radii = new Float32Array(OrderedSet.end(indices));
  let maxRadius = 0;
  for (let i = 0; i < n; ++i) {
    const j = OrderedSet.getAt(indices, i);
    const r = radius(j);
    if (maxRadius < r)
      maxRadius = r;
    radii[j] = r + probeRadius;
  }
  return { position: { ...position3, radius: radii }, boundary, maxRadius };
}
function computeUnitMolecularSurface(structure, unit, sizeTheme, props) {
  const { position: position3, boundary, maxRadius } = getUnitPositionDataAndMaxRadius(structure, unit, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return Task.create("Molecular Surface", async (ctx) => {
    return await MolecularSurface(ctx, position3, boundary, maxRadius, boundary.box, p);
  });
}
function getStructurePositionDataAndMaxRadius(structure, sizeTheme, props) {
  const { probeRadius } = props;
  const { position: position3, boundary, radius } = getStructureConformationAndRadius(structure, sizeTheme, props);
  const { indices } = position3;
  const n = OrderedSet.size(indices);
  const radii = new Float32Array(OrderedSet.end(indices));
  let maxRadius = 0;
  for (let i = 0; i < n; ++i) {
    const j = OrderedSet.getAt(indices, i);
    const r = radius(j);
    if (maxRadius < r)
      maxRadius = r;
    radii[j] = r + probeRadius;
  }
  return { position: { ...position3, radius: radii }, boundary, maxRadius };
}
function computeStructureMolecularSurface(structure, sizeTheme, props) {
  const { position: position3, boundary, maxRadius } = getStructurePositionDataAndMaxRadius(structure, sizeTheme, props);
  const p = ensureReasonableResolution(boundary.box, props);
  return Task.create("Molecular Surface", async (ctx) => {
    return await MolecularSurface(ctx, position3, boundary, maxRadius, boundary.box, p);
  });
}
async function MolecularSurface(ctx, position3, boundary, maxRadius, box3, props) {
  return calcMolecularSurface(ctx, position3, boundary, maxRadius, box3, props);
}

// node_modules/molstar/lib/mol-repr/structure/visual/molecular-surface-mesh.js
var MolecularSurfaceMeshParams = {
  ...UnitsMeshParams,
  ...MolecularSurfaceCalculationParams,
  ...CommonSurfaceParams,
  ...ColorSmoothingParams
};
async function createMolecularSurfaceMesh(ctx, unit, structure, theme, props, mesh) {
  const { transform, field, idField, resolution, maxRadius } = await computeUnitMolecularSurface(structure, unit, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: props.probeRadius,
    scalarField: field,
    idField
  };
  const surface = await computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime);
  if (props.includeParent) {
    const iterations = Math.ceil(2 / props.resolution);
    Mesh.smoothEdges(surface, { iterations, maxNewEdgeLength: Math.sqrt(2) });
  }
  Mesh.transform(surface, transform);
  if (ctx.webgl && !ctx.webgl.isWebGL2) {
    Mesh.uniformTriangleGroup(surface);
    ValueCell.updateIfChanged(surface.varyingGroup, false);
  } else {
    ValueCell.updateIfChanged(surface.varyingGroup, true);
  }
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, maxRadius);
  surface.setBoundingSphere(sphere);
  surface.meta.resolution = resolution;
  return surface;
}
function MolecularSurfaceMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(MolecularSurfaceMeshParams),
    createGeometry: createMolecularSurfaceMesh,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.probeRadius !== currentProps.probeRadius)
        state.createGeometry = true;
      if (newProps.probePositions !== currentProps.probePositions)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp) {
        applyMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}
async function createStructureMolecularSurfaceMesh(ctx, structure, theme, props, mesh) {
  const { transform, field, idField, resolution, maxRadius } = await computeStructureMolecularSurface(structure, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: props.probeRadius,
    scalarField: field,
    idField
  };
  const surface = await computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime);
  if (props.includeParent) {
    const iterations = Math.ceil(2 / props.resolution);
    Mesh.smoothEdges(surface, { iterations, maxNewEdgeLength: Math.sqrt(2) });
  }
  Mesh.transform(surface, transform);
  if (ctx.webgl && !ctx.webgl.isWebGL2) {
    Mesh.uniformTriangleGroup(surface);
    ValueCell.updateIfChanged(surface.varyingGroup, false);
  } else {
    ValueCell.updateIfChanged(surface.varyingGroup, true);
  }
  const sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, maxRadius);
  surface.setBoundingSphere(sphere);
  surface.meta.resolution = resolution;
  return surface;
}
function StructureMolecularSurfaceMeshVisual(materialId) {
  return ComplexMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(MolecularSurfaceMeshParams),
    createGeometry: createStructureMolecularSurfaceMesh,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.probeRadius !== currentProps.probeRadius)
        state.createGeometry = true;
      if (newProps.probePositions !== currentProps.probePositions)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {
        state.updateColor = true;
      } else if (newProps.smoothColors.name === "on" && currentProps.smoothColors.name === "on") {
        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)
          state.updateColor = true;
        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)
          state.updateColor = true;
      }
    },
    processValues: (values2, geometry, props, theme, webgl) => {
      const { resolution, colorTexture } = geometry.meta;
      const csp = getColorSmoothingProps(props.smoothColors, theme.color.preferSmoothing, resolution);
      if (csp) {
        applyMeshColorSmoothing(values2, csp.resolution, csp.stride, webgl, colorTexture);
        geometry.meta.colorTexture = values2.tColorGrid.ref.value;
      }
    },
    dispose: (geometry) => {
      var _a;
      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/molecular-surface-wireframe.js
var MolecularSurfaceWireframeParams = {
  ...UnitsLinesParams,
  ...MolecularSurfaceCalculationParams,
  ...CommonSurfaceParams,
  sizeFactor: ParamDefinition.Numeric(1.5, { min: 0, max: 10, step: 0.1 })
};
async function createMolecularSurfaceWireframe(ctx, unit, structure, theme, props, lines) {
  const { transform, field, idField, maxRadius } = await computeUnitMolecularSurface(structure, unit, theme.size, props).runInContext(ctx.runtime);
  const params = {
    isoLevel: props.probeRadius,
    scalarField: field,
    idField
  };
  const wireframe = await computeMarchingCubesLines(params, lines).runAsChild(ctx.runtime);
  Lines.transform(wireframe, transform);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, maxRadius);
  wireframe.setBoundingSphere(sphere);
  return wireframe;
}
function MolecularSurfaceWireframeVisual(materialId) {
  return UnitsLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(MolecularSurfaceWireframeParams),
    createGeometry: createMolecularSurfaceWireframe,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.probeRadius !== currentProps.probeRadius)
        state.createGeometry = true;
      if (newProps.probePositions !== currentProps.probePositions)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/molecular-surface.js
var MolecularSurfaceVisuals = {
  "molecular-surface-mesh": (ctx, getParams) => UnitsRepresentation("Molecular surface mesh", ctx, getParams, MolecularSurfaceMeshVisual),
  "structure-molecular-surface-mesh": (ctx, getParams) => ComplexRepresentation("Structure Molecular surface mesh", ctx, getParams, StructureMolecularSurfaceMeshVisual),
  "molecular-surface-wireframe": (ctx, getParams) => UnitsRepresentation("Molecular surface wireframe", ctx, getParams, MolecularSurfaceWireframeVisual)
};
var MolecularSurfaceParams = {
  ...MolecularSurfaceMeshParams,
  ...MolecularSurfaceWireframeParams,
  visuals: ParamDefinition.MultiSelect(["molecular-surface-mesh"], ParamDefinition.objectToOptions(MolecularSurfaceVisuals)),
  bumpFrequency: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getMolecularSurfaceParams(ctx, structure) {
  return MolecularSurfaceParams;
}
function MolecularSurfaceRepresentation(ctx, getParams) {
  return Representation.createMulti("Molecular Surface", ctx, getParams, StructureRepresentationStateBuilder, MolecularSurfaceVisuals);
}
var MolecularSurfaceRepresentationProvider = StructureRepresentationProvider({
  name: "molecular-surface",
  label: "Molecular Surface",
  description: "Displays a molecular surface.",
  factory: MolecularSurfaceRepresentation,
  getParams: getMolecularSurfaceParams,
  defaultValues: ParamDefinition.getDefaultValues(MolecularSurfaceParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/orientation-ellipsoid-mesh.js
var OrientationEllipsoidMeshParams = {
  ...UnitsMeshParams,
  sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 2, step: 0.1 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo)
};
function OrientationEllipsoidMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(OrientationEllipsoidMeshParams),
    createGeometry: createOrientationEllipsoidMesh,
    createLocationIterator: UnitIterator,
    getLoci: getUnitLoci,
    eachLocation: eachUnit,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail;
    }
  }, materialId);
}
function isUnitApplicable(unit) {
  if (Unit.Traits.is(unit.traits, Unit.Trait.MultiChain))
    return false;
  if (Unit.Traits.is(unit.traits, Unit.Trait.Partitioned))
    return false;
  if (Unit.isCoarse(unit))
    return true;
  if (unit.elements.length === 0)
    return false;
  unit.model.atomicHierarchy.derived.residue.moleculeType;
  const rI = unit.residueIndex[unit.elements[0]];
  const mt = unit.model.atomicHierarchy.derived.residue.moleculeType[rI];
  if (mt === MoleculeType.Ion)
    return false;
  if (mt === MoleculeType.Water)
    return false;
  return true;
}
function createOrientationEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {
  if (!isUnitApplicable(unit))
    return Mesh.createEmpty(mesh);
  const { detail, sizeFactor } = props;
  const vertexCount = 256;
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const axes = unit.principalAxes.boxAxes;
  const { origin, dirA, dirB } = axes;
  const size = Axes3D.size(Vec3(), axes);
  Vec3.scale(size, size, sizeFactor / 2);
  const radiusScale = Vec3.create(size[2], size[1], size[0]);
  builderState.currentGroup = 0;
  addEllipsoid(builderState, origin, dirA, dirB, radiusScale, detail + 1);
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
function UnitIterator(structureGroup) {
  const { group, structure } = structureGroup;
  const groupCount = 1;
  const instanceCount = group.units.length;
  const location = element_exports.Location.create(structure);
  const getLocation = (groupIndex, instanceIndex) => {
    const unit = group.units[instanceIndex];
    location.unit = unit;
    location.element = unit.elements[groupIndex];
    return location;
  };
  return LocationIterator(groupCount, instanceCount, 1, getLocation);
}
function getUnitLoci(pickingId, structureGroup, id) {
  const { objectId, instanceId } = pickingId;
  if (id === objectId) {
    const { structure, group } = structureGroup;
    const unit = group.units[instanceId];
    const indices = OrderedSet.ofBounds(0, unit.elements.length);
    return element_exports.Loci(structure, [{ unit, indices }]);
  }
  return EmptyLoci;
}
function eachUnit(loci, structureGroup, apply) {
  let changed = false;
  if (!element_exports.Loci.is(loci))
    return false;
  const { structure, group } = structureGroup;
  if (!Structure.areEquivalent(loci.structure, structure))
    return false;
  const elementCount = group.elements.length;
  for (const e of loci.elements) {
    const unitIdx = group.unitIndexMap.get(e.unit.id);
    if (unitIdx !== void 0) {
      if (OrderedSet.size(e.indices) === elementCount) {
        if (apply(Interval.ofSingleton(unitIdx)))
          changed = true;
      }
    }
  }
  return changed;
}

// node_modules/molstar/lib/mol-repr/structure/representation/orientation.js
var OrientationVisuals = {
  "orientation-ellipsoid-mesh": (ctx, getParams) => UnitsRepresentation("Orientation ellipsoid mesh", ctx, getParams, OrientationEllipsoidMeshVisual)
};
var OrientationParams = {
  ...OrientationEllipsoidMeshParams,
  visuals: ParamDefinition.MultiSelect(["orientation-ellipsoid-mesh"], ParamDefinition.objectToOptions(OrientationVisuals)),
  bumpFrequency: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory)
};
function getOrientationParams(ctx, structure) {
  return OrientationParams;
}
function OrientationRepresentation(ctx, getParams) {
  return Representation.createMulti("Orientation", ctx, getParams, StructureRepresentationStateBuilder, OrientationVisuals);
}
var OrientationRepresentationProvider = StructureRepresentationProvider({
  name: "orientation",
  label: "Orientation",
  description: "Displays orientation ellipsoids for polymer chains.",
  factory: OrientationRepresentation,
  getParams: getOrientationParams,
  defaultValues: ParamDefinition.getDefaultValues(OrientationParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/element-point.js
var v3add6 = Vec3.add;
var ElementPointParams = {
  ...UnitsPointsParams,
  pointSizeAttenuation: ParamDefinition.Boolean(false),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false),
  stride: ParamDefinition.Numeric(1, { min: 1, max: 100, step: 1 })
};
function createElementPoint(ctx, unit, structure, theme, props, points2) {
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Points.createEmpty(points2);
  const { stride } = props;
  const elements = unit.elements;
  const n = elements.length;
  const builder = PointsBuilder.create(n, n / 10, points2);
  const p = Vec3();
  const c4 = unit.conformation;
  const ignore2 = makeElementIgnoreTest(structure, unit, props);
  const center2 = Vec3();
  let count2 = 0;
  if (stride && stride > 1 || ignore2) {
    for (let i = 0; i < n; ++i) {
      if (stride && i % stride !== 0)
        continue;
      if (ignore2 && ignore2(elements[i]))
        continue;
      c4.invariantPosition(elements[i], p);
      v3add6(center2, center2, p);
      count2 += 1;
      builder.add(p[0], p[1], p[2], i);
    }
  } else {
    for (let i = 0; i < n; ++i) {
      c4.invariantPosition(elements[i], p);
      v3add6(center2, center2, p);
      count2 += 1;
      builder.add(p[0], p[1], p[2], i);
    }
  }
  const pt2 = builder.getPoints();
  if (count2 === 0)
    return pt2;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = points2 ? Sphere3D.clone(points2.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, 1 * props.sizeFactor);
  }
  pt2.setBoundingSphere(boundingSphere);
  return pt2;
}
function ElementPointVisual(materialId) {
  return UnitsPointsVisual({
    defaultProps: ParamDefinition.getDefaultValues(ElementPointParams),
    createGeometry: createElementPoint,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    }
  }, materialId);
}
function createStructureElementPoint(ctx, structure, theme, props, points2) {
  const { child } = structure;
  const { stride } = props;
  const { getSerialIndex } = structure.serialMapping;
  const structureElementCount = structure.elementCount;
  const builder = PointsBuilder.create(structureElementCount, structureElementCount / 2, points2);
  const center2 = Vec3();
  let count2 = 0;
  for (const unit of structure.units) {
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
      return Points.createEmpty(points2);
    const { elements, conformation: c4 } = unit;
    const elementCount = elements.length;
    const v2 = Vec3();
    const ignore2 = makeElementIgnoreTest(structure, unit, props);
    if (stride && stride > 1 || ignore2) {
      for (let i = 0; i < elementCount; i++) {
        const eI = elements[i];
        if (stride && i % stride !== 0)
          continue;
        if (ignore2 && ignore2(eI))
          continue;
        c4.position(eI, v2);
        builder.add(v2[0], v2[1], v2[2], getSerialIndex(unit, eI));
        v3add6(center2, center2, v2);
        count2 += 1;
      }
    } else {
      for (let i = 0; i < elementCount; i++) {
        const eI = elements[i];
        c4.position(eI, v2);
        builder.add(v2[0], v2[1], v2[2], getSerialIndex(unit, eI));
        v3add6(center2, center2, v2);
      }
      count2 += elementCount;
    }
  }
  const pt2 = builder.getPoints();
  if (count2 === 0)
    return pt2;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = points2 ? Sphere3D.clone(points2.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
  }
  pt2.setBoundingSphere(boundingSphere);
  return pt2;
}
var StructureElementPointParams = {
  ...ComplexPointsParams,
  pointSizeAttenuation: ParamDefinition.Boolean(false),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false),
  stride: ParamDefinition.Numeric(1, { min: 1, max: 100, step: 1 })
};
function StructureElementPointVisual(materialId) {
  return ComplexPointsVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureElementPointParams),
    createGeometry: createStructureElementPoint,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.stride !== currentProps.stride;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/point.js
var PointVisuals = {
  "element-point": (ctx, getParams) => UnitsRepresentation("Element points", ctx, getParams, ElementPointVisual),
  "structure-element-point": (ctx, getParams) => ComplexRepresentation("Structure element points", ctx, getParams, StructureElementPointVisual)
};
var PointParams = {
  ...ElementPointParams,
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory),
  visuals: ParamDefinition.MultiSelect(["element-point"], ParamDefinition.objectToOptions(PointVisuals))
};
function getPointParams(ctx, structure) {
  let params = PointParams;
  if (structure.unitSymmetryGroups.length > 5e3) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["structure-element-point"];
  }
  return params;
}
function PointRepresentation(ctx, getParams) {
  return Representation.createMulti("Point", ctx, getParams, StructureRepresentationStateBuilder, PointVisuals);
}
var PointRepresentationProvider = StructureRepresentationProvider({
  name: "point",
  label: "Point",
  description: "Displays elements (atoms, coarse spheres) as points.",
  factory: PointRepresentation,
  getParams: getPointParams,
  defaultValues: ParamDefinition.getDefaultValues(PointParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-tube-mesh.js
var PolymerTubeMeshParams = {
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  linearSegments: ParamDefinition.Numeric(8, { min: 1, max: 48, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo)
};
var DefaultPolymerTubeMeshProps = ParamDefinition.getDefaultValues(PolymerTubeMeshParams);
var tmpV12 = Vec3();
function createPolymerTubeMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Mesh.createEmpty(mesh);
  const { sizeFactor, detail, linearSegments, radialSegments } = props;
  const vertexCount = linearSegments * radialSegments * polymerElementCount + (radialSegments + 1) * polymerElementCount * 2;
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 10, mesh);
  const state = createCurveSegmentState(linearSegments);
  const { curvePoints, normalVectors, binormalVectors, widthValues, heightValues } = state;
  let i = 0;
  const polymerTraceIt = PolymerTraceIterator(unit, structure, { ignoreSecondaryStructure: true });
  while (polymerTraceIt.hasNext) {
    const v2 = polymerTraceIt.move();
    builderState.currentGroup = i;
    const isNucleicType = isNucleic(v2.moleculeType);
    const shift2 = isNucleicType ? NucleicShift : StandardShift;
    interpolateCurveSegment(state, v2, StandardTension, shift2);
    const startCap = v2.coarseBackboneFirst || v2.first;
    const endCap = v2.coarseBackboneLast || v2.last;
    const s0 = theme.size.size(v2.centerPrev) * sizeFactor;
    const s1 = theme.size.size(v2.center) * sizeFactor;
    const s2 = theme.size.size(v2.centerNext) * sizeFactor;
    interpolateSizes(state, s0, s1, s2, s0, s1, s2, shift2);
    let segmentCount2 = linearSegments;
    if (v2.initial) {
      segmentCount2 = Math.max(Math.round(linearSegments * shift2), 1);
      const offset = linearSegments - segmentCount2;
      curvePoints.copyWithin(0, offset * 3);
      binormalVectors.copyWithin(0, offset * 3);
      normalVectors.copyWithin(0, offset * 3);
      widthValues.copyWithin(0, offset * 3);
      heightValues.copyWithin(0, offset * 3);
      Vec3.fromArray(tmpV12, curvePoints, 3);
      Vec3.normalize(tmpV12, Vec3.sub(tmpV12, v2.p2, tmpV12));
      Vec3.scaleAndAdd(tmpV12, v2.p2, tmpV12, s1 * OverhangFactor);
      Vec3.toArray(tmpV12, curvePoints, 0);
    } else if (v2.final) {
      segmentCount2 = Math.max(Math.round(linearSegments * (1 - shift2)), 1);
      Vec3.fromArray(tmpV12, curvePoints, segmentCount2 * 3 - 3);
      Vec3.normalize(tmpV12, Vec3.sub(tmpV12, v2.p2, tmpV12));
      Vec3.scaleAndAdd(tmpV12, v2.p2, tmpV12, s1 * OverhangFactor);
      Vec3.toArray(tmpV12, curvePoints, segmentCount2 * 3);
    }
    if (v2.initial === true && v2.final === true) {
      addSphere(builderState, v2.p2, s1 * 2, detail);
    } else if (radialSegments === 2) {
      addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount2, widthValues, heightValues, 0);
    } else if (radialSegments === 4) {
      addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount2, widthValues, heightValues, 0, startCap, endCap);
    } else {
      addTube(builderState, curvePoints, normalVectors, binormalVectors, segmentCount2, radialSegments, widthValues, heightValues, startCap, endCap, "elliptical");
    }
    ++i;
  }
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
var PolymerTubeParams = {
  ...UnitsMeshParams,
  ...PolymerTubeMeshParams
};
function PolymerTubeVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerTubeParams),
    createGeometry: createPolymerTubeMesh,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup, { asSecondary: true }),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.linearSegments !== currentProps.linearSegments || newProps.radialSegments !== currentProps.radialSegments;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/putty.js
var PuttyVisuals = {
  "polymer-tube": (ctx, getParams) => UnitsRepresentation("Polymer tube mesh", ctx, getParams, PolymerTubeVisual),
  "polymer-gap": (ctx, getParams) => UnitsRepresentation("Polymer gap cylinder", ctx, getParams, PolymerGapVisual)
};
var PuttyParams = {
  ...PolymerTubeParams,
  ...PolymerGapParams,
  sizeFactor: ParamDefinition.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),
  visuals: ParamDefinition.MultiSelect(["polymer-tube", "polymer-gap"], ParamDefinition.objectToOptions(PuttyVisuals)),
  bumpFrequency: ParamDefinition.Numeric(2, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getPuttyParams(ctx, structure) {
  const params = ParamDefinition.clone(PuttyParams);
  let hasNucleotides = false;
  let hasGaps = false;
  structure.units.forEach((u2) => {
    if (!hasNucleotides && Unit.isAtomic(u2) && u2.nucleotideElements.length)
      hasNucleotides = true;
    if (!hasGaps && u2.gapElements.length)
      hasGaps = true;
  });
  params.visuals.defaultValue = ["polymer-tube"];
  if (hasGaps)
    params.visuals.defaultValue.push("polymer-gap");
  return params;
}
function PuttyRepresentation(ctx, getParams) {
  return Representation.createMulti("Putty", ctx, getParams, StructureRepresentationStateBuilder, PuttyVisuals);
}
var PuttyRepresentationProvider = StructureRepresentationProvider({
  name: "putty",
  label: "Putty",
  description: "Displays a tube smoothly following the trace atoms of polymers.",
  factory: PuttyRepresentation,
  getParams: getPuttyParams,
  defaultValues: ParamDefinition.getDefaultValues(PuttyParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "uncertainty" },
  isApplicable: (structure) => structure.polymerResidueCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/representation/spacefill.js
var SpacefillVisuals = {
  "element-sphere": (ctx, getParams) => UnitsRepresentation("Sphere mesh/impostor", ctx, getParams, ElementSphereVisual),
  "structure-element-sphere": (ctx, getParams) => ComplexRepresentation("Structure sphere mesh/impostor", ctx, getParams, StructureElementSphereVisual)
};
var SpacefillParams = {
  ...ElementSphereParams,
  bumpFrequency: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory),
  visuals: ParamDefinition.MultiSelect(["element-sphere"], ParamDefinition.objectToOptions(SpacefillVisuals))
};
var CoarseGrainedSpacefillParams;
function getSpacefillParams(ctx, structure) {
  let params = SpacefillParams;
  if (structure.isCoarseGrained) {
    if (!CoarseGrainedSpacefillParams) {
      CoarseGrainedSpacefillParams = ParamDefinition.clone(SpacefillParams);
      CoarseGrainedSpacefillParams.sizeFactor.defaultValue = 2;
    }
    params = CoarseGrainedSpacefillParams;
  }
  if (structure.unitSymmetryGroups.length > 5e3) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["structure-element-sphere"];
  }
  return params;
}
function SpacefillRepresentation(ctx, getParams) {
  return Representation.createMulti("Spacefill", ctx, getParams, StructureRepresentationStateBuilder, SpacefillVisuals);
}
var SpacefillRepresentationProvider = StructureRepresentationProvider({
  name: "spacefill",
  label: "Spacefill",
  description: "Displays atomic/coarse elements as spheres.",
  factory: SpacefillRepresentation,
  getParams: getSpacefillParams,
  defaultValues: ParamDefinition.getDefaultValues(SpacefillParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/bond-intra-unit-line.js
var isBondType2 = BondType.is;
function getIntraUnitBondLineBuilderProps(unit, structure, theme, props) {
  const location = element_exports.Location.create(structure, unit);
  const elements = unit.elements;
  const bonds = unit.bonds;
  const { edgeCount, a: a4, b: b4, edgeProps, offset } = bonds;
  const { order: _order, flags: _flags } = edgeProps;
  const { sizeFactor, aromaticBonds, includeTypes, excludeTypes, multipleBonds } = props;
  const mbOff = multipleBonds === "off";
  const mbSymmetric = multipleBonds === "symmetric";
  const include = BondType.fromNames(includeTypes);
  const exclude = BondType.fromNames(excludeTypes);
  const ignoreComputedAromatic = ignoreBondType(include, exclude, BondType.Flag.Computed);
  const vRef = Vec3();
  const c4 = unit.conformation;
  const { elementRingIndices, elementAromaticRingIndices } = unit.rings;
  const deloTriplets = aromaticBonds ? unit.resonance.delocalizedTriplets : void 0;
  return {
    linkCount: edgeCount * 2,
    referencePosition: (edgeIndex) => {
      let aI = a4[edgeIndex], bI = b4[edgeIndex];
      const rI = deloTriplets === null || deloTriplets === void 0 ? void 0 : deloTriplets.getThirdElement(aI, bI);
      if (rI !== void 0)
        return c4.invariantPosition(elements[rI], vRef);
      if (aI > bI)
        [aI, bI] = [bI, aI];
      if (offset[aI + 1] - offset[aI] === 1)
        [aI, bI] = [bI, aI];
      const aR = elementAromaticRingIndices.get(aI) || elementRingIndices.get(aI);
      let maxSize = 0;
      for (let i = offset[aI], il = offset[aI + 1]; i < il; ++i) {
        const _bI = b4[i];
        if (_bI !== bI && _bI !== aI) {
          if (aR) {
            const _bR = elementAromaticRingIndices.get(_bI) || elementRingIndices.get(_bI);
            if (!_bR)
              continue;
            const size = arrayIntersectionSize(aR, _bR);
            if (size > maxSize) {
              maxSize = size;
              c4.invariantPosition(elements[_bI], vRef);
            }
          } else {
            return c4.invariantPosition(elements[_bI], vRef);
          }
        }
      }
      return maxSize > 0 ? vRef : null;
    },
    position: (posA, posB, edgeIndex, _adjust) => {
      c4.invariantPosition(elements[a4[edgeIndex]], posA);
      c4.invariantPosition(elements[b4[edgeIndex]], posB);
    },
    style: (edgeIndex) => {
      const o = _order[edgeIndex];
      const f = _flags[edgeIndex];
      if (isBondType2(f, BondType.Flag.MetallicCoordination) || isBondType2(f, BondType.Flag.HydrogenBond)) {
        return LinkStyle.Dashed;
      } else if (o === 3) {
        return mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Triple : LinkStyle.OffsetTriple;
      } else if (aromaticBonds) {
        const aI = a4[edgeIndex], bI = b4[edgeIndex];
        const aR = elementAromaticRingIndices.get(aI);
        const bR = elementAromaticRingIndices.get(bI);
        const arCount = aR && bR ? arrayIntersectionSize(aR, bR) : 0;
        if (isBondType2(f, BondType.Flag.Aromatic) || arCount && !ignoreComputedAromatic) {
          if (arCount === 2) {
            return LinkStyle.MirroredAromatic;
          } else {
            return LinkStyle.Aromatic;
          }
        }
      }
      return o !== 2 || mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Double : LinkStyle.OffsetDouble;
    },
    radius: (edgeIndex) => {
      location.element = elements[a4[edgeIndex]];
      const sizeA = theme.size.size(location);
      location.element = elements[b4[edgeIndex]];
      const sizeB = theme.size.size(location);
      return Math.min(sizeA, sizeB) * sizeFactor;
    },
    ignore: makeIntraBondIgnoreTest(structure, unit, props)
  };
}
function createIntraUnitBondLines(ctx, unit, structure, theme, props, lines) {
  if (!Unit.isAtomic(unit))
    return Lines.createEmpty(lines);
  if (!hasUnitVisibleBonds(unit, props))
    return Lines.createEmpty(lines);
  if (!unit.bonds.edgeCount)
    return Lines.createEmpty(lines);
  const { child } = structure;
  const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
  if (child && !childUnit)
    return Lines.createEmpty(lines);
  const builderProps = getIntraUnitBondLineBuilderProps(unit, structure, theme, props);
  const { lines: l, boundingSphere } = createLinkLines(ctx, builderProps, props, lines);
  if (boundingSphere) {
    l.setBoundingSphere(boundingSphere);
  } else if (l.lineCount > 0) {
    const sphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, 1 * props.sizeFactor);
    l.setBoundingSphere(sphere);
  }
  return l;
}
var IntraUnitBondLineParams = {
  ...UnitsLinesParams,
  ...BondLineParams,
  includeParent: ParamDefinition.Boolean(false)
};
function IntraUnitBondLineVisual(materialId) {
  return UnitsLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(IntraUnitBondLineParams),
    createGeometry: createIntraUnitBondLines,
    createLocationIterator: (structureGroup) => BondIterator.fromGroup(structureGroup),
    getLoci: getIntraBondLoci,
    eachLocation: eachIntraBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.aromaticBonds !== currentProps.aromaticBonds || newProps.multipleBonds !== currentProps.multipleBonds;
      const newUnit = newStructureGroup.group.units[0];
      const currentUnit = currentStructureGroup.group.units[0];
      if (Unit.isAtomic(newUnit) && Unit.isAtomic(currentUnit)) {
        if (!IntAdjacencyGraph.areEqual(newUnit.bonds, currentUnit.bonds)) {
          state.createGeometry = true;
          state.updateTransform = true;
          state.updateColor = true;
          state.updateSize = true;
        }
      }
    }
  }, materialId);
}
function getStructureIntraUnitBondLineBuilderProps(structure, theme, props) {
  const intraUnitProps = [];
  const { bondCount: bondCount2, unitIndex, unitEdgeIndex, unitGroupIndex } = structure.intraUnitBondMapping;
  const { child } = structure;
  for (const ug of structure.unitSymmetryGroups) {
    const unit = ug.units[0];
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    const p = Unit.isAtomic(unit) && !(child && !childUnit) ? getIntraUnitBondLineBuilderProps(unit, structure, theme, props) : EmptyLinkBuilderProps;
    intraUnitProps.push({ group: ug, props: p });
  }
  return {
    linkCount: bondCount2,
    referencePosition: (edgeIndex) => {
      const { group, props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      if (!props2.referencePosition)
        return null;
      const v2 = props2.referencePosition(unitEdgeIndex[edgeIndex]);
      if (!v2)
        return null;
      const u2 = group.units[unitGroupIndex[edgeIndex]];
      Vec3.transformMat4(v2, v2, u2.conformation.operator.matrix);
      return v2;
    },
    position: (posA, posB, edgeIndex, adjust) => {
      const { group, props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      props2.position(posA, posB, unitEdgeIndex[edgeIndex], adjust);
      const u2 = group.units[unitGroupIndex[edgeIndex]];
      Vec3.transformMat4(posA, posA, u2.conformation.operator.matrix);
      Vec3.transformMat4(posB, posB, u2.conformation.operator.matrix);
    },
    style: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.style ? props2.style(unitEdgeIndex[edgeIndex]) : LinkStyle.Solid;
    },
    radius: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.radius(unitEdgeIndex[edgeIndex]);
    },
    ignore: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.ignore ? props2.ignore(unitEdgeIndex[edgeIndex]) : false;
    },
    stub: (edgeIndex) => {
      const { props: props2 } = intraUnitProps[unitIndex[edgeIndex]];
      return props2.stub ? props2.stub(unitEdgeIndex[edgeIndex]) : false;
    }
  };
}
function createStructureIntraUnitBondLines(ctx, structure, theme, props, lines) {
  if (!hasStructureVisibleBonds(structure, props))
    return Lines.createEmpty(lines);
  if (!structure.intraUnitBondMapping.bondCount)
    return Lines.createEmpty(lines);
  const builderProps = getStructureIntraUnitBondLineBuilderProps(structure, theme, props);
  const { lines: l, boundingSphere } = createLinkLines(ctx, builderProps, props, lines);
  if (boundingSphere) {
    l.setBoundingSphere(boundingSphere);
  } else if (l.lineCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    l.setBoundingSphere(sphere);
  }
  return l;
}
var StructureIntraUnitBondLineParams = {
  ...ComplexLinesParams,
  ...BondLineParams,
  includeParent: ParamDefinition.Boolean(false)
};
function StructureIntraUnitBondLineVisual(materialId) {
  return ComplexLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureIntraUnitBondLineParams),
    createGeometry: createStructureIntraUnitBondLines,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructureGroups(structure);
    },
    getLoci: getStructureGroupsBondLoci,
    eachLocation: eachStructureGroupsBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.multipleBonds !== currentProps.multipleBonds;
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/bond-inter-unit-line.js
var tmpRefPosBondIt2 = new Bond.ElementBondIterator();
function setRefPosition2(pos, structure, unit, index2) {
  tmpRefPosBondIt2.setElement(structure, unit, index2);
  while (tmpRefPosBondIt2.hasNext) {
    const bA = tmpRefPosBondIt2.move();
    bA.otherUnit.conformation.position(bA.otherUnit.elements[bA.otherIndex], pos);
    return pos;
  }
  return null;
}
function getInterUnitBondLineBuilderProps(structure, theme, props) {
  const bonds = structure.interUnitBonds;
  const { edgeCount, edges } = bonds;
  const { sizeFactor, aromaticBonds, multipleBonds } = props;
  const mbOff = multipleBonds === "off";
  const mbSymmetric = multipleBonds === "symmetric";
  const ref = Vec3();
  const loc = element_exports.Location.create();
  return {
    linkCount: edgeCount,
    referencePosition: (edgeIndex) => {
      const b4 = edges[edgeIndex];
      let unitA, unitB;
      let indexA, indexB;
      if (b4.unitA < b4.unitB) {
        unitA = structure.unitMap.get(b4.unitA);
        unitB = structure.unitMap.get(b4.unitB);
        indexA = b4.indexA;
        indexB = b4.indexB;
      } else if (b4.unitA > b4.unitB) {
        unitA = structure.unitMap.get(b4.unitB);
        unitB = structure.unitMap.get(b4.unitA);
        indexA = b4.indexB;
        indexB = b4.indexA;
      } else {
        throw new Error("same units in createInterUnitBondLines");
      }
      return setRefPosition2(ref, structure, unitA, indexA) || setRefPosition2(ref, structure, unitB, indexB);
    },
    position: (posA, posB, edgeIndex, _adjust) => {
      const b4 = edges[edgeIndex];
      const uA = structure.unitMap.get(b4.unitA);
      const uB = structure.unitMap.get(b4.unitB);
      uA.conformation.position(uA.elements[b4.indexA], posA);
      uB.conformation.position(uB.elements[b4.indexB], posB);
    },
    style: (edgeIndex) => {
      const o = edges[edgeIndex].props.order;
      const f = BitFlags.create(edges[edgeIndex].props.flag);
      if (BondType.is(f, BondType.Flag.MetallicCoordination) || BondType.is(f, BondType.Flag.HydrogenBond)) {
        return LinkStyle.Dashed;
      } else if (o === 3) {
        return mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Triple : LinkStyle.OffsetTriple;
      } else if (aromaticBonds && BondType.is(f, BondType.Flag.Aromatic)) {
        return LinkStyle.Aromatic;
      }
      return o !== 2 || mbOff ? LinkStyle.Solid : mbSymmetric ? LinkStyle.Double : LinkStyle.OffsetDouble;
    },
    radius: (edgeIndex) => {
      const b4 = edges[edgeIndex];
      loc.structure = structure;
      loc.unit = structure.unitMap.get(b4.unitA);
      loc.element = loc.unit.elements[b4.indexA];
      const sizeA = theme.size.size(loc);
      loc.unit = structure.unitMap.get(b4.unitB);
      loc.element = loc.unit.elements[b4.indexB];
      const sizeB = theme.size.size(loc);
      return Math.min(sizeA, sizeB) * sizeFactor;
    },
    ignore: makeInterBondIgnoreTest(structure, props)
  };
}
function createInterUnitBondLines(ctx, structure, theme, props, lines) {
  if (!hasStructureVisibleBonds(structure, props))
    return Lines.createEmpty(lines);
  if (!structure.interUnitBonds.edgeCount)
    return Lines.createEmpty(lines);
  const builderProps = getInterUnitBondLineBuilderProps(structure, theme, props);
  const { lines: l, boundingSphere } = createLinkLines(ctx, builderProps, props, lines);
  if (boundingSphere) {
    l.setBoundingSphere(boundingSphere);
  } else if (l.lineCount > 0) {
    const { child } = structure;
    const sphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
    l.setBoundingSphere(sphere);
  }
  return l;
}
var InterUnitBondLineParams = {
  ...ComplexLinesParams,
  ...BondLineParams,
  includeParent: ParamDefinition.Boolean(false)
};
function InterUnitBondLineVisual(materialId) {
  return ComplexLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(InterUnitBondLineParams),
    createGeometry: createInterUnitBondLines,
    createLocationIterator: (structure, props) => {
      return !hasStructureVisibleBonds(structure, props) ? EmptyLocationIterator : BondIterator.fromStructure(structure);
    },
    getLoci: getInterBondLoci,
    eachLocation: eachInterBond,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.linkScale !== currentProps.linkScale || newProps.linkSpacing !== currentProps.linkSpacing || newProps.aromaticDashCount !== currentProps.aromaticDashCount || newProps.dashCount !== currentProps.dashCount || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || !arrayEqual(newProps.includeTypes, currentProps.includeTypes) || !arrayEqual(newProps.excludeTypes, currentProps.excludeTypes) || newProps.multipleBonds !== currentProps.multipleBonds;
      if (hasStructureVisibleBonds(newStructure, newProps) && newStructure.interUnitBonds !== currentStructure.interUnitBonds) {
        state.createGeometry = true;
        state.updateTransform = true;
        state.updateColor = true;
        state.updateSize = true;
      }
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/element-cross.js
var v3add7 = Vec3.add;
var v3scaleAndAdd2 = Vec3.scaleAndAdd;
var v3unitX2 = Vec3.unitX;
var v3unitY = Vec3.unitY;
var v3unitZ = Vec3.unitZ;
var ElementCrossParams = {
  ...UnitsLinesParams,
  lineSizeAttenuation: ParamDefinition.Boolean(false),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false),
  crosses: ParamDefinition.Select("lone", ParamDefinition.arrayToOptions(["lone", "all"])),
  crossSize: ParamDefinition.Numeric(0.35, { min: 0, max: 2, step: 0.01 })
};
function createElementCross(ctx, unit, structure, theme, props, lines) {
  const { child } = structure;
  if (child && !child.unitMap.get(unit.id))
    return Lines.createEmpty(lines);
  const elements = unit.elements;
  const n = elements.length;
  const builder = LinesBuilder.create(n, n / 10, lines);
  const p = Vec3();
  const s = Vec3();
  const e = Vec3();
  const c4 = unit.conformation;
  const ignore2 = makeElementIgnoreTest(structure, unit, props);
  const r = props.crossSize / 2;
  const lone = props.crosses === "lone";
  const center2 = Vec3();
  let count2 = 0;
  for (let i = 0; i < n; ++i) {
    if (ignore2 && ignore2(elements[i]))
      continue;
    if (lone && Unit.isAtomic(unit) && hasUnitVisibleBonds(unit, props) && bondCount(structure, unit, i) !== 0)
      continue;
    c4.invariantPosition(elements[i], p);
    v3add7(center2, center2, p);
    count2 += 1;
    v3scaleAndAdd2(s, p, v3unitX2, r);
    v3scaleAndAdd2(e, p, v3unitX2, -r);
    builder.add(s[0], s[1], s[2], e[0], e[1], e[2], i);
    v3scaleAndAdd2(s, p, v3unitY, r);
    v3scaleAndAdd2(e, p, v3unitY, -r);
    builder.add(s[0], s[1], s[2], e[0], e[1], e[2], i);
    v3scaleAndAdd2(s, p, v3unitZ, r);
    v3scaleAndAdd2(e, p, v3unitZ, -r);
    builder.add(s[0], s[1], s[2], e[0], e[1], e[2], i);
  }
  const l = builder.getLines();
  if (count2 === 0)
    return l;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = lines ? Sphere3D.clone(lines.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  }
  l.setBoundingSphere(boundingSphere);
  return l;
}
function ElementCrossVisual(materialId) {
  return UnitsLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(ElementCrossParams),
    createGeometry: createElementCross,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.crosses !== currentProps.crosses || newProps.crossSize !== currentProps.crossSize;
    }
  }, materialId);
}
function createStructureElementCross(ctx, structure, theme, props, lines) {
  const { child } = structure;
  const { getSerialIndex } = structure.serialMapping;
  const structureElementCount = structure.elementCount;
  const builder = LinesBuilder.create(structureElementCount, structureElementCount / 2, lines);
  const p = Vec3();
  const s = Vec3();
  const e = Vec3();
  const r = props.crossSize / 2;
  const lone = props.crosses === "lone";
  const center2 = Vec3();
  let count2 = 0;
  for (const unit of structure.units) {
    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
      return Lines.createEmpty(lines);
    const { elements, conformation: c4 } = unit;
    const elementCount = elements.length;
    const ignore2 = makeElementIgnoreTest(structure, unit, props);
    for (let i = 0; i < elementCount; i++) {
      if (ignore2 && ignore2(elements[i]))
        continue;
      if (lone && Unit.isAtomic(unit) && hasUnitVisibleBonds(unit, props) && bondCount(structure, unit, i) !== 0)
        continue;
      c4.position(elements[i], p);
      v3add7(center2, center2, p);
      count2 += 1;
      const si = getSerialIndex(unit, elements[i]);
      v3scaleAndAdd2(s, p, v3unitX2, r);
      v3scaleAndAdd2(e, p, v3unitX2, -r);
      builder.add(s[0], s[1], s[2], e[0], e[1], e[2], si);
      v3scaleAndAdd2(s, p, v3unitY, r);
      v3scaleAndAdd2(e, p, v3unitY, -r);
      builder.add(s[0], s[1], s[2], e[0], e[1], e[2], si);
      v3scaleAndAdd2(s, p, v3unitZ, r);
      v3scaleAndAdd2(e, p, v3unitZ, -r);
      builder.add(s[0], s[1], s[2], e[0], e[1], e[2], si);
    }
  }
  const l = builder.getLines();
  if (count2 === 0)
    return l;
  let boundingSphere;
  Vec3.scale(center2, center2, 1 / count2);
  const oldBoundingSphere = lines ? Sphere3D.clone(lines.boundingSphere) : void 0;
  if (oldBoundingSphere && Vec3.distance(center2, oldBoundingSphere.center) / oldBoundingSphere.radius < 1) {
    boundingSphere = oldBoundingSphere;
  } else {
    boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, 1 * props.sizeFactor);
  }
  l.setBoundingSphere(boundingSphere);
  return l;
}
var StructureElementCrossParams = {
  ...ComplexLinesParams,
  lineSizeAttenuation: ParamDefinition.Boolean(false),
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false),
  crosses: ParamDefinition.Select("lone", ParamDefinition.arrayToOptions(["lone", "all"])),
  crossSize: ParamDefinition.Numeric(0.35, { min: 0, max: 2, step: 0.01 })
};
function StructureElementCrossVisual(materialId) {
  return ComplexLinesVisual({
    defaultProps: ParamDefinition.getDefaultValues(StructureElementCrossParams),
    createGeometry: createStructureElementCross,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.ignoreHydrogens !== currentProps.ignoreHydrogens || newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant || newProps.traceOnly !== currentProps.traceOnly || newProps.crosses !== currentProps.crosses || newProps.crossSize !== currentProps.crossSize;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/line.js
var LineVisuals = {
  "intra-bond": (ctx, getParams) => UnitsRepresentation("Intra-unit bond line", ctx, getParams, IntraUnitBondLineVisual),
  "inter-bond": (ctx, getParams) => ComplexRepresentation("Inter-unit bond line", ctx, getParams, InterUnitBondLineVisual),
  "element-point": (ctx, getParams) => UnitsRepresentation("Points", ctx, getParams, ElementPointVisual),
  "element-cross": (ctx, getParams) => UnitsRepresentation("Crosses", ctx, getParams, ElementCrossVisual),
  "structure-intra-bond": (ctx, getParams) => ComplexRepresentation("Structure intra-unit bond line", ctx, getParams, StructureIntraUnitBondLineVisual),
  "structure-element-point": (ctx, getParams) => ComplexRepresentation("Structure element points", ctx, getParams, StructureElementPointVisual),
  "structure-element-cross": (ctx, getParams) => ComplexRepresentation("Structure element crosses", ctx, getParams, StructureElementCrossVisual)
};
var LineParams = {
  ...IntraUnitBondLineParams,
  ...InterUnitBondLineParams,
  ...ElementPointParams,
  ...ElementCrossParams,
  pointStyle: ParamDefinition.Select("circle", ParamDefinition.objectToOptions(Points.StyleTypes)),
  multipleBonds: ParamDefinition.Select("offset", ParamDefinition.arrayToOptions(["off", "symmetric", "offset"])),
  includeParent: ParamDefinition.Boolean(false),
  sizeFactor: ParamDefinition.Numeric(2, { min: 0.01, max: 10, step: 0.01 }),
  unitKinds: getUnitKindsParam(["atomic"]),
  visuals: ParamDefinition.MultiSelect(["intra-bond", "inter-bond", "element-point", "element-cross"], ParamDefinition.objectToOptions(LineVisuals)),
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory)
};
function getLineParams(ctx, structure) {
  let params = LineParams;
  const size = Structure.getSize(structure);
  if (size >= Structure.Size.Huge) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["intra-bond", "element-point", "element-cross"];
  } else if (structure.unitSymmetryGroups.length > 5e3) {
    params = ParamDefinition.clone(params);
    params.visuals.defaultValue = ["structure-intra-bond", "structure-element-point", "structure-element-cross"];
  }
  return params;
}
function LineRepresentation(ctx, getParams) {
  return Representation.createMulti("Line", ctx, getParams, StructureRepresentationStateBuilder, LineVisuals);
}
var LineRepresentationProvider = StructureRepresentationProvider({
  name: "line",
  label: "Line",
  description: "Displays bonds as lines and atoms as points or croses.",
  factory: LineRepresentation,
  getParams: getLineParams,
  defaultValues: ParamDefinition.getDefaultValues(LineParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.elementCount > 0,
  getData: (structure, props) => {
    return props.includeParent ? structure.asParent() : structure;
  },
  mustRecreate: (oldProps, newProps) => {
    return oldProps.includeParent !== newProps.includeParent;
  }
});

// node_modules/molstar/lib/mol-repr/structure/visual/gaussian-density-volume.js
function createGaussianDensityVolume(ctx, structure, theme, props, directVolume) {
  const { webgl } = ctx;
  if (!webgl) {
    throw new Error("GaussianDensityVolume requires `webgl`");
  }
  const axisOrder = Vec3.create(0, 1, 2);
  const stats = { min: 0, max: 1, mean: 0.04, sigma: 0.01 };
  const create2 = (directVolume2) => {
    const oldTexture = directVolume2 ? directVolume2.gridTexture.ref.value : void 0;
    const densityTextureData = computeStructureGaussianDensityTexture(structure, theme.size, props, webgl, oldTexture);
    const { transform, texture, bbox, gridDim } = densityTextureData;
    const unitToCartn = Mat4.mul(Mat4(), transform, Mat4.fromScaling(Mat4(), gridDim));
    const cellDim = Mat4.getScaling(Vec3(), transform);
    const vol2 = DirectVolume.create(bbox, gridDim, transform, unitToCartn, cellDim, texture, stats, true, axisOrder, "byte", directVolume2);
    const sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, densityTextureData.maxRadius);
    vol2.setBoundingSphere(sphere);
    return vol2;
  };
  const vol = create2(directVolume);
  vol.meta.reset = () => {
    create2(vol);
  };
  return vol;
}
var GaussianDensityVolumeParams = {
  ...ComplexDirectVolumeParams,
  ...GaussianDensityParams,
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  includeParent: ParamDefinition.Boolean(false, { isHidden: true })
};
function GaussianDensityVolumeVisual(materialId) {
  return ComplexDirectVolumeVisual({
    defaultProps: ParamDefinition.getDefaultValues(GaussianDensityVolumeParams),
    createGeometry: createGaussianDensityVolume,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
    },
    dispose: (geometry) => {
      geometry.gridTexture.ref.value.destroy();
    }
  }, materialId);
}
function createUnitsGaussianDensityVolume(ctx, unit, structure, theme, props, directVolume) {
  const { webgl } = ctx;
  if (!webgl) {
    throw new Error("GaussianDensityVolume requires `webgl`");
  }
  const axisOrder = Vec3.create(0, 1, 2);
  const stats = { min: 0, max: 1, mean: 0.04, sigma: 0.01 };
  const create2 = (directVolume2) => {
    const oldTexture = directVolume2 ? directVolume2.gridTexture.ref.value : void 0;
    const densityTextureData = computeUnitGaussianDensityTexture(structure, unit, theme.size, props, webgl, oldTexture);
    const { transform, texture, bbox, gridDim } = densityTextureData;
    const unitToCartn = Mat4.mul(Mat4(), transform, Mat4.fromScaling(Mat4(), gridDim));
    const cellDim = Mat4.getScaling(Vec3(), transform);
    const vol2 = DirectVolume.create(bbox, gridDim, transform, unitToCartn, cellDim, texture, stats, true, axisOrder, "byte", directVolume2);
    const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, densityTextureData.maxRadius);
    vol2.setBoundingSphere(sphere);
    return vol2;
  };
  const vol = create2(directVolume);
  vol.meta.reset = () => {
    create2(vol);
  };
  return vol;
}
var UnitsGaussianDensityVolumeParams = {
  ...UnitsDirectVolumeParams,
  ...GaussianDensityParams,
  ignoreHydrogens: ParamDefinition.Boolean(false),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  includeParent: ParamDefinition.Boolean(false, { isHidden: true })
};
function UnitsGaussianDensityVolumeVisual(materialId) {
  return UnitsDirectVolumeVisual({
    defaultProps: ParamDefinition.getDefaultValues(UnitsGaussianDensityVolumeParams),
    createGeometry: createUnitsGaussianDensityVolume,
    createLocationIterator: ElementIterator.fromGroup,
    getLoci: getElementLoci,
    eachLocation: eachElement,
    setUpdateState: (state, newProps, currentProps) => {
      if (newProps.resolution !== currentProps.resolution)
        state.createGeometry = true;
      if (newProps.radiusOffset !== currentProps.radiusOffset)
        state.createGeometry = true;
      if (newProps.smoothness !== currentProps.smoothness)
        state.createGeometry = true;
      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)
        state.createGeometry = true;
      if (newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant)
        state.createGeometry = true;
      if (newProps.traceOnly !== currentProps.traceOnly)
        state.createGeometry = true;
      if (newProps.includeParent !== currentProps.includeParent)
        state.createGeometry = true;
    },
    dispose: (geometry) => {
      geometry.gridTexture.ref.value.destroy();
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/gaussian-volume.js
var GaussianVolumeVisuals = {
  "gaussian-volume": (ctx, getParams) => ComplexRepresentation("Gaussian volume", ctx, getParams, GaussianDensityVolumeVisual),
  "units-gaussian-volume": (ctx, getParams) => UnitsRepresentation("Units-Gaussian volume", ctx, getParams, UnitsGaussianDensityVolumeVisual)
};
var GaussianVolumeParams = {
  ...GaussianDensityVolumeParams,
  jumpLength: ParamDefinition.Numeric(4, { min: 0, max: 20, step: 0.1 }),
  visuals: ParamDefinition.MultiSelect(["gaussian-volume"], ParamDefinition.objectToOptions(GaussianVolumeVisuals))
};
function getGaussianVolumeParams(ctx, structure) {
  return GaussianVolumeParams;
}
function GaussianVolumeRepresentation(ctx, getParams) {
  return Representation.createMulti("Gaussian Volume", ctx, getParams, StructureRepresentationStateBuilder, GaussianVolumeVisuals);
}
var GaussianVolumeRepresentationProvider = StructureRepresentationProvider({
  name: "gaussian-volume",
  label: "Gaussian Volume",
  description: "Displays a gaussian molecular density using direct volume rendering.",
  factory: GaussianVolumeRepresentation,
  getParams: getGaussianVolumeParams,
  defaultValues: ParamDefinition.getDefaultValues(GaussianVolumeParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-backbone-cylinder.js
var v3scale4 = Vec3.scale;
var v3add8 = Vec3.add;
var v3sub4 = Vec3.sub;
var PolymerBackboneCylinderParams = {
  ...UnitsMeshParams,
  ...UnitsCylindersParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  radialSegments: ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo),
  tryUseImpostor: ParamDefinition.Boolean(true)
};
function PolymerBackboneCylinderVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth ? PolymerBackboneCylinderImpostorVisual(materialId) : PolymerBackboneCylinderMeshVisual(materialId);
}
function createPolymerBackboneCylinderImpostor(ctx, unit, structure, theme, props, cylinders) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Cylinders.createEmpty(cylinders);
  const cylindersCountEstimate = polymerElementCount * 2;
  const builder = CylindersBuilder.create(cylindersCountEstimate, cylindersCountEstimate / 4, cylinders);
  const uc = unit.conformation;
  const pA = Vec3();
  const pB = Vec3();
  const pM = Vec3();
  const add = function(indexA, indexB, groupA, groupB, moleculeType) {
    uc.invariantPosition(indexA, pA);
    uc.invariantPosition(indexB, pB);
    const isNucleicType = isNucleic(moleculeType);
    const shift2 = isNucleicType ? NucleicShift : StandardShift;
    v3add8(pM, pA, v3scale4(pM, v3sub4(pM, pB, pA), shift2));
    builder.add(pA[0], pA[1], pA[2], pM[0], pM[1], pM[2], 1, false, false, 2, groupA);
    builder.add(pM[0], pM[1], pM[2], pB[0], pB[1], pB[2], 1, false, false, 2, groupB);
  };
  eachPolymerBackboneLink(unit, add);
  const c4 = builder.getCylinders();
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  c4.setBoundingSphere(sphere);
  return c4;
}
function PolymerBackboneCylinderImpostorVisual(materialId) {
  return UnitsCylindersVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerBackboneCylinderParams),
    createGeometry: createPolymerBackboneCylinderImpostor,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function createPolymerBackboneCylinderMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Mesh.createEmpty(mesh);
  const { radialSegments, sizeFactor } = props;
  const vertexCountEstimate = radialSegments * 2 * polymerElementCount * 2;
  const builderState = MeshBuilder.createState(vertexCountEstimate, vertexCountEstimate / 10, mesh);
  const c4 = unit.conformation;
  const pA = Vec3();
  const pB = Vec3();
  const cylinderProps = { radiusTop: 1, radiusBottom: 1, radialSegments };
  const centerA = element_exports.Location.create(structure, unit);
  const centerB = element_exports.Location.create(structure, unit);
  const add = function(indexA, indexB, groupA, groupB, moleculeType) {
    centerA.element = indexA;
    centerB.element = indexB;
    c4.invariantPosition(centerA.element, pA);
    c4.invariantPosition(centerB.element, pB);
    const isNucleicType = isNucleic(moleculeType);
    const shift2 = isNucleicType ? NucleicShift : StandardShift;
    cylinderProps.radiusTop = cylinderProps.radiusBottom = theme.size.size(centerA) * sizeFactor;
    builderState.currentGroup = groupA;
    addCylinder(builderState, pA, pB, shift2, cylinderProps);
    cylinderProps.radiusTop = cylinderProps.radiusBottom = theme.size.size(centerB) * sizeFactor;
    builderState.currentGroup = groupB;
    addCylinder(builderState, pB, pA, 1 - shift2, cylinderProps);
  };
  eachPolymerBackboneLink(unit, add);
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
function PolymerBackboneCylinderMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerBackboneCylinderParams),
    createGeometry: createPolymerBackboneCylinderMesh,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.radialSegments !== currentProps.radialSegments;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/visual/polymer-backbone-sphere.js
var PolymerBackboneSphereParams = {
  ...UnitsMeshParams,
  ...UnitsSpheresParams,
  sizeFactor: ParamDefinition.Numeric(0.3, { min: 0, max: 10, step: 0.01 }),
  detail: ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),
  tryUseImpostor: ParamDefinition.Boolean(true)
};
function PolymerBackboneSphereVisual(materialId, structure, props, webgl) {
  return props.tryUseImpostor && webgl && webgl.extensions.fragDepth && webgl.extensions.textureFloat ? PolymerBackboneSphereImpostorVisual(materialId) : PolymerBackboneSphereMeshVisual(materialId);
}
function createPolymerBackboneSphereImpostor(ctx, unit, structure, theme, props, spheres) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Spheres.createEmpty(spheres);
  const builder = SpheresBuilder.create(polymerElementCount, polymerElementCount / 2, spheres);
  const c4 = unit.conformation;
  const p = Vec3();
  const add = (index2, group) => {
    c4.invariantPosition(index2, p);
    builder.add(p[0], p[1], p[2], group);
  };
  eachPolymerBackboneElement(unit, add);
  const s = builder.getSpheres();
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  s.setBoundingSphere(sphere);
  return s;
}
function PolymerBackboneSphereImpostorVisual(materialId) {
  return UnitsSpheresVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerBackboneSphereParams),
    createGeometry: createPolymerBackboneSphereImpostor,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return !props.tryUseImpostor || !webgl;
    }
  }, materialId);
}
function createPolymerBackboneSphereMesh(ctx, unit, structure, theme, props, mesh) {
  const polymerElementCount = unit.polymerElements.length;
  if (!polymerElementCount)
    return Mesh.createEmpty(mesh);
  const { detail, sizeFactor } = props;
  const vertexCount = polymerElementCount * sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  const c4 = unit.conformation;
  const p = Vec3();
  const center2 = element_exports.Location.create(structure, unit);
  const add = (index2, group) => {
    center2.element = index2;
    c4.invariantPosition(center2.element, p);
    builderState.currentGroup = group;
    addSphere(builderState, p, theme.size.size(center2) * sizeFactor, detail);
  };
  eachPolymerBackboneElement(unit, add);
  const m = MeshBuilder.getMesh(builderState);
  const sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);
  m.setBoundingSphere(sphere);
  return m;
}
function PolymerBackboneSphereMeshVisual(materialId) {
  return UnitsMeshVisual({
    defaultProps: ParamDefinition.getDefaultValues(PolymerBackboneSphereParams),
    createGeometry: createPolymerBackboneSphereMesh,
    createLocationIterator: (structureGroup) => PolymerLocationIterator.fromGroup(structureGroup),
    getLoci: getPolymerElementLoci,
    eachLocation: eachPolymerElement,
    setUpdateState: (state, newProps, currentProps) => {
      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail;
    },
    mustRecreate: (structureGroup, props, webgl) => {
      return props.tryUseImpostor && !!webgl;
    }
  }, materialId);
}

// node_modules/molstar/lib/mol-repr/structure/representation/backbone.js
var BackboneVisuals = {
  "polymer-backbone-cylinder": (ctx, getParams) => UnitsRepresentation("Polymer backbone cylinder", ctx, getParams, PolymerBackboneCylinderVisual),
  "polymer-backbone-sphere": (ctx, getParams) => UnitsRepresentation("Polymer backbone sphere", ctx, getParams, PolymerBackboneSphereVisual),
  "polymer-gap": (ctx, getParams) => UnitsRepresentation("Polymer gap cylinder", ctx, getParams, PolymerGapVisual)
};
var BackboneParams = {
  ...PolymerBackboneSphereParams,
  ...PolymerBackboneCylinderParams,
  ...PolymerGapParams,
  sizeAspectRatio: ParamDefinition.Numeric(1, { min: 0.1, max: 3, step: 0.1 }),
  visuals: ParamDefinition.MultiSelect(["polymer-backbone-cylinder", "polymer-backbone-sphere", "polymer-gap"], ParamDefinition.objectToOptions(BackboneVisuals)),
  bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
  density: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }, BaseGeometry.ShadingCategory),
  colorMode: ParamDefinition.Select("default", ParamDefinition.arrayToOptions(["default", "interpolate"]), { ...BaseGeometry.ShadingCategory, isHidden: true })
};
function getBackboneParams(ctx, structure) {
  const params = ParamDefinition.clone(BackboneParams);
  let hasGaps = false;
  structure.units.forEach((u2) => {
    if (!hasGaps && u2.gapElements.length)
      hasGaps = true;
  });
  params.visuals.defaultValue = ["polymer-backbone-cylinder", "polymer-backbone-sphere"];
  if (hasGaps)
    params.visuals.defaultValue.push("polymer-gap");
  return params;
}
function BackboneRepresentation(ctx, getParams) {
  return Representation.createMulti("Backbone", ctx, getParams, StructureRepresentationStateBuilder, BackboneVisuals);
}
var BackboneRepresentationProvider = StructureRepresentationProvider({
  name: "backbone",
  label: "Backbone",
  description: "Displays polymer backbone with cylinders and spheres.",
  factory: BackboneRepresentation,
  getParams: getBackboneParams,
  defaultValues: ParamDefinition.getDefaultValues(BackboneParams),
  defaultColorTheme: { name: "chain-id" },
  defaultSizeTheme: { name: "uniform" },
  isApplicable: (structure) => structure.polymerResidueCount > 0
});

// node_modules/molstar/lib/mol-repr/structure/visual/plane-image.js
var v3set2 = Vec3.set;
var v3transformMat4 = Vec3.transformMat4;
var v3squaredDistance = Vec3.squaredDistance;
var PlaneImageParams = {
  ...ComplexImageParams,
  interpolation: ParamDefinition.Select("nearest", ParamDefinition.objectToOptions(InterpolationTypes)),
  imageResolution: ParamDefinition.Numeric(0.5, { min: 0.01, max: 20, step: 0.01 }, { description: "Grid resolution/cell spacing.", ...BaseGeometry.CustomQualityParamInfo }),
  mode: ParamDefinition.Select("frame", ParamDefinition.arrayToOptions(["frame", "plane"]), { description: "Frame: slice through the structure along arbitrary axes in any step size. Plane: an arbitrary plane defined by point and normal." }),
  offset: ParamDefinition.Numeric(0, { min: -1, max: 1, step: 0.01 }, { isEssential: true, immediateUpdate: true, hideIf: (p) => p.mode !== "frame", description: "Relative offset from center." }),
  axis: ParamDefinition.Select("c", ParamDefinition.arrayToOptions(["a", "b", "c"]), { isEssential: true, hideIf: (p) => p.mode !== "frame" }),
  rotation: ParamDefinition.Group({
    axis: ParamDefinition.Vec3(Vec3.create(1, 0, 0), {}, { description: "Axis of rotation" }),
    angle: ParamDefinition.Numeric(0, { min: -180, max: 180, step: 1 }, { immediateUpdate: true, description: "Axis rotation angle in Degrees" })
  }, { isExpanded: true, hideIf: (p) => p.mode !== "frame" }),
  plane: ParamDefinition.Group({
    point: ParamDefinition.Vec3(Vec3.create(0, 0, 0), {}, { description: "Plane point" }),
    normal: ParamDefinition.Vec3(Vec3.create(1, 0, 0), {}, { description: "Plane normal" })
  }, { isExpanded: true, hideIf: (p) => p.mode !== "plane" }),
  extent: ParamDefinition.Select("frame", ParamDefinition.arrayToOptions(["frame", "sphere"]), { description: "Extent of the plane, either box (frame) or sphere." }),
  margin: ParamDefinition.Numeric(4, { min: 0, max: 50, step: 1 }, { immediateUpdate: true, description: "Margin around the structure in Angstrom" }),
  frame: ParamDefinition.Select("principalAxes", ParamDefinition.arrayToOptions(["principalAxes", "boundingBox"])),
  antialias: ParamDefinition.Boolean(true, { description: "Antialiasing of structure edges." }),
  cutout: ParamDefinition.Boolean(false, { description: "Cutout the structure from the image." }),
  defaultColor: ParamDefinition.Color(Color(13421772), { description: "Default color for parts of the image that are not covered by the color theme." }),
  includeParent: ParamDefinition.Boolean(false, { description: "Show parent structure (but within extent of this structure)." })
};
function PlaneImageVisual(materialId) {
  return ComplexImageVisual({
    defaultProps: ParamDefinition.getDefaultValues(PlaneImageParams),
    createGeometry: createPlaneImage,
    createLocationIterator: ElementIterator.fromStructure,
    getLoci: getSerialElementLoci,
    eachLocation: eachSerialElement,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme) => {
      state.createGeometry = newProps.imageResolution !== currentProps.imageResolution || newProps.mode !== currentProps.mode || newProps.margin !== currentProps.margin || newProps.frame !== currentProps.frame || newProps.extent !== currentProps.extent || !Vec3.equals(newProps.rotation.axis, currentProps.rotation.axis) || newProps.rotation.angle !== currentProps.rotation.angle || newProps.offset !== currentProps.offset || newProps.axis !== currentProps.axis || !Vec3.equals(newProps.plane.point, currentProps.plane.point) || !Vec3.equals(newProps.plane.normal, currentProps.plane.normal) || newProps.antialias !== currentProps.antialias || newProps.cutout !== currentProps.cutout || newProps.defaultColor !== currentProps.defaultColor || !ColorTheme.areEqual(newTheme.color, currentTheme.color) || !SizeTheme.areEqual(newTheme.size, currentTheme.size);
    }
  }, materialId);
}
function getFrame(structure, props) {
  const { mode, axis, frame, extent, margin, rotation, plane, includeParent } = props;
  if (includeParent && structure.child) {
    structure = structure.child;
  }
  const size = Vec3();
  const scale = Vec3();
  const major = Vec3();
  const minor = Vec3();
  const normal3 = Vec3();
  const center2 = Vec3();
  let a4 = 0, b4 = 0, c4 = 0;
  let dirA, dirB, dirC;
  if (frame === "principalAxes") {
    const axes = Structure.getPrincipalAxes(structure).boxAxes;
    [a4, b4, c4] = Axes3D.size(Vec3(), axes);
    dirA = axes.dirA;
    dirB = axes.dirB;
    dirC = axes.dirC;
    Vec3.copy(center2, axes.origin);
  } else {
    [a4, b4, c4] = Box3D.size(Vec3(), structure.boundary.box);
    dirA = Vec3.create(1, 0, 0);
    dirB = Vec3.create(0, 1, 0);
    dirC = Vec3.create(0, 0, 1);
    Vec3.copy(center2, structure.boundary.sphere.center);
  }
  Vec3.set(scale, a4, b4, c4);
  if (axis === "c") {
    Vec3.set(size, a4, b4, c4);
    Vec3.copy(major, dirA);
    Vec3.copy(minor, dirB);
    Vec3.copy(normal3, dirC);
  } else if (axis === "b") {
    Vec3.set(size, a4, c4, b4);
    Vec3.copy(major, dirA);
    Vec3.copy(normal3, dirB);
    Vec3.copy(minor, dirC);
  } else {
    Vec3.set(size, b4, c4, a4);
    Vec3.copy(normal3, dirA);
    Vec3.copy(major, dirB);
    Vec3.copy(minor, dirC);
  }
  if (rotation.angle !== 0) {
    const ra = Vec3();
    Vec3.scaleAndAdd(ra, ra, dirA, rotation.axis[0]);
    Vec3.scaleAndAdd(ra, ra, dirB, rotation.axis[1]);
    Vec3.scaleAndAdd(ra, ra, dirC, rotation.axis[2]);
    Vec3.normalize(ra, ra);
    const rm = Mat4.fromRotation(Mat4(), degToRad(rotation.angle), ra);
    Vec3.transformDirection(major, major, rm);
    Vec3.transformDirection(minor, minor, rm);
    Vec3.transformDirection(normal3, normal3, rm);
  }
  if (extent === "sphere" || rotation.angle !== 0) {
    const r = structure.boundary.sphere.radius * 2;
    const s = Vec3.magnitude(Box3D.size(Vec3(), Box3D.fromSphere3D(Box3D(), structure.boundary.sphere)));
    Vec3.set(size, s, s, r);
    if (extent === "sphere") {
      Vec3.set(scale, r, r, r);
    }
  }
  Vec3.addScalar(size, size, margin * 2);
  Vec3.addScalar(scale, scale, margin * 2);
  const trimRotation = Quat.identity();
  if (frame === "principalAxes") {
    Quat.fromBasis(trimRotation, Vec3.normalize(Vec3(), dirA), Vec3.normalize(Vec3(), dirB), Vec3.normalize(Vec3(), dirC));
  }
  if (mode === "plane") {
    Vec3.copy(center2, plane.point);
    Vec3.copy(normal3, plane.normal);
    Vec3.cross(major, normal3, Vec3.unitX);
    if (Vec3.dot(major, major) < EPSILON) {
      Vec3.cross(major, normal3, Vec3.unitY);
    }
    Vec3.normalize(major, major);
    Vec3.cross(minor, normal3, major);
    Vec3.normalize(minor, minor);
  }
  const trim = {
    type: extent === "sphere" ? 2 : 3,
    center: center2,
    scale,
    rotation: trimRotation,
    transform: Mat4.identity()
  };
  return { size, major, minor, normal: normal3, center: center2, trim };
}
function createPlaneImage(ctx, structure, theme, props, image2) {
  const { imageResolution, offset, antialias, cutout, defaultColor } = props;
  const scaleFactor = 1 / imageResolution;
  const color2 = "color" in theme.color && theme.color.color ? theme.color.color : () => Color(16777215);
  const { size, major, minor, normal: normal3, center: center2, trim } = getFrame(structure, props);
  const scale = Vec3.create(size[0], size[1], 1);
  const offsetDir = Vec3.setMagnitude(Vec3(), normal3, size[2] / 2);
  const width = Math.floor(size[1] * scaleFactor);
  const height = Math.floor(size[0] * scaleFactor);
  const m = Mat4.identity();
  const v2 = Vec3();
  const anchor = Vec3();
  Vec3.add(v2, center2, major);
  Mat4.targetTo(m, center2, v2, minor);
  Vec3.scaleAndAdd(anchor, center2, offsetDir, offset);
  Mat4.setTranslation(m, anchor);
  Mat4.mul(m, m, Mat4.rotY90);
  Mat4.scale(m, m, scale);
  const { getSerialIndex } = structure.serialMapping;
  const isVertex = theme.color.granularity.startsWith("vertex");
  const plane = Plane3D.fromNormalAndCoplanarPoint(Plane3D(), Vec3.normalize(Vec3(), normal3), anchor);
  const invM = Mat4.invert(Mat4(), m);
  const pl = PositionLocation(Vec3(), Vec3());
  const el = element_exports.Location.create(structure);
  const { units } = structure;
  let maxRadius = 0;
  for (let i = 0, il = units.length; i < il; ++i) {
    const { elements } = units[i];
    el.unit = units[i];
    for (let j = 0, jl = elements.length; j < jl; ++j) {
      el.element = elements[j];
      const r = theme.size.size(el);
      if (r > maxRadius)
        maxRadius = r;
    }
  }
  const imageArray = new Uint8Array(width * height * 4);
  const groupArray = new Uint8Array(width * height * 4);
  const distArray = new Float32Array(width * height);
  distArray.fill(Number.MAX_VALUE);
  const p = Vec3();
  const pp = Vec3();
  const pn = Vec3();
  if (isVertex) {
    let i = 0;
    for (let ih = 0; ih < height; ++ih) {
      for (let iw = 0; iw < width; ++iw) {
        const y = clamp(iw + 0.5, 0, width - 1) / width - 0.5;
        const x = clamp(ih + 0.5, 0, height - 1) / height - 0.5;
        Vec3.set(v2, x, -y, 0);
        Vec3.transformMat4(v2, v2, m);
        Vec3.copy(pl.position, v2);
        const c4 = color2(pl, false);
        Color.toArray(c4, imageArray, i);
        imageArray[i + 3] = cutout ? 0 : 255;
        i += 4;
      }
    }
  } else {
    for (let i = 0, il = width * height * 4; i < il; i += 4) {
      Color.toArray(defaultColor, imageArray, i);
      imageArray[i + 3] = cutout ? 0 : 255;
    }
  }
  for (let i = 0, il = units.length; i < il; ++i) {
    const unit = units[i];
    const { elements, conformation: c4 } = unit;
    el.unit = units[i];
    for (let j = 0, jl = elements.length; j < jl; ++j) {
      const eI = elements[j];
      el.element = eI;
      c4.position(eI, p);
      const dist = Plane3D.distanceToPoint(plane, p);
      if (Math.abs(dist) > maxRadius)
        continue;
      const r = theme.size.size(el);
      if (Math.abs(dist) > r)
        continue;
      const rf = Math.cos(Math.abs(dist) / r);
      const tol = antialias ? imageResolution * rf : 0;
      const rTol = r + tol / 2;
      const rTolSq = rTol * rTol;
      Vec3.scaleAndAdd(pp, p, plane.normal, -dist);
      Vec3.transformMat4(pn, pp, invM);
      Vec3.addScalar(pn, pn, 0.5);
      const x = Math.floor(pn[0] * height);
      const y = width - Math.ceil(pn[1] * width);
      const ng = Math.ceil(r * scaleFactor);
      const begX = Math.max(0, x - ng);
      const begY = Math.max(0, y - ng);
      const endX = Math.min(height, x + ng + 2);
      const endY = Math.min(width, y + ng + 2);
      Vec3.copy(pl.position, pp);
      const col = isVertex ? defaultColor : color2(el, false);
      const idx = getSerialIndex(el.unit, el.element);
      for (let xi = begX; xi < endX; ++xi) {
        for (let yi = begY; yi < endY; ++yi) {
          const xx = clamp(xi + 0.5, 0, height - 1) / height - 0.5;
          const yy = clamp(yi + 0.5, 0, width - 1) / width - 0.5;
          v3set2(v2, xx, -yy, 0);
          v3transformMat4(v2, v2, m);
          const distSq = v3squaredDistance(v2, p);
          if (distSq > rTolSq)
            continue;
          const k = xi * width + yi;
          if (distSq < distArray[k]) {
            const k4 = k * 4;
            const d3 = Math.sqrt(distSq) - r + tol / 2;
            let f = d3 > 0 ? 1 - d3 / tol : 1;
            if (isVertex) {
              if (f === 1) {
                distArray[k] = distSq;
              } else {
                if (cutout) {
                  if (groupArray[k4] !== 0 || groupArray[k4 + 1] !== 0 || groupArray[k4 + 2] !== 0) {
                    f = 1;
                  }
                }
              }
            } else {
              if (f === 1) {
                distArray[k] = distSq;
                Color.toArray(col, imageArray, k4);
              } else {
                if (cutout) {
                  Color.toArray(col, imageArray, k4);
                  if (groupArray[k4] !== 0 || groupArray[k4 + 1] !== 0 || groupArray[k4 + 2] !== 0) {
                    f = 1;
                  }
                } else {
                  Color.toArray(Color.interpolate(Color.fromArray(imageArray, k4), col, f), imageArray, k4);
                }
              }
            }
            packIntToRGBArray(idx, groupArray, k4);
            groupArray[k4 + 3] = antialias ? Math.round(255 * f) : 255;
            if (cutout) {
              imageArray[k * 4 + 3] = antialias ? Math.round(255 * f) : 255;
            }
          }
        }
      }
    }
  }
  const imageTexture = { width, height, array: imageArray, flipY: true };
  const groupTexture = { width, height, array: groupArray, flipY: true };
  const valueTexture = { width: 1, height: 1, array: new Float32Array(1), flipY: true };
  const corners = new Float32Array([
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0,
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0
  ]);
  transformPositionArray(m, corners, 0, 4);
  return Image.create(imageTexture, corners, groupTexture, valueTexture, trim, -1, image2);
}

// node_modules/molstar/lib/mol-repr/structure/representation/plane.js
var PlaneVisuals = {
  "plane-image": (ctx, getParams) => ComplexRepresentation("Plane image", ctx, getParams, PlaneImageVisual)
};
var PlaneParams = {
  ...PlaneImageParams,
  visuals: ParamDefinition.MultiSelect(["plane-image"], ParamDefinition.objectToOptions(PlaneVisuals))
};
function getPlaneParams(ctx, structure) {
  return PlaneParams;
}
function PlaneRepresentation(ctx, getParams) {
  return Representation.createMulti("Plane", ctx, getParams, StructureRepresentationStateBuilder, PlaneVisuals);
}
var PlaneRepresentationProvider = StructureRepresentationProvider({
  name: "plane",
  label: "Plane",
  description: "Displays planes.",
  factory: PlaneRepresentation,
  getParams: getPlaneParams,
  defaultValues: ParamDefinition.getDefaultValues(PlaneParams),
  defaultColorTheme: { name: "element-symbol" },
  defaultSizeTheme: { name: "physical" },
  isApplicable: (structure) => structure.elementCount > 0,
  getData: (structure, props) => {
    return props.includeParent ? structure.asParent() : structure;
  },
  mustRecreate: (oldProps, newProps) => {
    return oldProps.includeParent !== newProps.includeParent;
  }
});

// node_modules/molstar/lib/mol-repr/structure/registry.js
var StructureRepresentationRegistry = class _StructureRepresentationRegistry extends RepresentationRegistry {
  constructor() {
    super();
    objectForEach(_StructureRepresentationRegistry.BuiltIn, (p, k) => {
      if (p.name !== k)
        throw new Error(`Fix BuiltInStructureRepresentations to have matching names. ${p.name} ${k}`);
      this.add(p);
    });
  }
};
(function(StructureRepresentationRegistry2) {
  StructureRepresentationRegistry2.BuiltIn = {
    "cartoon": CartoonRepresentationProvider,
    "backbone": BackboneRepresentationProvider,
    "ball-and-stick": BallAndStickRepresentationProvider,
    "carbohydrate": CarbohydrateRepresentationProvider,
    "ellipsoid": EllipsoidRepresentationProvider,
    "gaussian-surface": GaussianSurfaceRepresentationProvider,
    "gaussian-volume": GaussianVolumeRepresentationProvider,
    "label": LabelRepresentationProvider,
    "line": LineRepresentationProvider,
    "molecular-surface": MolecularSurfaceRepresentationProvider,
    "orientation": OrientationRepresentationProvider,
    "plane": PlaneRepresentationProvider,
    "point": PointRepresentationProvider,
    "putty": PuttyRepresentationProvider,
    "spacefill": SpacefillRepresentationProvider
  };
})(StructureRepresentationRegistry || (StructureRepresentationRegistry = {}));

// node_modules/molstar/lib/mol-plugin/animation-loop.js
var PluginAnimationLoop = class {
  get isAnimating() {
    return this._isAnimating;
  }
  async tick(t4, options) {
    var _a, _b;
    await this.plugin.managers.animation.tick(t4, options === null || options === void 0 ? void 0 : options.isSynchronous, options === null || options === void 0 ? void 0 : options.animation);
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.tick(t4, options);
    if (isTimingMode) {
      const timerResults = (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.webgl.timer.resolve();
      if (timerResults) {
        for (const result of timerResults) {
          printTimerResults([result]);
        }
      }
    }
  }
  resetTime(t4 = now()) {
    var _a;
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.resetTime(t4);
  }
  start(options) {
    var _a;
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.resume();
    this._isAnimating = true;
    this.resetTime();
    if (options === null || options === void 0 ? void 0 : options.immediate)
      this.frame();
    else
      this.currentFrame = requestAnimationFrame(this.frame);
  }
  stop(options) {
    var _a;
    this._isAnimating = false;
    if (this.currentFrame !== void 0) {
      cancelAnimationFrame(this.currentFrame);
      this.currentFrame = void 0;
    }
    if (options === null || options === void 0 ? void 0 : options.noDraw) {
      (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.pause(options === null || options === void 0 ? void 0 : options.noDraw);
    }
  }
  constructor(plugin) {
    this.plugin = plugin;
    this.currentFrame = void 0;
    this._isAnimating = false;
    this.frame = () => {
      this.tick(now());
      if (this._isAnimating) {
        this.currentFrame = requestAnimationFrame(this.frame);
      }
    };
  }
};

// node_modules/molstar/lib/mol-plugin/util/substructure-parent-helper.js
var SubstructureParentHelper = class {
  getDecorator(root3) {
    const tree = this.plugin.state.data.tree;
    const children = tree.children.get(root3);
    if (children.size !== 1)
      return root3;
    const child = children.first();
    if (child && tree.transforms.get(child).transformer.definition.isDecorator) {
      return this.getDecorator(child);
    }
    return root3;
  }
  /** Returns the root node of given structure if existing, takes decorators into account */
  get(s, ignoreDecorators = false) {
    const r = this.root.get(s);
    if (!r)
      return;
    if (ignoreDecorators)
      return this.plugin.state.data.cells.get(r.ref);
    return this.plugin.state.data.cells.get(this.getDecorator(r.ref));
  }
  addMapping(state, ref, obj) {
    if (!PluginStateObject.Molecule.Structure.is(obj))
      return false;
    this.tracked.set(ref, obj.data);
    if (this.root.has(obj.data)) {
      const e = this.root.get(obj.data);
      e.count++;
    } else {
      const parent = state.select(StateSelection.Generators.byRef(ref).rootOfType([PluginStateObject.Molecule.Structure]))[0];
      if (!parent) {
        this.root.set(obj.data, { ref, count: 1 });
      } else {
        this.root.set(obj.data, { ref: parent.transform.ref, count: 1 });
      }
    }
    return true;
  }
  removeMapping(ref) {
    if (!this.tracked.has(ref))
      return false;
    const s = this.tracked.get(ref);
    this.tracked.delete(ref);
    const root3 = this.root.get(s);
    if (root3.count > 1) {
      root3.count--;
    } else {
      this.root.delete(s);
    }
    return true;
  }
  updateMapping(state, ref, oldObj, obj) {
    if (!PluginStateObject.Molecule.Structure.is(obj))
      return false;
    this.removeMapping(ref);
    this.addMapping(state, ref, obj);
    return true;
  }
  dispose() {
    this.ev.dispose();
  }
  constructor(plugin) {
    this.plugin = plugin;
    this.ev = RxEventHelper.create();
    this.events = {
      updated: this.ev(),
      removed: this.ev()
    };
    this.root = /* @__PURE__ */ new Map();
    this.tracked = /* @__PURE__ */ new Map();
    plugin.state.data.events.object.created.subscribe((e) => {
      this.addMapping(e.state, e.ref, e.obj);
    });
    plugin.state.data.events.object.removed.subscribe((e) => {
      if (this.removeMapping(e.ref)) {
        this.events.removed.next({ ref: e.ref, obj: e.obj });
      }
    });
    plugin.state.data.events.object.updated.subscribe((e) => {
      if (this.updateMapping(e.state, e.ref, e.oldObj, e.obj)) {
        this.events.updated.next({ ref: e.ref, oldObj: e.oldObj, obj: e.obj });
      }
    });
  }
};

// node_modules/molstar/lib/mol-plugin/util/task-manager.js
var TaskManager = class {
  constructor() {
    this.ev = RxEventHelper.create();
    this.id = 0;
    this.runningTasks = /* @__PURE__ */ new Set();
    this.abortRequests = /* @__PURE__ */ new Map();
    this.options = /* @__PURE__ */ new Map();
    this.currentContext = [];
    this.events = {
      progress: this.ev(),
      finished: this.ev()
    };
  }
  tryGetAbortTaskId(node2) {
    if (this.abortRequests.has(node2.progress.taskId))
      return node2.progress.taskId;
    for (const c4 of node2.children) {
      const abort = this.tryGetAbortTaskId(c4);
      if (abort !== void 0)
        return abort;
    }
    return void 0;
  }
  track(internalId, taskId) {
    return (progress) => {
      var _a;
      if (progress.canAbort && progress.requestAbort) {
        const abortTaskId = this.tryGetAbortTaskId(progress.root);
        if (abortTaskId !== void 0)
          progress.requestAbort(this.abortRequests.get(abortTaskId));
      }
      const elapsed = now() - progress.root.progress.startedTime;
      this.events.progress.next({
        id: internalId,
        useOverlay: (_a = this.options.get(taskId)) === null || _a === void 0 ? void 0 : _a.useOverlay,
        level: elapsed < 250 ? "none" : "background",
        progress
      });
    };
  }
  async run(task, params) {
    const id = this.id++;
    let ctx;
    if ((params === null || params === void 0 ? void 0 : params.createNewContext) || this.currentContext.length === 0) {
      ctx = { ctx: CreateObservableCtx(task, this.track(id, task.id), 100), refCount: 1 };
    } else {
      ctx = this.currentContext[this.currentContext.length - 1];
      ctx.refCount++;
    }
    try {
      this.options.set(task.id, { useOverlay: !!(params === null || params === void 0 ? void 0 : params.useOverlay) });
      this.runningTasks.add(task.id);
      const ret = await ExecuteInContext(ctx.ctx, task);
      return ret;
    } finally {
      this.options.delete(task.id);
      this.runningTasks.delete(task.id);
      this.events.finished.next({ id });
      this.abortRequests.delete(task.id);
      ctx.refCount--;
      if (ctx.refCount === 0)
        arrayRemoveInPlace(this.currentContext, ctx);
    }
  }
  requestAbortAll(reason) {
    this.runningTasks.forEach((id) => this.abortRequests.set(id, reason));
  }
  requestAbort(taskIdOrProgress, reason) {
    const id = typeof taskIdOrProgress === "number" ? taskIdOrProgress : taskIdOrProgress.root.progress.taskId;
    this.abortRequests.set(id, reason);
  }
  dispose() {
    this.ev.dispose();
  }
};
(function(TaskManager2) {
  function delay2(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  function testTask(N) {
    return Task.create("Test", async (ctx) => {
      let i = 0;
      while (i < N) {
        await delay2(100 + Math.random() * 200);
        if (ctx.shouldUpdate) {
          await ctx.update({ message: "Step " + i, current: i, max: N, isIndeterminate: false });
        }
        i++;
      }
    });
  }
  TaskManager2.testTask = testTask;
})(TaskManager || (TaskManager = {}));

// node_modules/molstar/lib/mol-plugin/util/toast.js
var PluginToastManager = class extends StatefulPluginComponent {
  findByKey(key) {
    return this.state.entries.find((e) => !!e && e.key === key);
  }
  show(toast) {
    let entries = this.state.entries;
    let e = void 0;
    const id = ++this.serialId;
    let serialNumber;
    if (toast.key && (e = this.findByKey(toast.key))) {
      if (e.timeout !== void 0)
        clearTimeout(e.timeout);
      serialNumber = e.serialNumber;
      entries = entries.remove(e.id);
    } else {
      serialNumber = ++this.serialNumber;
    }
    e = {
      id,
      serialNumber,
      key: toast.key,
      title: toast.title,
      message: toast.message,
      timeout: this.timeout(id, toast.timeoutMs),
      hide: () => this.hideId(id)
    };
    if (this.updateState({ entries: entries.set(id, e) }))
      this.events.changed.next(void 0);
  }
  timeout(id, delay2) {
    if (delay2 === void 0)
      return void 0;
    if (delay2 < 0)
      delay2 = 500;
    return setTimeout(() => {
      const e = this.state.entries.get(id);
      e.timeout = void 0;
      this.hide(e);
    }, delay2);
  }
  hideId(id) {
    this.hide(this.state.entries.get(id));
  }
  hide(e) {
    if (!e)
      return;
    if (e.timeout !== void 0)
      clearTimeout(e.timeout);
    e.hide = void 0;
    if (this.updateState({ entries: this.state.entries.delete(e.id) }))
      this.events.changed.next(void 0);
  }
  constructor(plugin) {
    super({ entries: OrderedMap() });
    this.events = {
      changed: this.ev()
    };
    this.serialNumber = 0;
    this.serialId = 0;
    PluginCommands.Toast.Show.subscribe(plugin, (e) => this.show(e));
    PluginCommands.Toast.Hide.subscribe(plugin, (e) => this.hide(this.findByKey(e.key)));
  }
};

// node_modules/molstar/lib/mol-plugin/util/viewport-screenshot.js
function checkWebPSupport() {
  const elem = document.createElement("canvas");
  if (!!(elem.getContext && elem.getContext("2d"))) {
    return elem.toDataURL("image/webp").indexOf("data:image/webp") === 0;
  } else {
    return false;
  }
}
var ViewportScreenshotHelper = class extends PluginComponent {
  createParams() {
    let max2 = 8192;
    if (this.plugin.canvas3d) {
      const { webgl } = this.plugin.canvas3d;
      max2 = Math.floor(Math.min(webgl.maxRenderbufferSize, webgl.maxTextureSize) / 2);
    }
    return {
      resolution: ParamDefinition.MappedStatic("viewport", {
        viewport: ParamDefinition.Group({}),
        hd: ParamDefinition.Group({}),
        "full-hd": ParamDefinition.Group({}),
        "ultra-hd": ParamDefinition.Group({}),
        custom: ParamDefinition.Group({
          width: ParamDefinition.Numeric(1920, { min: 128, max: max2, step: 1 }),
          height: ParamDefinition.Numeric(1080, { min: 128, max: max2, step: 1 })
        }, { isFlat: true })
      }, {
        options: [
          ["viewport", "Viewport"],
          ["hd", "HD (1280 x 720)"],
          ["full-hd", "Full HD (1920 x 1080)"],
          ["ultra-hd", "Ultra HD (3840 x 2160)"],
          ["custom", "Custom"]
        ]
      }),
      format: ParamDefinition.MappedStatic("png", {
        png: ParamDefinition.Group({}),
        webp: ParamDefinition.Group({
          quality: ParamDefinition.Numeric(0.9, { min: 0, max: 1, step: 0.01 })
        }),
        jpeg: ParamDefinition.Group({
          quality: ParamDefinition.Numeric(0.9, { min: 0, max: 1, step: 0.01 })
        })
      }, {
        options: [
          ["png", "PNG"],
          ["jpeg", "JPEG"],
          ...checkWebPSupport() ? [["webp", "WebP"]] : []
        ]
      }),
      transparent: ParamDefinition.Boolean(false),
      axes: CameraHelperParams.axes,
      illumination: ParamDefinition.Group({
        extraIterations: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 1 }),
        targetIterationTimeMs: ParamDefinition.Numeric(300, { min: 100, max: 3e3, step: 10 })
      })
    };
  }
  get params() {
    if (this._params)
      return this._params;
    return this._params = this.createParams();
  }
  get values() {
    return this.behaviors.values.value;
  }
  get cropParams() {
    return this.behaviors.cropParams.value;
  }
  get relativeCrop() {
    return this.behaviors.relativeCrop.value;
  }
  getCanvasSize() {
    var _a, _b;
    return {
      width: ((_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl.gl.drawingBufferWidth) || 0,
      height: ((_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.webgl.gl.drawingBufferHeight) || 0
    };
  }
  getSize() {
    const values2 = this.values;
    switch (values2.resolution.name) {
      case "viewport":
        return this.getCanvasSize();
      case "hd":
        return { width: 1280, height: 720 };
      case "full-hd":
        return { width: 1920, height: 1080 };
      case "ultra-hd":
        return { width: 3840, height: 2160 };
      default:
        return { width: values2.resolution.params.width, height: values2.resolution.params.height };
    }
  }
  getPostprocessingProps() {
    const c4 = this.plugin.canvas3d;
    const aoProps = c4.props.postprocessing.occlusion;
    return {
      ...c4.props.postprocessing,
      occlusion: aoProps.name === "on" ? { name: "on", params: { ...aoProps.params, samples: 128, resolutionScale: c4.webgl.pixelRatio, transparentThreshold: 1 } } : aoProps
    };
  }
  getIlluminationProps(isPreview) {
    const c4 = this.plugin.canvas3d;
    const giProps = c4.props.illumination;
    const { extraIterations, targetIterationTimeMs } = this.values.illumination;
    return {
      ...giProps,
      enabled: isPreview ? false : giProps.enabled,
      maxIterations: Math.ceil(Math.log2(Math.pow(2, giProps.maxIterations + extraIterations) * giProps.rendersPerFrame[1])),
      targetFps: 1e3 / targetIterationTimeMs,
      denoiseThreshold: [giProps.denoiseThreshold[0], giProps.denoiseThreshold[0]],
      rendersPerFrame: [1, 1]
    };
  }
  createPass(isPreview) {
    const c4 = this.plugin.canvas3d;
    const { colorBufferFloat, textureFloat } = c4.webgl.extensions;
    return c4.getImagePass({
      transparentBackground: this.values.transparent,
      cameraHelper: { axes: this.values.axes },
      multiSample: {
        ...c4.props.multiSample,
        mode: isPreview ? "off" : "on",
        sampleLevel: colorBufferFloat && textureFloat ? 4 : 2,
        reuseOcclusion: false
      },
      postprocessing: this.getPostprocessingProps(),
      marking: { ...c4.props.marking },
      illumination: this.getIlluminationProps(isPreview)
    });
  }
  get previewPass() {
    return this._previewPass || (this._previewPass = this.createPass(true));
  }
  get imagePass() {
    if (this._imagePass) {
      const c4 = this.plugin.canvas3d;
      this._imagePass.setProps({
        cameraHelper: { axes: this.values.axes },
        transparentBackground: this.values.transparent,
        postprocessing: this.getPostprocessingProps(),
        marking: { ...c4.props.marking },
        illumination: this.getIlluminationProps(false)
      });
      return this._imagePass;
    }
    return this._imagePass = this.createPass(false);
  }
  getFilename(extension2) {
    if (typeof extension2 !== "string")
      extension2 = this.extension;
    const models = this.plugin.state.data.select(StateSelection.Generators.rootsOfType(PluginStateObject.Molecule.Model)).map((s) => s.obj.data);
    const uniqueIds = /* @__PURE__ */ new Set();
    models.forEach((m) => uniqueIds.add(m.entryId.toUpperCase()));
    const idString = SetUtils.toArray(uniqueIds).join("-");
    return `${idString || "molstar-image"}${extension2}`;
  }
  resetCrop() {
    this.behaviors.relativeCrop.next({ x: 0, y: 0, width: 1, height: 1 });
  }
  toggleAutocrop() {
    if (this.cropParams.auto) {
      this.behaviors.cropParams.next({ ...this.cropParams, auto: false });
      this.resetCrop();
    } else {
      this.behaviors.cropParams.next({ ...this.cropParams, auto: true });
    }
  }
  get isFullFrame() {
    const crop = this.relativeCrop;
    return equalEps(crop.x, 0, 1e-5) && equalEps(crop.y, 0, 1e-5) && equalEps(crop.width, 1, 1e-5) && equalEps(crop.height, 1, 1e-5);
  }
  autocrop(relativePadding = this.cropParams.relativePadding) {
    const { data, width, height } = this.previewData.image;
    const isTransparent = this.previewData.transparent;
    const bgColor = isTransparent ? this.previewData.background : 4278190080 | this.previewData.background;
    let l = width, r = 0, t4 = height, b4 = 0;
    for (let j = 0; j < height; j++) {
      const jj = j * width;
      for (let i = 0; i < width; i++) {
        const o = 4 * (jj + i);
        if (isTransparent) {
          if (data[o + 3] === 0)
            continue;
        } else {
          const c4 = data[o] << 16 | data[o + 1] << 8 | data[o + 2] | data[o + 3] << 24;
          if (c4 === bgColor)
            continue;
        }
        if (i < l)
          l = i;
        if (i > r)
          r = i;
        if (j < t4)
          t4 = j;
        if (j > b4)
          b4 = j;
      }
    }
    if (l > r) {
      const x = l;
      l = r;
      r = x;
    }
    if (t4 > b4) {
      const x = t4;
      t4 = b4;
      b4 = x;
    }
    const tw = r - l + 1, th = b4 - t4 + 1;
    l -= relativePadding * tw;
    r += relativePadding * tw;
    t4 -= relativePadding * th;
    b4 += relativePadding * th;
    const crop = {
      x: Math.max(0, l / width),
      y: Math.max(0, t4 / height),
      width: Math.min(1, (r - l + 1) / width),
      height: Math.min(1, (b4 - t4 + 1) / height)
    };
    this.behaviors.relativeCrop.next(crop);
  }
  async getPreview(ctx, maxDim = 320) {
    const { width, height } = this.getSize();
    if (width <= 0 || height <= 0)
      return;
    const f = width / height;
    let w = 0, h = 0;
    if (f > 1) {
      w = maxDim;
      h = Math.round(maxDim / f);
    } else {
      h = maxDim;
      w = Math.round(maxDim * f);
    }
    const canvasProps = this.plugin.canvas3d.props;
    this.previewPass.setProps({
      cameraHelper: { axes: this.values.axes },
      transparentBackground: this.values.transparent,
      postprocessing: canvasProps.postprocessing,
      marking: canvasProps.marking
    });
    const imageData = await this.previewPass.getImageData(ctx, w, h);
    const canvas = this.previewCanvas;
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    this.previewData.image = imageData;
    this.previewData.background = canvasProps.renderer.backgroundColor;
    this.previewData.transparent = this.values.transparent;
    const canvasCtx = canvas.getContext("2d");
    if (!canvasCtx)
      throw new Error("Could not create canvas 2d context");
    canvasCtx.putImageData(imageData, 0, 0);
    if (this.cropParams.auto)
      this.autocrop();
    this.events.previewed.next(void 0);
    return { canvas, width: w, height: h };
  }
  getSizeAndViewport() {
    const { width, height } = this.getSize();
    const crop = this.relativeCrop;
    const viewport = {
      x: Math.floor(crop.x * width),
      y: Math.floor(crop.y * height),
      width: Math.ceil(crop.width * width),
      height: Math.ceil(crop.height * height)
    };
    if (viewport.width + viewport.x > width)
      viewport.width = width - viewport.x;
    if (viewport.height + viewport.y > height)
      viewport.height = height - viewport.y;
    return { width, height, viewport };
  }
  async draw(ctx) {
    var _a, _b;
    const { width, height, viewport } = this.getSizeAndViewport();
    if (width <= 0 || height <= 0)
      return;
    (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.pause(true);
    try {
      await ctx.update("Rendering image...");
      const pass = this.imagePass;
      await pass.updateBackground();
      const imageData = await pass.getImageData(ctx, width, height, viewport);
      await ctx.update("Encoding image...");
      const canvas = this.canvas;
      canvas.width = imageData.width;
      canvas.height = imageData.height;
      const canvasCtx = canvas.getContext("2d");
      if (!canvasCtx)
        throw new Error("Could not create canvas 2d context");
      canvasCtx.putImageData(imageData, 0, 0);
    } finally {
      (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.animate();
    }
    return;
  }
  copyToClipboardTask() {
    const cb = navigator.clipboard;
    if (!(cb === null || cb === void 0 ? void 0 : cb.write)) {
      this.plugin.log.error("clipboard.write not supported!");
      return;
    }
    return Task.create("Copy Image", async (ctx) => {
      await this.draw(ctx);
      await ctx.update("Converting image...");
      const mime = this.mimeType;
      const blob = await canvasToBlob(this.canvas, mime, this.quality);
      const item = new ClipboardItem({ [mime]: blob });
      await cb.write([item]);
      this.plugin.log.message("Image copied to clipboard.");
    });
  }
  get mimeType() {
    var _a, _b;
    return `image/${(_b = (_a = this.values.format) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "png"}`;
  }
  get extension() {
    var _a, _b, _c;
    switch ((_a = this.values.format) === null || _a === void 0 ? void 0 : _a.name) {
      case "jpeg":
        return ".jpg";
      default:
        return `.${(_c = (_b = this.values.format) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "png"}`;
    }
  }
  get quality() {
    var _a, _b, _c, _d;
    switch ((_a = this.values.format) === null || _a === void 0 ? void 0 : _a.name) {
      case "webp":
      case "jpeg":
        return (_d = (_c = (_b = this.values.format) === null || _b === void 0 ? void 0 : _b.params) === null || _c === void 0 ? void 0 : _c.quality) !== null && _d !== void 0 ? _d : 0.9;
      default:
        return void 0;
    }
  }
  getImageDataUri() {
    return this.plugin.runTask(Task.create("Generate Image", async (ctx) => {
      await this.draw(ctx);
      await ctx.update("Converting image...");
      return this.canvas.toDataURL(this.mimeType);
    }));
  }
  copyToClipboard() {
    const task = this.copyToClipboardTask();
    if (!task)
      return;
    return this.plugin.runTask(task);
  }
  downloadTask(filename) {
    return Task.create("Download Image", async (ctx) => {
      await this.draw(ctx);
      await ctx.update("Downloading image...");
      const blob = await canvasToBlob(this.canvas, this.mimeType, this.quality);
      download(blob, filename !== null && filename !== void 0 ? filename : this.getFilename(this.extension));
    });
  }
  download(filename) {
    return this.plugin.runTask(this.downloadTask(filename), { useOverlay: true });
  }
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this._params = void 0;
    this.behaviors = {
      values: this.ev.behavior({
        transparent: this.params.transparent.defaultValue,
        format: { name: "png", params: {} },
        axes: { name: "off", params: {} },
        resolution: this.params.resolution.defaultValue,
        illumination: this.params.illumination.defaultValue
      }),
      cropParams: this.ev.behavior({ auto: true, relativePadding: 0.1 }),
      relativeCrop: this.ev.behavior({ x: 0, y: 0, width: 1, height: 1 })
    };
    this.events = {
      previewed: this.ev()
    };
    this.canvas = function() {
      const canvas = document.createElement("canvas");
      return canvas;
    }();
    this.previewCanvas = function() {
      const canvas = document.createElement("canvas");
      return canvas;
    }();
    this.previewData = {
      image: { data: new Uint8ClampedArray(1), width: 1, height: 0 },
      background: Color(0),
      transparent: false
    };
  }
};

// node_modules/molstar/lib/mol-plugin-state/manager/drag-and-drop.js
var DragAndDropManager = class {
  addHandler(name2, handler) {
    const index2 = this.handlers.findIndex((h) => h[0] === name2);
    if (index2 < 0)
      this.handlers.push([name2, handler]);
    else
      this.handlers[index2][1] = handler;
  }
  removeHandler(name2) {
    const index2 = this.handlers.findIndex((h) => h[0] === name2);
    if (index2 >= 0)
      this.handlers.splice(index2, 1);
  }
  async handle(files) {
    for (let i = this.handlers.length - 1; i >= 0; i--) {
      const handler = this.handlers[i][1];
      const handled = await handler(files, this.plugin);
      if (handled)
        return;
    }
    defaultDragAndDropHandler(this.plugin, files);
  }
  dispose() {
    this.handlers.length = 0;
  }
  constructor(plugin) {
    this.plugin = plugin;
    this.handlers = [];
  }
};
function defaultDragAndDropHandler(plugin, files) {
  const sessions = files.filter((f) => {
    const fn = f.name.toLowerCase();
    return fn.endsWith(".molx") || fn.endsWith(".molj");
  });
  if (sessions.length > 0) {
    PluginCommands.State.Snapshots.OpenFile(plugin, { file: sessions[0] });
  } else {
    plugin.runTask(plugin.state.data.applyAction(OpenFiles, {
      files: files.map((f) => Asset.File(f)),
      format: { name: "auto", params: {} },
      visuals: true
    }));
  }
}

// node_modules/molstar/lib/mol-util/error-context.js
var ErrorContext = class {
  constructor() {
    this.errors = /* @__PURE__ */ Object.create(null);
  }
  get(tag) {
    var _a;
    return (_a = this.errors[tag]) !== null && _a !== void 0 ? _a : [];
  }
  add(tag, error) {
    if (tag in this.errors && Array.isArray(this.errors[tag])) {
      this.errors[tag].push(error);
    } else {
      this.errors[tag] = [error];
    }
  }
  clear(tag) {
    delete this.errors[tag];
  }
};

// node_modules/molstar/lib/mol-plugin/context.js
var PluginContext = class {
  get isInitialized() {
    return this._isInitialized;
  }
  build() {
    return this.state.data.build();
  }
  initContainer(options) {
    var _a;
    if (this.canvasContainer)
      return true;
    const container = document.createElement("div");
    Object.assign(container.style, {
      position: "absolute",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      "-webkit-user-select": "none",
      "user-select": "none",
      "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
      "-webkit-touch-callout": "none",
      "touch-action": "manipulation"
    });
    let canvas = (_a = options === null || options === void 0 ? void 0 : options.canvas3dContext) === null || _a === void 0 ? void 0 : _a.canvas;
    if (!canvas) {
      canvas = document.createElement("canvas");
      if (options === null || options === void 0 ? void 0 : options.checkeredCanvasBackground) {
        Object.assign(canvas.style, {
          "background-image": "linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%, lightgrey), linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%, lightgrey)",
          "background-size": "60px 60px",
          "background-position": "0 0, 30px 30px"
        });
      }
      container.appendChild(canvas);
    }
    if (!this.initViewer(canvas, container, options === null || options === void 0 ? void 0 : options.canvas3dContext)) {
      return false;
    }
    this.canvasContainer = container;
    return true;
  }
  /**
   * Mount the plugin into the target element (assumes the target has "relative"-like positioninig).
   * If initContainer wasn't called separately before, initOptions will be passed to it.
   */
  mount(target, initOptions) {
    var _a;
    if (this.disposed)
      throw new Error("Cannot mount a disposed context");
    if (!this.initContainer(initOptions))
      return false;
    if (this.canvasContainer.parentElement !== target) {
      (_a = this.canvasContainer.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.canvasContainer);
    }
    target.appendChild(this.canvasContainer);
    this.handleResize();
    return true;
  }
  unmount() {
    var _a, _b;
    (_b = (_a = this.canvasContainer) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this.canvasContainer);
  }
  initViewer(canvas, container, canvas3dContext) {
    var _a, _b, _c, _d, _e, _f;
    try {
      this.layout.setRoot(container);
      if (this.spec.layout && this.spec.layout.initial)
        this.layout.setProps(this.spec.layout.initial);
      if (!canvas3dContext) {
        canvas3dContext = Canvas3DContext.fromCanvas(canvas, this.managers.asset, {
          antialias: !((_a = this.config.get(PluginConfig.General.DisableAntialiasing)) !== null && _a !== void 0 ? _a : false),
          preserveDrawingBuffer: !((_b = this.config.get(PluginConfig.General.DisablePreserveDrawingBuffer)) !== null && _b !== void 0 ? _b : false),
          preferWebGl1: this.config.get(PluginConfig.General.PreferWebGl1) || false,
          failIfMajorPerformanceCaveat: !((_c = this.config.get(PluginConfig.General.AllowMajorPerformanceCaveat)) !== null && _c !== void 0 ? _c : false),
          powerPreference: this.config.get(PluginConfig.General.PowerPreference) || "high-performance",
          handleResize: this.handleResize
        }, {
          pixelScale: this.config.get(PluginConfig.General.PixelScale) || 1,
          pickScale: this.config.get(PluginConfig.General.PickScale) || 0.25,
          transparency: this.config.get(PluginConfig.General.Transparency) || "wboit",
          resolutionMode: this.config.get(PluginConfig.General.ResolutionMode) || "auto"
        });
      }
      this.canvas3dContext = canvas3dContext;
      this.canvas3d = Canvas3D.create(this.canvas3dContext);
      this.canvas3dInit.next(true);
      let props = this.spec.canvas3d;
      const backgroundColor = Color(16579577);
      if (!props) {
        (_d = this.canvas3d) === null || _d === void 0 ? void 0 : _d.setProps({ renderer: { backgroundColor } });
      } else {
        if (((_e = props.renderer) === null || _e === void 0 ? void 0 : _e.backgroundColor) === void 0) {
          props = produce(props, (p) => {
            if (p.renderer)
              p.renderer.backgroundColor = backgroundColor;
            else
              p.renderer = { backgroundColor };
          });
        }
        (_f = this.canvas3d) === null || _f === void 0 ? void 0 : _f.setProps(props);
      }
      this.animationLoop.start();
      this.helpers.viewportScreenshot = new ViewportScreenshotHelper(this);
      this.subs.push(this.canvas3d.interaction.click.subscribe((e) => this.behaviors.interaction.click.next(e)));
      this.subs.push(this.canvas3d.interaction.drag.subscribe((e) => this.behaviors.interaction.drag.next(e)));
      this.subs.push(this.canvas3d.interaction.hover.subscribe((e) => this.behaviors.interaction.hover.next(e)));
      this.subs.push(this.canvas3d.input.resize.pipe(debounceTime(50), throttleTime(100, void 0, { leading: false, trailing: true })).subscribe(() => this.handleResize()));
      this.subs.push(this.canvas3d.input.keyDown.subscribe((e) => this.behaviors.interaction.key.next(e)));
      this.subs.push(this.canvas3d.input.keyUp.subscribe((e) => this.behaviors.interaction.keyReleased.next(e)));
      this.subs.push(this.layout.events.updated.subscribe(() => requestAnimationFrame(() => this.handleResize())));
      this.handleResize();
      Scheduler.setImmediate(() => this.initCanvas3dPromiseCallbacks[0]());
      return true;
    } catch (e) {
      this.log.error("" + e);
      console.error(e);
      Scheduler.setImmediate(() => this.initCanvas3dPromiseCallbacks[1](e));
      return false;
    }
  }
  /** return true is animating or updating */
  get isBusy() {
    return this.behaviors.state.isAnimating.value || this.behaviors.state.isUpdating.value;
  }
  get selectionMode() {
    return this.behaviors.interaction.selectionMode.value;
  }
  set selectionMode(mode) {
    this.behaviors.interaction.selectionMode.next(mode);
  }
  dataTransaction(f, options) {
    return this.runTask(this.state.data.transaction(f, options));
  }
  clear(resetViewportSettings = false) {
    var _a;
    if (resetViewportSettings)
      (_a = this.canvas3d) === null || _a === void 0 ? void 0 : _a.setProps(DefaultCanvas3DParams);
    return PluginCommands.State.RemoveObject(this, { state: this.state.data, ref: Transform.RootRef });
  }
  dispose(options) {
    var _a, _b;
    if (this.disposed)
      return;
    for (const s of this.subs) {
      s.unsubscribe();
    }
    this.subs = [];
    this.animationLoop.stop();
    this.commands.dispose();
    (_a = this.canvas3d) === null || _a === void 0 ? void 0 : _a.dispose();
    if (!(options === null || options === void 0 ? void 0 : options.doNotDisposeCanvas3DContext)) {
      (_b = this.canvas3dContext) === null || _b === void 0 ? void 0 : _b.dispose(options);
    }
    this.ev.dispose();
    this.state.dispose();
    this.helpers.substructureParent.dispose();
    objectForEach(this.managers, (m) => {
      var _a2;
      return (_a2 = m === null || m === void 0 ? void 0 : m.dispose) === null || _a2 === void 0 ? void 0 : _a2.call(m);
    });
    objectForEach(this.managers.structure, (m) => {
      var _a2;
      return (_a2 = m === null || m === void 0 ? void 0 : m.dispose) === null || _a2 === void 0 ? void 0 : _a2.call(m);
    });
    objectForEach(this.managers.volume, (m) => {
      var _a2;
      return (_a2 = m === null || m === void 0 ? void 0 : m.dispose) === null || _a2 === void 0 ? void 0 : _a2.call(m);
    });
    this.unmount();
    this.canvasContainer = void 0;
    this.customState = {};
    this.disposed = true;
  }
  initBehaviorEvents() {
    this.subs.push(merge(this.state.data.behaviors.isUpdating, this.state.behaviors.behaviors.isUpdating).subscribe((u2) => {
      if (this.behaviors.state.isUpdating.value !== u2)
        this.behaviors.state.isUpdating.next(u2);
    }));
    const timeoutMs = this.config.get(PluginConfig.General.IsBusyTimeoutMs) || 750;
    const isBusy = this.behaviors.state.isBusy;
    let timeout2 = void 0;
    const setBusy = () => {
      if (!isBusy.value)
        isBusy.next(true);
    };
    const reset = () => {
      if (timeout2 !== void 0)
        clearTimeout(timeout2);
      timeout2 = void 0;
    };
    this.subs.push(merge(this.behaviors.state.isUpdating, this.behaviors.state.isAnimating).subscribe((v2) => {
      const isUpdating = this.behaviors.state.isUpdating.value;
      const isAnimating = this.behaviors.state.isAnimating.value;
      if (isUpdating || isAnimating) {
        if (!isBusy.value) {
          reset();
          timeout2 = setTimeout(setBusy, timeoutMs);
        }
      } else {
        reset();
        isBusy.next(false);
      }
    }));
    this.subs.push(this.behaviors.interaction.selectionMode.subscribe((v2) => {
      var _a;
      if (!v2) {
        (_a = this.managers.interactivity) === null || _a === void 0 ? void 0 : _a.lociSelects.deselectAll();
      }
    }));
  }
  initBuiltInBehavior() {
    BuiltInPluginBehaviors.State.registerDefault(this);
    BuiltInPluginBehaviors.Representation.registerDefault(this);
    BuiltInPluginBehaviors.Camera.registerDefault(this);
    BuiltInPluginBehaviors.Misc.registerDefault(this);
    this.subs.push(merge(this.state.data.events.log, this.state.behaviors.events.log).subscribe((e) => this.events.log.next(e)));
  }
  async initBehaviors() {
    let tree = this.state.behaviors.build();
    for (const cat of Object.keys(PluginBehavior.Categories)) {
      tree.toRoot().apply(PluginBehavior.CreateCategory, { label: PluginBehavior.Categories[cat] }, { ref: cat, state: { isLocked: true } });
    }
    for (const b4 of this.spec.behaviors) {
      const cat = PluginBehavior.getCategoryId(b4.transformer);
      if (cat !== "custom-props")
        continue;
      tree.to(PluginBehavior.getCategoryId(b4.transformer)).apply(b4.transformer, b4.defaultParams, { ref: b4.transformer.id });
    }
    await this.runTask(this.state.behaviors.updateTree(tree, { doNotUpdateCurrent: true, doNotLogTiming: true }));
    tree = this.state.behaviors.build();
    for (const b4 of this.spec.behaviors) {
      const cat = PluginBehavior.getCategoryId(b4.transformer);
      if (cat === "custom-props")
        continue;
      tree.to(PluginBehavior.getCategoryId(b4.transformer)).apply(b4.transformer, b4.defaultParams, { ref: b4.transformer.id });
    }
    await this.runTask(this.state.behaviors.updateTree(tree, { doNotUpdateCurrent: true, doNotLogTiming: true }));
  }
  initCustomFormats() {
    if (!this.spec.customFormats)
      return;
    for (const f of this.spec.customFormats) {
      this.dataFormats.add(f[0], f[1]);
    }
  }
  initAnimations() {
    if (!this.spec.animations)
      return;
    for (const anim of this.spec.animations) {
      this.managers.animation.register(anim);
    }
  }
  initDataActions() {
    if (!this.spec.actions)
      return;
    for (const a4 of this.spec.actions) {
      this.state.data.actions.add(a4.action);
    }
  }
  async init() {
    try {
      this.subs.push(this.events.log.subscribe((e) => this.log.entries = this.log.entries.push(e)));
      this.initCustomFormats();
      this.initBehaviorEvents();
      this.initBuiltInBehavior();
      this.managers.interactivity = new InteractivityManager(this);
      this.managers.lociLabels = new LociLabelManager(this);
      this.builders.structure = new StructureBuilder(this);
      this.initAnimations();
      this.initDataActions();
      await this.initBehaviors();
      this.log.message(`Mol* Plugin ${PLUGIN_VERSION} [${PLUGIN_VERSION_DATE.toLocaleString()}]`);
      if (!isProductionMode)
        this.log.message(`Development mode enabled`);
      if (isDebugMode)
        this.log.message(`Debug mode enabled`);
      this._isInitialized = true;
      this.initializedPromiseCallbacks[0]();
    } catch (err) {
      this.initializedPromiseCallbacks[1](err);
      throw err;
    }
  }
  constructor(spec) {
    var _a;
    this.spec = spec;
    this.runTask = (task, params) => this.managers.task.run(task, params);
    this.resolveTask = (object) => {
      if (!object)
        return void 0;
      if (Task.is(object))
        return this.runTask(object);
      return object;
    };
    this.subs = [];
    this.initCanvas3dPromiseCallbacks = [() => {
    }, () => {
    }];
    this._isInitialized = false;
    this.initializedPromiseCallbacks = [() => {
    }, () => {
    }];
    this.disposed = false;
    this.canvasContainer = void 0;
    this.ev = RxEventHelper.create();
    this.config = new PluginConfigManager(this.spec.config);
    this.state = new PluginState(this);
    this.commands = new PluginCommandManager();
    this.canvas3dInit = this.ev.behavior(false);
    this.behaviors = {
      state: {
        isAnimating: this.ev.behavior(false),
        isUpdating: this.ev.behavior(false),
        // TODO: should there be separate "updated" event?
        //   Often, this is used to indicate that the state has updated
        //   and it might not be the best way to react to state updates.
        isBusy: this.ev.behavior(false)
      },
      interaction: {
        hover: this.ev.behavior({ current: Representation.Loci.Empty, modifiers: ModifiersKeys.None, buttons: 0, button: 0 }),
        click: this.ev.behavior({ current: Representation.Loci.Empty, modifiers: ModifiersKeys.None, buttons: 0, button: 0 }),
        drag: this.ev.behavior({ current: Representation.Loci.Empty, modifiers: ModifiersKeys.None, buttons: 0, button: 0, pageStart: Vec2(), pageEnd: Vec2() }),
        key: this.ev.behavior(EmptyKeyInput),
        keyReleased: this.ev.behavior(EmptyKeyInput),
        selectionMode: this.ev.behavior(false)
      },
      labels: {
        highlight: this.ev.behavior({ labels: [] })
      },
      layout: {
        leftPanelTabName: this.ev.behavior("root")
      },
      canvas3d: {
        // TODO: remove in 4.0?
        initialized: this.canvas3dInit.pipe(filter((v2) => !!v2), take(1))
      }
    };
    this.canvas3dInitialized = new Promise((res, rej) => {
      this.initCanvas3dPromiseCallbacks = [res, rej];
    });
    this.initialized = new Promise((res, rej) => {
      this.initializedPromiseCallbacks = [res, rej];
    });
    this.layout = new PluginLayout(this);
    this.animationLoop = new PluginAnimationLoop(this);
    this.representation = {
      structure: {
        registry: new StructureRepresentationRegistry(),
        themes: { colorThemeRegistry: ColorTheme.createRegistry(), sizeThemeRegistry: SizeTheme.createRegistry() }
      },
      volume: {
        registry: new VolumeRepresentationRegistry(),
        themes: { colorThemeRegistry: ColorTheme.createRegistry(), sizeThemeRegistry: SizeTheme.createRegistry() }
      }
    };
    this.query = {
      structure: {
        registry: new StructureSelectionQueryRegistry()
      }
    };
    this.dataFormats = new DataFormatRegistry();
    this.builders = {
      data: new DataBuilder(this),
      structure: void 0
    };
    this.helpers = {
      substructureParent: new SubstructureParentHelper(this),
      viewportScreenshot: void 0
    };
    this.managers = {
      structure: {
        hierarchy: new StructureHierarchyManager(this),
        component: new StructureComponentManager(this),
        measurement: new StructureMeasurementManager(this),
        selection: new StructureSelectionManager(this),
        focus: new StructureFocusManager(this)
      },
      volume: {
        hierarchy: new VolumeHierarchyManager(this)
      },
      interactivity: void 0,
      camera: new CameraManager(this),
      animation: new PluginAnimationManager(this),
      snapshot: new PluginStateSnapshotManager(this),
      lociLabels: void 0,
      toast: new PluginToastManager(this),
      asset: new AssetManager(),
      task: new TaskManager(),
      dragAndDrop: new DragAndDropManager(this)
    };
    this.events = {
      log: this.ev(),
      task: this.managers.task.events,
      canvas3d: {
        settingsUpdated: this.ev()
      }
    };
    this.customModelProperties = new CustomProperty.Registry();
    this.customStructureProperties = new CustomProperty.Registry();
    this.customStructureControls = /* @__PURE__ */ new Map();
    this.customImportControls = /* @__PURE__ */ new Map();
    this.genericRepresentationControls = /* @__PURE__ */ new Map();
    this.errorContext = new ErrorContext();
    this.customState = /* @__PURE__ */ Object.create(null);
    this.handleResize = () => {
      var _a2, _b;
      const canvas = (_a2 = this.canvas3dContext) === null || _a2 === void 0 ? void 0 : _a2.canvas;
      const container = this.layout.root;
      if (container && canvas) {
        resizeCanvas(canvas, container, this.canvas3dContext.pixelScale);
        this.canvas3dContext.syncPixelScale();
        (_b = this.canvas3d) === null || _b === void 0 ? void 0 : _b.requestResize();
      }
    };
    this.log = {
      entries: List(),
      entry: (e) => this.events.log.next(e),
      error: (msg) => this.events.log.next(LogEntry.error(msg)),
      message: (msg) => this.events.log.next(LogEntry.message(msg)),
      info: (msg) => this.events.log.next(LogEntry.info(msg)),
      warn: (msg) => this.events.log.next(LogEntry.warning(msg))
    };
    this.fetch = ajaxGet;
    setAutoFreeze(false);
    setSaccharideCompIdMapType((_a = this.config.get(PluginConfig.Structure.SaccharideCompIdMapType)) !== null && _a !== void 0 ? _a : "default");
  }
};

// node_modules/molstar/lib/mol-plugin-ui/context.js
var PluginUIContext = class extends PluginContext {
  initCustomParamEditors() {
    if (!this.spec.customParamEditors)
      return;
    for (const [t4, e] of this.spec.customParamEditors) {
      this.customParamEditors.set(t4.id, e);
    }
  }
  dispose(options) {
    super.dispose(options);
    this.layout.dispose();
  }
  constructor(spec) {
    super(spec);
    this.spec = spec;
    this.customParamEditors = /* @__PURE__ */ new Map();
    this.initCustomParamEditors();
  }
};

// node_modules/molstar/lib/mol-plugin-ui/index.js
async function createPluginUI(options) {
  const { spec, target, onBeforeUIRender, render } = options;
  const ctx = new PluginUIContext(spec || DefaultPluginUISpec());
  await ctx.init();
  if (onBeforeUIRender) {
    await onBeforeUIRender(ctx);
  }
  render((0, import_react6.createElement)(Plugin, { plugin: ctx }), target);
  try {
    await ctx.canvas3dInitialized;
  } catch (_a) {
  }
  return ctx;
}
export {
  createPluginUI
};
//# sourceMappingURL=molstar_lib_mol-plugin-ui.js.map
